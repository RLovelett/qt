diff --git a/configure b/configure
index e58180a..b5f9c28 100755
--- a/configure
+++ b/configure
@@ -1932,6 +1932,9 @@ while [ "$#" -gt 0 ]; do
             UNKNOWN_OPT=yes
         fi
         ;;
+    hildon)
+        CFG_HILDON="yes"
+        ;;
     *)
         UNKNOWN_OPT=yes
         ;;
@@ -2784,8 +2787,8 @@ fi
 
 # auto-detect support for separate debug info in objcopy
 if [ "$CFG_SEPARATE_DEBUG_INFO" != "no" ] && [ "$CFG_SHARED" = "yes" ]; then
-    TEST_COMPILER_CFLAGS=`getQMakeConf "$XQMAKESPEC" | sed -n -e 's%QMAKE_CFLAGS[^_].*=%%p' | tr '\n' ' '`
-    TEST_COMPILER_CXXFLAGS=`getQMakeConf "$XQMAKESPEC" | sed -n -e 's%QMAKE_CXXFLAGS[^_].*=%%p' | tr '\n' ' '`
+    TEST_COMPILER_CFLAGS=`getQMakeConf "$XQMAKESPEC" | sed -n -e 's%QMAKE_CFLAGS[^_][^=]*=%%p' | tr '\n' ' '`
+    TEST_COMPILER_CXXFLAGS=`getQMakeConf "$XQMAKESPEC" | sed -n -e 's%QMAKE_CXXFLAGS[^_][^=]*=%%p' | tr '\n' ' '`
     TEST_OBJCOPY=`getQMakeConf "$XQMAKESPEC" | grep "^QMAKE_OBJCOPY" | sed "s%.* *= *\(.*\)$%\1%" | tail -1`
     COMPILER_WITH_FLAGS="$TEST_COMPILER $TEST_COMPILER_CXXFLAGS"
     COMPILER_WITH_FLAGS=`echo "$COMPILER_WITH_FLAGS" | sed -e "s%\\$\\$QMAKE_CFLAGS%$TEST_COMPILER_CFLAGS%g"`
@@ -3073,8 +3076,8 @@ Usage:  $relconf [-h] [-prefix <dir>] [-prefix-install] [-bindir <dir>] [-libdir
         [-no-separate-debug-info] [-no-mmx] [-no-3dnow] [-no-sse] [-no-sse2]
         [-qtnamespace <namespace>] [-qtlibinfix <infix>] [-separate-debug-info] [-armfpa]
         [-no-optimized-qmake] [-optimized-qmake] [-no-xmlpatterns] [-xmlpatterns]
-        [-no-phonon] [-phonon] [-no-phonon-backend] [-phonon-backend]
-        [-no-openssl] [-openssl] [-openssl-linked]
+        [-no-phonon] [-phonon] [-no-phonon-backend] [-phonon-backend] [-hildon]
+	[-no-openssl] [-openssl] [-openssl-linked]
         [-no-gtkstyle] [-gtkstyle] [-no-svg] [-svg] [-no-webkit] [-webkit]
         [-no-scripttools] [-scripttools]
 
@@ -5071,6 +5074,27 @@ if [ "$PLATFORM_X11" = "yes" ]; then
     elif [ "$CFG_GLIB" = "no" ]; then
         CFG_QGTKSTYLE=no
     fi
+
+    if [ "$CFG_HILDON" == "yes" -a "$CFG_QGTKSTYLE" = "yes" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_HILDON=`$PKG_CONFIG --cflags hildon-1 2>/dev/null`
+            #QT_LIBS_HILDON=`$PKG_CONFIG --libs gtk+-x11-2.0 hildon-1 2>/dev/null`
+            QMakeVar set QT_CFLAGS_HILDON "$QT_CFLAGS_HILDON"
+            #QMakeVar set QT_LIBS_HILDON "$QT_LIBS_HILDON"
+            #QMakeVar set styles "plastique gtk windows" #NO motif
+            # Add Hildon to config.h
+            QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XIM Q_WS_HILDON Q_OS_FREMANTLE QT_NO_SIZEGRIP"
+        else
+            echo "Hildon support cannot be enabled due to functionality test!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        fi
+    else
+        CFG_HILDON="no"
+    fi
+
 fi # X11
 
 
@@ -6594,6 +6618,9 @@ else
     QT_CONFIG="$QT_CONFIG qt_framework"
     QTCONFIG_CONFIG="$QTCONFIG_CONFIG qt_framework"
 fi
+if [ "$CFG_HILDON" == "yes" -a "$CFG_QGTKSTYLE" = "yes" ]; then
+	    QT_CONFIG="$QT_CONFIG hildon"
+fi
 if [ "$PLATFORM_MAC" = "yes" ]; then
     QT_CONFIG="$QT_CONFIG $CFG_MAC_ARCHS"
 fi
@@ -6949,6 +6976,7 @@ if [ "$PLATFORM_X11" = "yes" ]; then
     echo "XKB Support ......... $CFG_XKB"
     echo "immodule support .... $CFG_IM"
     echo "GTK theme support ... $CFG_QGTKSTYLE"
+    echo "Hildon support  ..... $CFG_HILDON"
 fi
 [ "$CFG_SQL_mysql" != "no" ] && echo "MySQL support ....... $CFG_SQL_mysql"
 [ "$CFG_SQL_psql" != "no" ] && echo "PostgreSQL support .. $CFG_SQL_psql"
diff --git a/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp b/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp
index dae0be5..0f69d51 100644
--- a/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp
+++ b/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp
@@ -243,7 +243,11 @@ void HTMLInputElement::aboutToUnload()
 
 bool HTMLInputElement::shouldUseInputMethod() const
 {
+#ifdef Q_WS_HILDON
+    return m_type == TEXT || m_type == SEARCH || m_type == ISINDEX || m_type == PASSWORD ;
+#else
     return m_type == TEXT || m_type == SEARCH || m_type == ISINDEX;
+#endif
 }
 
 void HTMLInputElement::dispatchFocusEvent()
diff --git a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
index 01b68eb..107e32e 100644
--- a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
+++ b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
@@ -93,6 +93,10 @@
 #include "qwebnetworkinterface.h"
 #endif
 
+#ifdef Q_WS_HILDON
+#include <QInputContext>
+#endif
+
 using namespace WebCore;
 
 bool QWebPagePrivate::drtRun = false;
@@ -1009,6 +1013,18 @@ bool QWebPagePrivate::handleScrolling(QKeyEvent *ev)
 */
 QVariant QWebPage::inputMethodQuery(Qt::InputMethodQuery property) const
 {
+#ifdef Q_WS_HILDON
+    //Return input method query values only for input elements
+    Frame *frame = d->page->focusController()->focusedOrMainFrame();
+    if (!frame){
+         return QVariant();
+    }
+    Editor* editor = frame->editor();
+    if (!editor->canEdit()){
+        return QVariant();
+    }
+#endif	
+
     switch(property) {
     case Qt::ImMicroFocus: {
         Frame *frame = d->page->focusController()->focusedFrame();
@@ -1045,6 +1061,22 @@ QVariant QWebPage::inputMethodQuery(Qt::InputMethodQuery property) const
     }
     case Qt::ImCurrentSelection:
         return QVariant(selectedText());
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:{
+        int mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_DICTIONARY;
+        Frame *frame = d->page->focusController()->focusedFrame();
+        if (frame) {
+            Document *document = frame->document();
+            if (document) {
+                Element* element = static_cast<Element*>(document->focusedNode());
+                if (element && element->isPasswordField()) {
+                    mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_INVISIBLE;
+                }
+            }
+        }
+        return QVariant(mode);
+    }
+#endif
     default:
         return QVariant();
     }
diff --git a/src/corelib/global/qnamespace.h b/src/corelib/global/qnamespace.h
index 6a9df3a..33a2f39 100644
--- a/src/corelib/global/qnamespace.h
+++ b/src/corelib/global/qnamespace.h
@@ -1390,6 +1390,9 @@ public:
         ImFont,
         ImCursorPosition,
         ImSurroundingText,
+#ifdef Q_WS_HILDON
+	ImMode,
+#endif
         ImCurrentSelection
     };
 
diff --git a/src/gui/dialogs/qmessagebox.cpp b/src/gui/dialogs/qmessagebox.cpp
index b3522ce..ed25dc3 100644
--- a/src/gui/dialogs/qmessagebox.cpp
+++ b/src/gui/dialogs/qmessagebox.cpp
@@ -278,6 +278,8 @@ void QMessageBoxPrivate::updateSize()
 #elif defined(Q_OS_WINCE)
     // the width of the screen, less the window border.
     int hardLimit = screenSize.width() - (q->frameGeometry().width() - q->geometry().width());
+#elif defined(Q_WS_HILDON)
+    int hardLimit = screenSize.width() - (q->frameGeometry().width() - q->geometry().width());
 #else
     int hardLimit = qMin(screenSize.width() - 480, 1000); // can never get bigger than this
     // on small screens allows the messagebox be the same size as the screen
@@ -290,10 +292,12 @@ void QMessageBoxPrivate::updateSize()
     int softLimit = qMin(hardLimit, 500);
 #else
     // note: ideally on windows, hard and soft limits but it breaks compat
-#ifndef Q_OS_WINCE
-    int softLimit = qMin(screenSize.width()/2, 500);
-#else
+#ifdef Q_WS_HILDON
+    int softLimit = qMin(screenSize.width() * 2 / 3, 500);
+#elif Q_OS_WINCE
     int softLimit = qMin(screenSize.width() * 3 / 4, 500);
+#else
+    int softLimit = qMin(screenSize.width()/2, 500);
 #endif //Q_OS_WINCE
 #endif
 
diff --git a/src/gui/inputmethod/inputmethod.pri b/src/gui/inputmethod/inputmethod.pri
index d321cd4..0d2e09e 100644
--- a/src/gui/inputmethod/inputmethod.pri
+++ b/src/gui/inputmethod/inputmethod.pri
@@ -8,8 +8,11 @@ SOURCES +=inputmethod/qinputcontextfactory.cpp \
           inputmethod/qinputcontextplugin.cpp \
           inputmethod/qinputcontext.cpp
 x11 {
-    HEADERS += inputmethod/qximinputcontext_p.h
-    SOURCES += inputmethod/qximinputcontext_x11.cpp
+    HEADERS += inputmethod/qximinputcontext_p.h \
+               inputmethod/qhildoninputcontext_p.h \
+               inputmethod/qhildoninputmethodprotocol_p.h
+    SOURCES += inputmethod/qximinputcontext_x11.cpp \
+               inputmethod/qhildoninputcontext_x11.cpp
 }
 win32 {
     HEADERS += inputmethod/qwininputcontext_p.h
diff --git a/src/gui/inputmethod/qhildoninputcontext_p.h b/src/gui/inputmethod/qhildoninputcontext_p.h
new file mode 100644
index 0000000..a16ba38
--- /dev/null
+++ b/src/gui/inputmethod/qhildoninputcontext_p.h
@@ -0,0 +1,111 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+**
+** This file is part of the QtGui module of the Maemo Qt project.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QHILDONINPUTCONTEXT_P_H
+#define QHILDONINPUTCONTEXT_P_H
+
+#include "QtGui/qinputcontext.h"
+#include "qhildoninputmethodprotocol_p.h"
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_HEADER
+
+QT_MODULE(Gui)
+
+class QHildonInputContext : public QInputContext
+{
+    Q_OBJECT
+public:
+    explicit QHildonInputContext(QObject* parent = 0);
+    ~QHildonInputContext();
+
+    QString identifierName();
+    QString language();
+    void reset();
+    bool isComposing() const;
+    void setFocusWidget(QWidget *w);
+    bool eventFilter(QObject *obj, QEvent *event);
+    void update();
+
+protected:
+    void toggleHildonMainIMUi();
+    void timerEvent(QTimerEvent *);
+
+    //Filters
+    bool filterKeyPress(QWidget *w,QKeyEvent *ev);
+    bool x11FilterEvent(QWidget *keywidget, XEvent *event);
+
+private:
+    bool canUseIM(QWidget *w);
+    void insertUtf8(int flag, const QString& text);
+    void clearSelection();
+
+    void sendHildonCommand(HildonIMCommand cmd, QWidget *widget=0);
+    void sendX11Event(XEvent *event);
+    void showHIMMainUI();
+
+    //Context
+    void checkSentenceStart();
+    void commitPreeditData();
+    void checkCommitMode(); //### REMOVE?
+    void sendSurrounding(bool sendAllContents = false);
+    void sendSurroundingHeader(int offset);
+    void inputModeChanged();
+    void setClientCursorLocation(int offsetIsRelative, int cursorOffset); //FIXME?? Move offsetIsRelative to Bool?
+
+    //Vars
+    int timerId;
+    int mask;
+    int options;
+    HildonIMTrigger triggerMode;
+    HildonIMCommitMode commitMode;
+    int inputMode;
+    QString preEditBuffer;
+    QString surrounding;
+    int textCursorPosOnPress; //position of the cursor in the surrounding text at the last TabletPress event
+    bool autoUpper;
+    bool lastInternalChange;
+};
+
+QT_END_HEADER
+
+#endif // Q_WS_HILDON
+
+#endif //QHILDONINPUTCONTEXT_P_H
diff --git a/src/gui/inputmethod/qhildoninputcontext_x11.cpp b/src/gui/inputmethod/qhildoninputcontext_x11.cpp
new file mode 100644
index 0000000..843bd41
--- /dev/null
+++ b/src/gui/inputmethod/qhildoninputcontext_x11.cpp
@@ -0,0 +1,1674 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+**
+** This file is part of the QtGui module of the Maemo Qt project.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qdebug.h"
+#include "qhildoninputcontext_p.h"
+#include "qpointer.h"
+#include "qapplication.h"
+#include "qclipboard.h"
+#include "qplaintextedit.h"
+#include "qlineedit.h"
+#include "qtextedit.h"
+#include "qtextbrowser.h"
+#include "kernel/qevent_p.h"       //QKeyEventEx
+#include "kernel/qapplication_p.h" //QApplicationPrivate::areXInputEventsUsed()
+
+#ifdef Q_WS_HILDON 
+
+//#define HIM_DEBUG
+
+#define GDK_ISO_ENTER  0xfe34
+#define COMPOSE_KEY    Qt::Key_Multi_key   // "Ch" key
+#define LEVEL_KEY      Qt::Key_AltGr       //"Fn" key
+
+#define LEVEL_KEY_MOD_MASK   0x4
+#define STATE_LEVEL_KEY_MASK 0x80
+
+#define STATE_CONTROL_MASK  1 << 2
+#define STATE_SHIFT_MASK    1 << 0 
+
+//Keyboard layout levels
+#define NUMERIC_LEVEL 2
+#define LOCKABLE_LEVEL 4
+
+#define PRESSURE_THRESHOLD  0.40
+
+/* TODO
+   - Cleaning up
+
+   Fremantle:
+   - Read Gconf (?) Settings for Auto-Capitalization, Word completion and insert space after word
+     Currently these are switched on.
+   - TRIGGER STYLUS is sent all the time, this prevent the usage of fullscreen virtual keyboard (Bug tracked, waiting for a tix)
+   - sendSurrounding when sendAllContents == true
+   - hildon banner integration to show the modifiers status (Sticky/Lock).
+   - put Q_OS_FREMANTLE in configure
+
+   Diablo
+   - Fix dead key support 
+*/
+
+extern bool qt_sendSpontaneousEvent(QObject*, QEvent*); //qapplication_x11.cpp
+
+/*!
+ * keysym to QString functions
+ * These functions are part of qkeymapper_x11.cpp
+ */
+static const unsigned short katakanaKeysymsToUnicode[] = {
+    0x0000, 0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1,
+    0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3,
+    0x30FC, 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD,
+    0x30AF, 0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD,
+    0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC,
+    0x30CD, 0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE,
+    0x30DF, 0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9,
+    0x30EA, 0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
+};
+
+static const unsigned short cyrillicKeysymsToUnicode[] = {
+    0x0000, 0x0452, 0x0453, 0x0451, 0x0454, 0x0455, 0x0456, 0x0457,
+    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x0000, 0x045e, 0x045f,
+    0x2116, 0x0402, 0x0403, 0x0401, 0x0404, 0x0405, 0x0406, 0x0407,
+    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x0000, 0x040e, 0x040f,
+    0x044e, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433,
+    0x0445, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e,
+    0x043f, 0x044f, 0x0440, 0x0441, 0x0442, 0x0443, 0x0436, 0x0432,
+    0x044c, 0x044b, 0x0437, 0x0448, 0x044d, 0x0449, 0x0447, 0x044a,
+    0x042e, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413,
+    0x0425, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e,
+    0x041f, 0x042f, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412,
+    0x042c, 0x042b, 0x0417, 0x0428, 0x042d, 0x0429, 0x0427, 0x042a
+};
+
+static const unsigned short greekKeysymsToUnicode[] = {
+    0x0000, 0x0386, 0x0388, 0x0389, 0x038a, 0x03aa, 0x0000, 0x038c,
+    0x038e, 0x03ab, 0x0000, 0x038f, 0x0000, 0x0000, 0x0385, 0x2015,
+    0x0000, 0x03ac, 0x03ad, 0x03ae, 0x03af, 0x03ca, 0x0390, 0x03cc,
+    0x03cd, 0x03cb, 0x03b0, 0x03ce, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
+    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,
+    0x03a0, 0x03a1, 0x03a3, 0x0000, 0x03a4, 0x03a5, 0x03a6, 0x03a7,
+    0x03a8, 0x03a9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
+    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
+    0x03c0, 0x03c1, 0x03c3, 0x03c2, 0x03c4, 0x03c5, 0x03c6, 0x03c7,
+    0x03c8, 0x03c9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short technicalKeysymsToUnicode[] = {
+    0x0000, 0x23B7, 0x250C, 0x2500, 0x2320, 0x2321, 0x2502, 0x23A1,
+    0x23A3, 0x23A4, 0x23A6, 0x239B, 0x239D, 0x239E, 0x23A0, 0x23A8,
+    0x23AC, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x2264, 0x2260, 0x2265, 0x222B,
+    0x2234, 0x221D, 0x221E, 0x0000, 0x0000, 0x2207, 0x0000, 0x0000,
+    0x223C, 0x2243, 0x0000, 0x0000, 0x0000, 0x21D4, 0x21D2, 0x2261,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x221A, 0x0000,
+    0x0000, 0x0000, 0x2282, 0x2283, 0x2229, 0x222A, 0x2227, 0x2228,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2202,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0192, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x2190, 0x2191, 0x2192, 0x2193, 0x0000
+};
+
+static const unsigned short specialKeysymsToUnicode[] = {
+    0x25C6, 0x2592, 0x2409, 0x240C, 0x240D, 0x240A, 0x0000, 0x0000,
+    0x2424, 0x240B, 0x2518, 0x2510, 0x250C, 0x2514, 0x253C, 0x23BA,
+    0x23BB, 0x2500, 0x23BC, 0x23BD, 0x251C, 0x2524, 0x2534, 0x252C,
+    0x2502, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short publishingKeysymsToUnicode[] = {
+    0x0000, 0x2003, 0x2002, 0x2004, 0x2005, 0x2007, 0x2008, 0x2009,
+    0x200a, 0x2014, 0x2013, 0x0000, 0x0000, 0x0000, 0x2026, 0x2025,
+    0x2153, 0x2154, 0x2155, 0x2156, 0x2157, 0x2158, 0x2159, 0x215a,
+    0x2105, 0x0000, 0x0000, 0x2012, 0x2329, 0x0000, 0x232a, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x215b, 0x215c, 0x215d, 0x215e, 0x0000,
+    0x0000, 0x2122, 0x2613, 0x0000, 0x25c1, 0x25b7, 0x25cb, 0x25af,
+    0x2018, 0x2019, 0x201c, 0x201d, 0x211e, 0x0000, 0x2032, 0x2033,
+    0x0000, 0x271d, 0x0000, 0x25ac, 0x25c0, 0x25b6, 0x25cf, 0x25ae,
+    0x25e6, 0x25ab, 0x25ad, 0x25b3, 0x25bd, 0x2606, 0x2022, 0x25aa,
+    0x25b2, 0x25bc, 0x261c, 0x261e, 0x2663, 0x2666, 0x2665, 0x0000,
+    0x2720, 0x2020, 0x2021, 0x2713, 0x2717, 0x266f, 0x266d, 0x2642,
+    0x2640, 0x260e, 0x2315, 0x2117, 0x2038, 0x201a, 0x201e, 0x0000
+};
+
+static const unsigned short aplKeysymsToUnicode[] = {
+    0x0000, 0x0000, 0x0000, 0x003c, 0x0000, 0x0000, 0x003e, 0x0000,
+    0x2228, 0x2227, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x00af, 0x0000, 0x22a5, 0x2229, 0x230a, 0x0000, 0x005f, 0x0000,
+    0x0000, 0x0000, 0x2218, 0x0000, 0x2395, 0x0000, 0x22a4, 0x25cb,
+    0x0000, 0x0000, 0x0000, 0x2308, 0x0000, 0x0000, 0x222a, 0x0000,
+    0x2283, 0x0000, 0x2282, 0x0000, 0x22a2, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x22a3, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short koreanKeysymsToUnicode[] = {
+    0x0000, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137,
+    0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f,
+    0x3140, 0x3141, 0x3142, 0x3143, 0x3144, 0x3145, 0x3146, 0x3147,
+    0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f,
+    0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157,
+    0x3158, 0x3159, 0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f,
+    0x3160, 0x3161, 0x3162, 0x3163, 0x11a8, 0x11a9, 0x11aa, 0x11ab,
+    0x11ac, 0x11ad, 0x11ae, 0x11af, 0x11b0, 0x11b1, 0x11b2, 0x11b3,
+    0x11b4, 0x11b5, 0x11b6, 0x11b7, 0x11b8, 0x11b9, 0x11ba, 0x11bb,
+    0x11bc, 0x11bd, 0x11be, 0x11bf, 0x11c0, 0x11c1, 0x11c2, 0x316d,
+    0x3171, 0x3178, 0x317f, 0x3181, 0x3184, 0x3186, 0x318d, 0x318e,
+    0x11eb, 0x11f0, 0x11f9, 0x0000, 0x0000, 0x0000, 0x0000, 0x20a9
+};
+
+static QChar keysymToUnicode(unsigned char byte3, unsigned char byte4)
+{
+    switch (byte3) {
+    case 0x04:
+        // katakana
+        if (byte4 > 0xa0 && byte4 < 0xe0)
+            return QChar(katakanaKeysymsToUnicode[byte4 - 0xa0]);
+        else if (byte4 == 0x7e)
+            return QChar(0x203e); // Overline
+        break;
+    case 0x06:
+        // russian, use lookup table
+        if (byte4 > 0xa0)
+            return QChar(cyrillicKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x07:
+        // greek
+        if (byte4 > 0xa0)
+            return QChar(greekKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x08:
+        // technical
+        if (byte4 > 0xa0)
+            return QChar(technicalKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x09:
+        // special
+        if (byte4 >= 0xe0)
+            return QChar(specialKeysymsToUnicode[byte4 - 0xe0]);
+        break;
+    case 0x0a:
+        // publishing
+        if (byte4 > 0xa0)
+            return QChar(publishingKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x0b:
+        // APL
+        if (byte4 > 0xa0)
+            return QChar(aplKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x0e:
+        // Korean
+        if (byte4 > 0xa0)
+            return QChar(koreanKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    default:
+        break;
+    }
+    return QChar(0x0);
+}
+
+static QString translateKeySym(KeySym keysym)
+{
+    if (!keysym) 
+        return QString();
+
+    // all keysyms smaller than 0xff00 are actally keys that can be mapped to unicode chars
+    extern QTextCodec *qt_input_mapper; // from qapplication_x11.cpp
+    QTextCodec *mapper = qt_input_mapper;
+    QChar converted;
+
+    QByteArray chars;
+    int count=0;
+
+    if (keysym < 0xff00) {
+        unsigned char byte3 = (unsigned char)(keysym >> 8);
+        int mib = -1;
+        switch(byte3) {
+        case 0: // Latin 1
+        case 1: // Latin 2
+        case 2: //latin 3
+        case 3: // latin4
+            mib = byte3 + 4; break;
+        case 5: // arabic
+            mib = 82; break;
+        case 12: // Hebrew
+            mib = 85; break;
+        case 13: // Thai
+            mib = 2259; break;
+        case 4: // kana
+        case 6: // cyrillic
+        case 7: // greek
+        case 8: // technical, no mapping here at the moment
+        case 9: // Special
+        case 10: // Publishing
+        case 11: // APL
+        case 14: // Korean, no mapping
+            mib = -1; // manual conversion
+            mapper = 0;
+            converted = keysymToUnicode(byte3, keysym & 0xff);
+        case 0x20:
+            // currency symbols
+            if (keysym >= 0x20a0 && keysym <= 0x20ac) {
+                mib = -1; // manual conversion
+                mapper = 0;
+                converted = (uint)keysym;
+            }
+            break;
+        default:
+            break;
+        }
+        if (mib != -1) {
+            mapper = QTextCodec::codecForMib(mib);
+            if (chars.isEmpty())
+                chars.resize(1);
+            chars[0] = (unsigned char) (keysym & 0xff); // get only the fourth bit for conversion later
+            count++;
+        }
+    } else if (keysym >= 0x1000000 && keysym <= 0x100ffff) {
+        converted = (ushort) (keysym - 0x1000000);
+        mapper = 0;
+    }
+    if (count < (int)chars.size()-1)
+        chars[count] = '\0';
+
+    QString text;
+    if (!mapper && converted.unicode() != 0x0) {
+        text = converted;
+    } else if (!chars.isEmpty()) {
+        // convert chars (8bit) to text (unicode).
+        if (mapper)
+            text = mapper->toUnicode(chars.data(), count, 0);
+        if (text.isEmpty()) {
+            // no mapper, or codec couldn't convert to unicode (this
+            // can happen when running in the C locale or with no LANG
+            // set). try converting from latin-1
+            text = QString::fromLatin1(chars);
+        }
+    }
+    return text;
+}
+
+/*! XkbLookupKeySym ( X11->display, event->nativeScanCode(), HILDON_IM_SHIFT_STICKY_MASK, &mods_rtrn, sym_rtrn)
+ */
+static QString translateKeycodeAndState(KeyCode key, uint state, quint32 &keysym){
+    uint mods;
+    KeySym *ks = reinterpret_cast<KeySym*>(&keysym);
+    if ( XkbLookupKeySym ( X11->display, key, state, &mods, ks) )
+        return translateKeySym(*ks);
+    else
+        return QString();
+}
+
+static Window findHildonIm()
+{
+    union
+    {
+        Window *win;
+        unsigned char *val;
+    } value;
+
+    Window result = 0;
+    ulong n = 0;
+    ulong extra = 0;
+    int format = 0;
+    Atom realType;
+
+    int status = XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                    ATOM(_HILDON_IM_WINDOW), 0L, 4L, 0,
+                    XA_WINDOW, &realType, &format,
+                    &n, &extra, (unsigned char **) &value.val);
+
+    if (status == Success && realType == XA_WINDOW
+          && format == HILDON_IM_WINDOW_ID_FORMAT && n == 1 && value.win != 0) {
+        result = value.win[0];
+        XFree(value.val);
+    } else {
+        qWarning("QHildonInputContext: Unable to get the Hildon IM window id");
+    }
+
+    return result;
+}
+
+
+
+/*! Send a key event to the IM, which makes it available to the plugins
+ */
+static void sendKeyEvent(QWidget *widget, QEvent::Type type, uint state, uint keyval, quint16 keycode)
+{
+    int gdkEventType;
+    Window w = findHildonIm();
+
+    if (!w)
+        return;
+    
+    //Translate QEvent::Type in GDK_Event
+    switch (type){
+        case QEvent::KeyPress:
+            gdkEventType = 8;
+        break;
+        case QEvent::KeyRelease:
+            gdkEventType = 9;
+        break;
+        default:
+            qWarning("QHildonInputContext: Event type not allowed");
+            return;
+    }
+
+    XEvent ev;
+    memset(&ev, 0, sizeof(XEvent));
+
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = w;
+    ev.xclient.message_type = ATOM(_HILDON_IM_KEY_EVENT);
+    ev.xclient.format = HILDON_IM_KEY_EVENT_FORMAT; 
+ 
+    HildonIMKeyEventMessage *msg = reinterpret_cast<HildonIMKeyEventMessage *>(&ev.xclient.data);
+    msg->input_window = widget->winId();
+
+    msg->type = gdkEventType;
+    msg->state = state;
+    msg->keyval = keyval;
+    msg->hardware_keycode = keycode;
+
+    XSendEvent(X11->display, w, false, 0, &ev);
+    XSync( X11->display, false );
+}
+
+static void setMaskState(int *mask,
+                         HildonIMInternalModifierMask lock_mask,
+                         HildonIMInternalModifierMask sticky_mask,
+                         bool was_press_and_release)
+{
+
+  /* Pressing the key while already locked clears the state */
+  if (*mask & lock_mask)
+    *mask &= ~(lock_mask | sticky_mask);
+  /* When the key is already sticky, a second press locks the key */
+  else if (*mask & sticky_mask)
+    *mask |= lock_mask;
+#if 0 
+  //TODO port needed for hildon_banner_show_information
+  if (lock_mask & HILDON_IM_SHIFT_LOCK_MASK)
+      hildon_banner_show_information (NULL, NULL, _("inpu_ib_mode_fn_locked"));
+    else if (lock_mask & HILDON_IM_LEVEL_LOCK_MASK)
+      hildon_banner_show_information (NULL, NULL, _("inpu_ib_mode_level_locked"));
+#endif 
+  /* Pressing the key for the first time stickies the key for one character,
+     but only if no characters were entered while holding the key down */
+  else if (was_press_and_release) {
+    *mask |= sticky_mask;
+  }
+}
+
+//TODO
+static quint32 dead_key_to_unicode_combining_character(int qtkeycode)
+{
+  quint32 combining; //Unicode Hex value
+
+  switch (qtkeycode)
+  {
+    case Qt::Key_Dead_Grave:            combining = 0x0300; break;
+    case Qt::Key_Dead_Acute:            combining = 0x0301; break;
+    case Qt::Key_Dead_Circumflex:       combining = 0x0302; break;
+    case Qt::Key_Dead_Tilde:            combining = 0x0303; break;
+    case Qt::Key_Dead_Macron:           combining = 0x0304; break;
+    case Qt::Key_Dead_Breve:            combining = 0x032e; break;
+    case Qt::Key_Dead_Abovedot:         combining = 0x0307; break;
+    case Qt::Key_Dead_Diaeresis:        combining = 0x0308; break;
+    case Qt::Key_Dead_Abovering:        combining = 0x030a; break;
+    case Qt::Key_Dead_Doubleacute:      combining = 0x030b; break;
+    case Qt::Key_Dead_Caron:            combining = 0x030c; break;
+    case Qt::Key_Dead_Cedilla:          combining = 0x0327; break;
+    case Qt::Key_Dead_Ogonek:           combining = 0x0328; break;
+    case Qt::Key_Dead_Iota:             combining = 0; break; /* Cannot be combined */
+    case Qt::Key_Dead_Voiced_Sound:     combining = 0; break; /* Cannot be combined */
+    case Qt::Key_Dead_Semivoiced_Sound: combining = 0; break; /* Cannot be combined */
+    case Qt::Key_Dead_Belowdot:         combining = 0x0323; break;
+    case Qt::Key_Dead_Hook:             combining = 0x0309; break;
+    case Qt::Key_Dead_Horn:             combining = 0x031b; break;
+    default: combining = 0; break; /* Unknown dead key */
+  }
+
+  return combining;
+}
+
+/*! Sends the key as a spontaneous event.
+ */
+static void sendKey(QWidget *keywidget, int qtCode)
+{
+    QPointer<QWidget> guard = keywidget;
+
+    KeySym keysym = NoSymbol;
+    int keycode;
+
+    switch (qtCode){
+        case Qt::Key_Enter:
+            keycode = 36;
+        break;
+        case Qt::Key_Tab:
+            keycode = 66;
+        break;
+        case Qt::Key_Backspace:
+            keycode = 22;
+        break;
+        default: 
+        qWarning("keycode not allowed");
+        return;
+    }
+
+    keysym = XKeycodeToKeysym(X11->display, keycode, 0);
+
+    QKeyEventEx click(QEvent::KeyPress, qtCode, Qt::NoModifier , QString(), false, 1, keycode, keysym, 0);
+    qt_sendSpontaneousEvent(keywidget, &click);
+
+    // in case the widget was destroyed when the key went down
+    if (guard.isNull()){
+        return;
+    }
+
+    QKeyEventEx release(QEvent::KeyRelease, qtCode, Qt::NoModifier , QString(), false, 1, keycode, keysym, 0);
+    qt_sendSpontaneousEvent(keywidget, &release);
+}
+
+/*!
+ */
+static void answerClipboardSelectionQuery(QWidget *widget)
+{
+    bool hasSelection = !widget->inputMethodQuery(Qt::ImCurrentSelection).toString().isEmpty();
+
+    XEvent xev;
+    Window w = findHildonIm();
+
+    memset(&xev, 0, sizeof(xev));
+    xev.xclient.type = ClientMessage;
+    xev.xclient.window = w;
+    xev.xclient.message_type = ATOM(_HILDON_IM_CLIPBOARD_SELECTION_REPLY);
+    xev.xclient.format = HILDON_IM_CLIPBOARD_SELECTION_REPLY_FORMAT;
+    xev.xclient.data.l[0] = hasSelection;
+
+    XSendEvent(X11->display, w, false, 0, &xev);
+}
+
+
+
+const char *getNextPacketStart(const char *str)
+{
+    const char *candidate, *good;
+
+    candidate = good = str;
+
+    while (*candidate != 0) {
+        ++candidate;
+        if (candidate - str >= HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE)
+            return good;
+        good = candidate;
+    }
+
+    /* The whole string is small enough */
+    return candidate;
+}
+
+KeySym getKeySymForLevel(int keycode, int level ){
+    XkbDescPtr xkbDesc = XkbGetMap(X11->display, XkbAllClientInfoMask, XkbUseCoreKbd);
+    KeySym keySym = XkbKeySymEntry(xkbDesc, keycode, level, 0);
+
+    //Check for a not repated keysym
+    KeySym keySymTest = XkbKeySymEntry(xkbDesc, keycode, 0, 1);
+    if (keySym == keySymTest)
+        return NoSymbol;
+
+    return keySym;    
+}
+
+QHildonInputContext::QHildonInputContext(QObject* parent)
+    : QInputContext(parent), timerId(-1), mask(0), 
+      triggerMode(HILDON_IM_TRIGGER_NONE), commitMode(HILDON_IM_COMMIT_REDIRECT),
+      inputMode(HILDON_GTK_INPUT_MODE_FULL), lastInternalChange(false)
+{
+}
+
+QHildonInputContext::~QHildonInputContext()
+{
+    sendHildonCommand(HILDON_IM_HIDE);
+}
+
+QString QHildonInputContext::identifierName()
+{
+    return QLatin1String("hildon");
+}
+
+QString QHildonInputContext::language()
+{
+    //TODO GConf /apps/osso/inputmethod/hildon-im-languages
+    return QString();
+}
+
+/*!reset the UI state 
+ */
+void QHildonInputContext::reset()
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::reset()" << focusWidget() <<  QApplication::focusWidget();
+#endif
+    QPointer<QWidget> oldFocus= focusWidget();
+    
+    if (oldFocus && QApplication::focusWidget() != oldFocus){
+        oldFocus->removeEventFilter(oldFocus->inputContext());
+        sendHildonCommand(HILDON_IM_CLEAR, oldFocus);
+    }
+
+    //Reset internals
+    mask = 0;
+    lastInternalChange = false;
+}
+
+bool QHildonInputContext::isComposing() const
+{
+    return false;
+}
+
+void QHildonInputContext::setFocusWidget(QWidget *w)
+{
+    if (!w)
+        return;
+
+    w->installEventFilter(this);
+    QInputContext::setFocusWidget(w);
+    sendHildonCommand(HILDON_IM_SETCLIENT, w);    
+}
+
+bool QHildonInputContext::eventFilter(QObject *obj, QEvent *event)
+{
+    QWidget *w = static_cast<QWidget*>(obj);
+    if (w) 
+        QObject::eventFilter(obj, event);
+
+    switch (event->type()){
+    case QEvent::MouseButtonRelease:{
+        //On the device, these events are sent at the same time of the TabletRelease ones
+        if (QApplicationPrivate::areXInputEventsUsed()) break;
+
+        //Emulate Finger poke in scratchbox
+        QMouseEvent *me = static_cast<QMouseEvent*>(event);
+#ifndef Q_OS_FREMANTLE	
+        if (me->button() == Qt::MidButton)
+            triggerMode = HILDON_IM_TRIGGER_FINGER;
+        else
+            triggerMode = HILDON_IM_TRIGGER_STYLUS;
+#else
+	triggerMode = HILDON_IM_TRIGGER_FINGER;
+#endif
+        inputMode = w->inputMethodQuery(Qt::ImMode).toInt();
+        toggleHildonMainIMUi(); //showHIMMainUI();
+        break;
+    }
+    case QEvent::TabletPress:{
+        textCursorPosOnPress = -1;
+        break;
+    }
+    case QEvent::TabletMove:{
+        //Moving the finger generate more than 1 TabletMove event
+        if ( textCursorPosOnPress == -1){
+            textCursorPosOnPress = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+        }
+        break;
+    }
+    case QEvent::TabletRelease:{
+        QTabletEvent *te = static_cast<QTabletEvent*>(event);
+
+        //No HIM if there are popup widgets.
+        if (QApplication::activePopupWidget()){ 
+            break;
+        }
+
+#ifndef Q_OS_FREMANTLE
+        if (te->pressure() >= PRESSURE_THRESHOLD){
+            triggerMode = HILDON_IM_TRIGGER_FINGER;
+        }else{
+            triggerMode = HILDON_IM_TRIGGER_STYLUS;    
+        }
+#else
+	triggerMode = HILDON_IM_TRIGGER_FINGER;
+#endif
+        inputMode = w->inputMethodQuery(Qt::ImMode).toInt();
+        toggleHildonMainIMUi(); showHIMMainUI();
+        break;
+    }
+    case QEvent::KeyPress:
+    case QEvent::KeyRelease:{
+        triggerMode = HILDON_IM_TRIGGER_KEYBOARD;
+        return filterKeyPress(static_cast<QWidget*>(obj), 
+                              static_cast<QKeyEvent*>(event));
+    }
+    default:
+        //Remove compile warning
+        break;
+    }
+    return QObject::eventFilter(obj, event);
+}
+
+//TODO
+void QHildonInputContext::update()
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::update()";
+#endif
+
+    if (lastInternalChange) {
+        //Autocase update
+        checkSentenceStart();
+        lastInternalChange = false;
+    }
+}
+
+/*!  Shows/hides the Hildon Main Input Method Ui Window
+ */
+void QHildonInputContext::toggleHildonMainIMUi()
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::toggleHildonMainIMUi()";
+#endif
+    QPointer<QWidget> w = focusWidget();
+    if (!w)
+        return;
+     
+    if (!canUseIM(w)){
+        sendHildonCommand(HILDON_IM_HIDE);
+        return;
+    }
+
+     sendHildonCommand(HILDON_IM_SETCLIENT,w);
+     if (timerId != -1){
+         killTimer(timerId);
+     }
+     timerId = startTimer(HILDON_IM_DEFAULT_LAUNCH_DELAY);
+}
+
+/*! Shows the IM after a timeout.
+ *  GTK implementation use this to improve the possibility
+ *  to distinguish a finger poke.
+ */
+void QHildonInputContext::timerEvent(QTimerEvent *ev)
+{
+    if (ev->timerId() != timerId){
+        return;
+    }
+    killTimer(timerId);
+
+    if (QWidget *w = QApplication::focusWidget()){
+        sendHildonCommand(HILDON_IM_SETNSHOW,w);
+    }
+}
+
+/*! Filters spontaneous keyevents then elaborates them and updates the Hildon Main UI
+ *  via XMessages. In some cases it creates and posts a new keyevent
+ *  as no spontaneous event.
+ */
+bool QHildonInputContext::filterKeyPress(QWidget *keywidget,QKeyEvent *event){
+
+    if (!canUseIM(keywidget))
+        return false;
+
+    //Avoid to filter events generated by this function.
+    if (!event->spontaneous())
+        return false;
+
+    const quint32 state = event->nativeModifiers();
+    const quint32 keycode = event->nativeScanCode();
+    quint32 keysym= event->nativeVirtualKey();
+    const int qtkeycode = event->key();
+
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::filterKeyPress"
+             << QString(" Mask:0x%1 state:0x%2 keycode:%3 keysym:0x%4 QtKey:0x%5 ").arg(mask,0,16)
+                                                                        .arg(state,0,16)
+                                                                        .arg(keycode)
+                                                                        .arg(keysym,0,16)
+                                                                        .arg(qtkeycode,0,16);
+#endif
+
+    //Drop auto repeated keys for COMPOSE_KEY
+    if (qtkeycode == COMPOSE_KEY && event->isAutoRepeat()){
+        return true;
+    }
+
+    //TODO MOVE
+    static QWidget* lastKeywidget = 0;
+    static int lastQtkeycode = 0;
+    static qint32 combiningChar = 0; //Unicode rappresentation of the dead key.
+
+    QString commitString; //String to commit to the Key Widget
+ 
+    lastKeywidget = keywidget;
+    //Reset static vars when the widget change.
+    if (keywidget != lastKeywidget){
+        mask = 0;
+        lastKeywidget = 0;
+        lastQtkeycode = 0;
+        combiningChar = 0;
+    }
+
+    if (!qtkeycode)
+        return true;
+
+    //1. A dead key will not be immediately commited, but combined with the next key
+    if (qtkeycode >= Qt::Key_Dead_Grave && qtkeycode <= Qt::Key_Dead_Horn)
+        mask |= HILDON_IM_DEAD_KEY_MASK;
+    else
+        mask &= ~HILDON_IM_DEAD_KEY_MASK;
+
+    if (mask & HILDON_IM_DEAD_KEY_MASK && combiningChar == 0)
+    {        
+        combiningChar = dead_key_to_unicode_combining_character(qtkeycode);//### WORKS? IMPROVE?
+        return true;
+    }
+
+    /*2. Pressing any key while the compose key is pressed will keep that
+     *   character from being directly submitted to the application. This
+     *   allows the IM process to override the interpretation of the key 
+     */
+    if (qtkeycode == COMPOSE_KEY)
+    {
+        if (event->type() == QEvent::KeyPress)
+            mask |= HILDON_IM_COMPOSE_MASK;
+        else
+            mask &= ~HILDON_IM_COMPOSE_MASK;
+    }
+
+    // 3 Sticky and locking keys initialization
+    if (event->type() == QEvent::KeyRelease)
+    {
+        if (qtkeycode == Qt::Key_Shift )
+        {
+            setMaskState(&mask,
+                         HILDON_IM_SHIFT_LOCK_MASK,
+                         HILDON_IM_SHIFT_STICKY_MASK,
+                         lastQtkeycode == Qt::Key_Shift);
+        }else if (event->key() == LEVEL_KEY){
+            setMaskState(&mask,
+                         HILDON_IM_LEVEL_LOCK_MASK,
+                         HILDON_IM_LEVEL_STICKY_MASK,
+                         lastQtkeycode == LEVEL_KEY);
+        }
+    }
+    //Update lastQtkeycode.
+    lastQtkeycode=qtkeycode;
+
+    if (qtkeycode == Qt::Key_Return || qtkeycode == Qt::Key_Enter || keysym == GDK_ISO_ENTER) {
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+        lastInternalChange = true;
+        return false;
+    }else if (qtkeycode == Qt::Key_Tab){
+        commitString = QString("\t");
+    }
+
+    /* 5. When the level key is in sticky or locked state, translate the
+     *    keyboard state as if that level key was being held down.
+     */
+    if ((mask & (HILDON_IM_LEVEL_STICKY_MASK | HILDON_IM_LEVEL_LOCK_MASK)) || 
+           state == LEVEL_KEY_MOD_MASK)
+    {
+        commitString = translateKeycodeAndState(keycode, STATE_LEVEL_KEY_MASK, keysym);
+    }
+   
+    /* If the input mode is strictly numeric and the digits are level
+     *  shifted on the layout, it's not necessary for the level key to
+     *  be pressed at all. 
+     */
+    else if (options & HILDON_IM_AUTOLEVEL_NUMERIC &&
+                (inputMode & HILDON_GTK_INPUT_MODE_FULL) == HILDON_GTK_INPUT_MODE_NUMERIC)
+    {
+        KeySym ks = getKeySymForLevel(keycode, NUMERIC_LEVEL); 
+        QString string = translateKeySym(ks);
+
+        if (!string.isEmpty()){
+            keysym = ks;
+            commitString = string;
+        }
+    }
+    /* The input is forced to a predetermined level 
+     */
+    else if (options & HILDON_IM_LOCK_LEVEL)
+    {
+        KeySym ks = getKeySymForLevel(keycode, LOCKABLE_LEVEL); 
+        QString string = translateKeySym(ks);
+
+        if (!string.isEmpty()){
+            keysym = ks;
+            commitString = string;
+        }
+    } 
+    /* Hardware keyboard autocapitalization  */
+    if (autoUpper && inputMode & HILDON_GTK_INPUT_MODE_AUTOCAP)
+    {
+        QChar currentChar;
+        KeySym lower = NoSymbol;
+        KeySym upper = NoSymbol;
+
+        if (commitString.isEmpty()){
+            QString ks = translateKeySym(keysym);
+            if (!ks.isEmpty())
+                currentChar = ks.at(0);
+        }else{
+            currentChar = commitString.at(0);
+        }
+
+        XConvertCase(keysym, &lower, &upper);
+
+        if (currentChar.isPrint()){
+            if (state & STATE_SHIFT_MASK){
+                currentChar = currentChar.toLower();
+                keysym = lower;
+            } else {
+                currentChar = currentChar.toUpper();
+                keysym = upper;
+            }
+            commitString = QString(currentChar); //sent to the widget
+        }
+    }
+
+    //6. Shift lock or holding the shift down forces uppercase, ignoring autocap
+    if (mask & HILDON_IM_SHIFT_LOCK_MASK || state & STATE_SHIFT_MASK)
+    {
+        KeySym lower = NoSymbol;
+        KeySym upper = NoSymbol;
+        XConvertCase(keysym, &lower, &upper);
+        QString tempStr = translateKeySym(upper);
+        if (!tempStr.isEmpty())
+            commitString = tempStr.at(0);
+    }else if (mask & HILDON_IM_SHIFT_STICKY_MASK){
+        KeySym lower = NoSymbol;
+        KeySym upper = NoSymbol;
+        QString tempStr = translateKeySym(keysym);
+        QChar currentChar = tempStr.at(0);
+        
+        /* Simulate shift key being held down in sticky state for non-printables  */
+        if ( currentChar.isPrint() ){
+            /*  For printable characters sticky shift negates the case,
+             *  including any autocapitalization changes 
+             */
+            if ( currentChar.isUpper() ){
+                currentChar = currentChar.toLower();
+                lower = lower;
+            }else{
+                currentChar = currentChar.toUpper();
+                upper = upper;
+            }
+            commitString = QString(currentChar); //sent to the widget  
+        }
+    }
+    
+    //F. word completion manipulation (for fremantle)
+    if (event->type() == QEvent::KeyPress &&
+        commitMode == HILDON_IM_COMMIT_PREEDIT &&
+        !preEditBuffer.isNull())
+    {
+        switch (qtkeycode){
+            case Qt::Key_Right:{
+                //TODO Move this code in commitPreeditData();
+                QInputMethodEvent e;
+                e.setCommitString(preEditBuffer + ' ');
+                sendEvent(e);
+                preEditBuffer.clear();
+                return true;
+            }
+            case Qt::Key_Backspace:
+            case Qt::Key_Left:{
+                //TODO Move this code
+                preEditBuffer.clear();
+                QInputMethodEvent e;
+                sendEvent(e);
+                return true;
+           }
+        } 
+    }
+
+    //7. Sticky and lock state reset
+    if (event->type() == QEvent::KeyPress)
+    {
+        if (qtkeycode != Qt::Key_Shift )
+        {
+            /* If not locked, pressing any character resets shift state */
+            if ((mask & HILDON_IM_SHIFT_LOCK_MASK) == 0)
+            {
+                mask &= ~HILDON_IM_SHIFT_STICKY_MASK;
+            }
+        }
+        if (qtkeycode != LEVEL_KEY)
+        {
+            /* If not locked, pressing any character resets level state */
+            if ((mask & HILDON_IM_LEVEL_LOCK_MASK) == 0)
+            {
+                mask &= ~HILDON_IM_LEVEL_STICKY_MASK;
+            }
+        }
+    }
+
+    if (event->type() == QEvent::KeyRelease || state & STATE_CONTROL_MASK)
+    {
+#ifdef HIM_DEBUG
+        qDebug() << QString("Sending state=0x%1 keysym=0x%2 keycode=%3").arg(state,0,16).arg(keysym,0,16).arg(keycode);
+#endif
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+        return false;
+    }
+ 
+     
+    /* 8. Pressing a dead key twice, or if followed by a space, inputs
+     *    the dead key's character representation 
+     */
+    if ((mask & HILDON_IM_DEAD_KEY_MASK || qtkeycode == Qt::Key_Space) && combiningChar)
+    {
+        qint32 last;
+        last = dead_key_to_unicode_combining_character (qtkeycode);
+        if ((last == combiningChar) || qtkeycode == Qt::Key_Space)
+        {
+            commitString = QString(combiningChar);
+        }else{
+            commitString = QString::fromUtf8(XKeysymToString(keysym));
+        }
+        combiningChar = 0;
+    }else{
+        /* Regular keypress */
+        if (mask & HILDON_IM_COMPOSE_MASK)
+        {
+            sendKeyEvent(keywidget, event->type(),state, keysym, keycode);
+            return true;
+        }else{
+            if ( commitString.isEmpty() && qtkeycode != Qt::Key_Backspace){
+#ifdef HIM_DEBUG
+                qDebug() << "this string" << event->text() << "will be committed";
+#endif
+                commitString = QString(event->text());
+            }
+        }
+   }
+    
+    if ( !commitString.isEmpty() ){
+        //entering a new character cleans the preedit buffer
+        preEditBuffer.clear();
+        QInputMethodEvent e;
+        sendEvent(e);
+
+        /* Pressing a dead key followed by a regular key combines to form
+         * an accented character
+         */
+        if (combiningChar){ //FIXME
+            commitString.append(combiningChar);//This will be sent to the widget
+            const char *charStr = qPrintable(commitString);
+            keysym = XStringToKeysym(charStr); //This will be sent to the IM
+        }
+
+        //Create the new event with the elaborate information,
+        //then it adds the event to the events queue
+        {
+            QEvent::Type type = event->type();
+            Qt::KeyboardModifiers modifiers= event->modifiers();
+            //WARNING the qt keycode has not been updated!!
+            QKeyEventEx *ke= new QKeyEventEx(type, keycode, modifiers, commitString, false, commitString.size(), keycode, keysym, state);
+            QCoreApplication::postEvent(keywidget,ke);
+        }
+
+        //Send the new keysym 
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+#if 0
+        /* Non-printable characters invalidate any previous dead keys */
+        if (qtkeycode != Qt::Key_Shift)
+            combiningChar=0;
+#endif
+        lastInternalChange = true;
+        return true;
+    }else{
+        //Send the new keysym 
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+        if (qtkeycode == Qt::Key_Backspace){
+            lastInternalChange = true; 
+        }
+
+        return false; 
+    }
+}
+
+/*! Filters the XClientMessages sent by QApplication_x11
+ */
+bool QHildonInputContext::x11FilterEvent(QWidget *keywidget, XEvent *event)
+{
+    if (event->xclient.message_type == ATOM(_HILDON_IM_INSERT_UTF8)
+            && event->xclient.format == HILDON_IM_INSERT_UTF8_FORMAT) {
+#ifdef HIM_DEBUG
+        qDebug() << "HILDON_IM_INSERT_UTF8_FORMAT" << options;
+#endif
+        HildonIMInsertUtf8Message *msg = (HildonIMInsertUtf8Message *)&event->xclient.data;
+        insertUtf8(msg->msg_flag, QString::fromUtf8(msg->utf8_str));
+        return true;
+
+    }else if (event->xclient.message_type == ATOM(_HILDON_IM_COM)) {
+        HildonIMComMessage *msg = (HildonIMComMessage *)&event->xclient.data;
+        options = msg->options;
+#ifdef HIM_DEBUG
+        qDebug() << "OPTIONS" << options;
+#endif
+
+        switch (msg->type) {
+        //Handle Keys msgs
+        case HILDON_IM_CONTEXT_HANDLE_ENTER: {
+            sendKey(keywidget, Qt::Key_Enter);
+            return true; }
+        case HILDON_IM_CONTEXT_HANDLE_TAB: {
+            sendKey(keywidget, Qt::Key_Tab);
+            return true; }
+        case HILDON_IM_CONTEXT_HANDLE_BACKSPACE: {
+            sendKey(keywidget, Qt::Key_Backspace);
+            return true; }
+        case HILDON_IM_CONTEXT_HANDLE_SPACE: {
+            insertUtf8(HILDON_IM_MSG_CONTINUE, QChar(Qt::Key_Space));
+            commitPreeditData();
+            return true; }
+
+        //Handle Clipboard msgs
+        case HILDON_IM_CONTEXT_CLIPBOARD_SELECTION_QUERY: {
+            answerClipboardSelectionQuery(keywidget);
+            return true; }
+        case HILDON_IM_CONTEXT_CLIPBOARD_PASTE:
+            if (QClipboard *clipboard = QApplication::clipboard()){
+                QInputMethodEvent e;
+                e.setCommitString(clipboard->text());
+                sendEvent(e);
+            }
+            return true;
+        case HILDON_IM_CONTEXT_CLIPBOARD_COPY: {
+            if (QClipboard *clipboard = QApplication::clipboard())
+                clipboard->setText(keywidget->inputMethodQuery(Qt::ImCurrentSelection).toString());
+            return true; }
+        case HILDON_IM_CONTEXT_CLIPBOARD_CUT: {
+            if (QClipboard *clipboard = QApplication::clipboard())
+                clipboard->setText(keywidget->inputMethodQuery(Qt::ImCurrentSelection).toString());
+            QInputMethodEvent ev;
+            sendEvent(ev);
+            return true; }
+
+        //Handle commit mode msgs
+        case HILDON_IM_CONTEXT_DIRECT_MODE: { //default mode
+            #ifdef HIM_DEBUG
+                qDebug() << "commitMode =  HILDON_IM_CONTEXT_DIRECT_MODE";
+            #endif
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_DIRECT;
+            return true; }
+        case HILDON_IM_CONTEXT_BUFFERED_MODE: {
+            #ifdef HIM_DEBUG
+                qDebug() << "commitMode =  HILDON_IM_CONTEXT_BUFFERED_MODE";
+            #endif
+            if (commitMode != HILDON_IM_COMMIT_BUFFERED){
+                preEditBuffer = QString("");
+                commitMode = HILDON_IM_COMMIT_BUFFERED;
+            }
+            return true; }
+        case HILDON_IM_CONTEXT_REDIRECT_MODE: {
+            #ifdef HIM_DEBUG
+                qDebug() << "commitMode =  HILDON_IM_CONTEXT_REDIRECT_MODE";
+            #endif
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_REDIRECT;
+            checkCommitMode();
+            clearSelection();
+            return true; }
+        case HILDON_IM_CONTEXT_SURROUNDING_MODE: {
+            #ifdef HIM_DEBUG
+                qDebug() << "commitMode =  HILDON_IM_CONTEXT_SURROUNDING_MODE";
+            #endif
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_SURROUNDING;
+            return true; }
+
+        //Handle context
+        case HILDON_IM_CONTEXT_CONFIRM_SENTENCE_START: {
+            #ifdef HIM_DEBUG
+                qDebug() << "HILDON_IM_CONTEXT_CONFIRM_SENTENCE_START";
+            #endif
+            checkSentenceStart();
+            return true; }
+        case HILDON_IM_CONTEXT_FLUSH_PREEDIT: {
+            #ifdef HIM_DEBUG
+                qDebug() << "commitMode = HILDON_IM_CONTEXT_FLUSH_PREEDIT";
+            #endif
+            commitPreeditData();
+            return true; }
+        case HILDON_IM_CONTEXT_REQUEST_SURROUNDING: {
+            #ifdef HIM_DEBUG
+                qDebug() << "HILDON_IM_CONTEXT_REQUEST_SURROUNDING";
+            #endif
+            checkCommitMode();
+            sendSurrounding();
+            //if (self->is_url_entry)
+            //  hildon_im_context_send_command(self, HILDON_IM_SELECT_ALL);
+            return true; }
+        case HILDON_IM_CONTEXT_OPTION_CHANGED: {
+            //Nothing to do
+            return true; }
+        case HILDON_IM_CONTEXT_CLEAR_STICKY: {
+            mask &= ~(HILDON_IM_SHIFT_STICKY_MASK |
+                      HILDON_IM_SHIFT_LOCK_MASK |
+                      HILDON_IM_LEVEL_STICKY_MASK |
+                      HILDON_IM_LEVEL_LOCK_MASK);
+            return true; }
+
+        //Unused 
+        case HILDON_IM_CONTEXT_NUM_COM: {
+            return true; }
+        case HILDON_IM_CONTEXT_ENTER_ON_FOCUS: {
+            return true; }
+        case HILDON_IM_CONTEXT_WIDGET_CHANGED: {
+            //Do we really need to set the mask=0? See reset();
+            return true; }
+        
+#ifdef Q_OS_FREMANTLE
+        case HILDON_IM_CONTEXT_CANCEL_PREEDIT: {
+            #ifdef HIM_DEBUG
+                qDebug() << "HILDON_IM_CONTEXT_CANCEL_PREEDIT";
+            #endif
+            preEditBuffer.clear();
+            QInputMethodEvent e;            
+            sendEvent(e);
+            return true; }
+        case HILDON_IM_CONTEXT_PREEDIT_MODE: {
+            #ifdef HIM_DEBUG
+                qDebug() << "commitMode = HILDON_IM_CONTEXT_PREEDIT_MODE";
+            #endif
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_PREEDIT;
+            return true; } 
+        case HILDON_IM_CONTEXT_REQUEST_SURROUNDING_FULL: {
+            #ifdef HIM_DEBUG
+                qDebug() << "HILDON_IM_CONTEXT_REQUEST_SURROUNDING_FULL";
+            #endif
+            checkCommitMode();
+            sendSurrounding(true);
+            //if (self->is_url_entry)
+            //  hildon_im_context_send_command(self, HILDON_IM_SELECT_ALL);
+            return true; }
+#endif  
+        default:
+            qWarning() << "Hildon Input Method Message not handled" << msg->type;
+        }
+    }else if (event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING_CONTENT) &&
+              event->xclient.format == HILDON_IM_SURROUNDING_CONTENT_FORMAT) {
+        #ifdef HIM_DEBUG
+                qDebug() << "HILDON_IM_SURROUNDING_CONTENT_FORMAT";
+        #endif
+        HildonIMSurroundingContentMessage *msg = reinterpret_cast<HildonIMSurroundingContentMessage*>(&event->xclient.data);
+
+        if (!surrounding.isNull()) {
+            if (msg->msg_flag == HILDON_IM_MSG_START) {
+                surrounding.clear();
+            }else if (msg->msg_flag == HILDON_IM_MSG_END) {
+                //TODO? commitSurrounding();
+                qWarning("commitSurrounding() NOT IMPLEMENTED YET");
+                return true;
+            }            
+        }
+        surrounding += QString::fromUtf8(msg->surrounding);
+        return true;
+    }else if (event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING) &&
+                  event->xclient.format == HILDON_IM_SURROUNDING_FORMAT) {
+        #ifdef HIM_DEBUG
+                qDebug() << "HILDON_IM_SURROUNDING_FORMAT";
+        #endif
+        HildonIMSurroundingMessage *msg = reinterpret_cast<HildonIMSurroundingMessage*>(&event->xclient.data);
+        setClientCursorLocation(msg->offset_is_relative, msg->cursor_offset );
+        return true;
+    }
+    return false;
+}
+
+/*! Some widgets have the IM always enabled.
+ *  In some particular cases it don't need the IM
+ *  Eg:  If the widget is read only or if we have 
+ *        complex widgets like QWebView or 
+ *        QGraphicsView. 
+ */
+bool QHildonInputContext::canUseIM(QWidget *w)
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::canUseIM" << w;
+#endif
+
+    bool enabled = false;
+    
+    if ( w && w->testAttribute(Qt::WA_InputMethodEnabled) ){
+
+        //is it in readOnlyMode?
+        QLineEdit *le = qobject_cast<QLineEdit*>(w);
+        QTextEdit *te = qobject_cast<QTextEdit*>(w);
+        QPlainTextEdit *pte = qobject_cast<QPlainTextEdit*>(w);
+
+        if (le){
+            enabled=!le->isReadOnly();
+        }else if (te){
+            enabled=!te->isReadOnly();
+        }else if (pte){
+            enabled=!pte->isReadOnly();
+        }else{
+            //These queries return a valid values only for input elements
+            //If the user click in an input element, the cursor return a valid
+            //value and the selection will be an empty string.
+            //Vice versa if the user select a text.
+            enabled=  (w->inputMethodQuery(Qt::ImCursorPosition).isNull() !=
+                       w->inputMethodQuery(Qt::ImCurrentSelection).toString().isEmpty());
+        }
+    }
+    return enabled;
+}
+
+/*! Ask the client widget to insert the specified text at the cursor
+ *  position, by triggering the commit signal on the context
+ */
+void QHildonInputContext::insertUtf8(int flag, const QString& text)
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::insertUtf8 flag=" << flag << "text=" << text;
+#endif
+    QString cleanText= text;
+    lastInternalChange = true;
+
+    //TODO HILDON_IM_AUTOCORRECT is used by the hadwriting plugin
+    //Writing CiAo in the plugin add Ciao in the widget.
+    if (options & HILDON_IM_AUTOCORRECT){
+        qWarning() << "HILDON_IM_AUTOCORRECT Not Implemented Yet";
+    }
+    
+    //Delete suroundings when we are using the preeditbuffer.
+    // Eg: For the HandWriting plugin 
+    if (!preEditBuffer.isNull()) {
+#ifdef HIM_DEBUG
+    qDebug() << "  preEditBuffer=" << preEditBuffer;
+#endif        
+        QInputMethodEvent e;
+        int charCount = preEditBuffer.length(); 
+        e.setCommitString(QString(), -charCount, charCount);
+        sendEvent(e);
+    } 
+
+    //Updates preEditBuffer
+    if (!preEditBuffer.isNull()){
+        if (flag == HILDON_IM_MSG_START) {
+            preEditBuffer = text;
+        }else{
+            preEditBuffer.append(text);
+        }
+        cleanText = preEditBuffer;
+    }
+    
+    //Adds the actual text
+    switch (commitMode) {
+        case HILDON_IM_COMMIT_PREEDIT: { //Fremantle specific code
+            //Fill preEditBuffer
+            preEditBuffer = text;
+
+            //Creating attribute list
+            QList<QInputMethodEvent::Attribute> list;
+            QInputMethodEvent::Attribute cursor(QInputMethodEvent::Cursor, 0, cleanText.length(), QColor(0, 0, 255, 127));
+            list.append(cursor);
+
+            QTextCharFormat textCharFormat;
+            textCharFormat.setFontUnderline(true);
+            textCharFormat.setBackground(focusWidget()->palette().highlight());
+            textCharFormat.setForeground(focusWidget()->palette().highlightedText());
+            QInputMethodEvent::Attribute textFormat(QInputMethodEvent::TextFormat, 0, cleanText.length(), textCharFormat);
+            list.append(textFormat);
+
+            QInputMethodEvent e(cleanText, list);            
+            sendEvent(e);
+        }break;
+        case HILDON_IM_COMMIT_BUFFERED: //Diablo Handwriting
+        case HILDON_IM_COMMIT_DIRECT:
+        case HILDON_IM_COMMIT_REDIRECT:{
+            QInputMethodEvent e;
+            e.setCommitString(cleanText);
+            sendEvent(e);
+        }break;
+        default:
+            qWarning() << "Commit mode " << commitMode << " not handled by InsertText method";
+    }
+}
+
+void QHildonInputContext::clearSelection()
+{
+#ifdef HIM_DEBUG
+    qDebug() <<  "QHildonInputContext::clearSelection()";
+#endif
+    QWidget *w = focusWidget();
+    int textCursorPos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+    QString selection = w->inputMethodQuery(Qt::ImCurrentSelection).toString();
+
+    if (selection.isEmpty())
+        return;
+    
+    //Remove the selection
+    QInputMethodEvent e;
+    e.setCommitString(selection);
+    sendEvent(e);
+
+    //Move the cursor backward if the text has been selected from right to left
+    if (textCursorPos < textCursorPosOnPress){
+        QInputMethodEvent e;
+        e.setCommitString(QString(), -selection.length(),0);
+        sendEvent(e);
+    }
+}
+
+void QHildonInputContext::sendHildonCommand(HildonIMCommand cmd, QWidget *widget)
+{
+#ifdef HIM_DEBUG
+    qDebug() <<  "QHildonInputContext::sendHildonCommand cmd="<< cmd << "widget=" << widget;
+#endif
+    Window w = findHildonIm();
+
+    if (!w){
+        return;
+    }
+
+    XEvent ev;
+    memset(&ev, 0, sizeof(XEvent));
+
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = w;
+    ev.xclient.message_type = ATOM(_HILDON_IM_ACTIVATE);
+    ev.xclient.format = HILDON_IM_ACTIVATE_FORMAT;
+
+    HildonIMActivateMessage *msg = reinterpret_cast<HildonIMActivateMessage *>(&ev.xclient.data);
+
+    if (widget){
+        msg->input_window = widget->winId();
+        msg->app_window = widget->window()->winId();
+    }else if ( cmd != HILDON_IM_HIDE ){
+        qWarning() << "Invalid Hildon Command:" << cmd;
+        return;
+    }
+
+    if ( cmd == HILDON_IM_HIDE && timerId != -1){
+        killTimer(timerId);
+    }
+
+    msg->cmd = cmd;
+    msg->input_mode = inputMode;
+    msg->trigger = triggerMode;
+
+    XSendEvent(X11->display, w, false, 0, &ev);
+    XSync(X11->display, False);
+}
+
+/*!
+ */
+void QHildonInputContext::sendX11Event(XEvent *event)
+{
+#ifdef HIM_DEBUG
+    qDebug() <<  "QHildonInputContext::sendX11Event" << event;
+#endif
+    Window w = findHildonIm();
+
+    if (!w){
+        return;
+    }
+
+    event->xclient.type = ClientMessage;
+    event->xclient.window = w;
+
+    XSendEvent(X11->display, w, false, 0, event);
+    XSync(X11->display, False);
+}
+
+/*! Shows the Hildon Input Method Main UI
+ */
+void QHildonInputContext::showHIMMainUI() //### REMOVE
+{
+    //Force QInputContext to use the fucused widget.
+#ifdef HIM_DEBUG
+    qDebug() <<  "QHildonInputContext::showHIMMainUI()"
+             <<  "QApplication::focusWidget=" << QApplication::focusWidget()
+             <<  "focusWidget=" << focusWidget();
+#endif
+    //QInputContext::setFocusWidget(QApplication::focusWidget());
+    toggleHildonMainIMUi();
+}
+
+//CONTEXT
+/*! Updates the IM with the autocap state at the active cursor position
+ */
+void QHildonInputContext::checkSentenceStart()
+{
+#ifdef HIM_DEBUG
+    qDebug() <<  "QHildonInputContext::contextCheckSentenceStart()";
+#endif
+
+    QWidget *w = focusWidget();
+    if (!w){
+        return;
+    }
+
+    if ((inputMode & (HILDON_GTK_INPUT_MODE_ALPHA | HILDON_GTK_INPUT_MODE_AUTOCAP)) !=
+            (HILDON_GTK_INPUT_MODE_ALPHA | HILDON_GTK_INPUT_MODE_AUTOCAP)) {
+        /* If autocap is off, but the mode contains alpha, send autocap message.
+         * The important part is that when entering a numerical entry the autocap
+         * is not defined, and the plugin sets the mode appropriate for the language */
+        if (inputMode & HILDON_GTK_INPUT_MODE_ALPHA){
+            autoUpper = false;
+            sendHildonCommand(HILDON_IM_LOW,w);
+        }
+        return;
+    }
+    
+    QString surrounding = w->inputMethodQuery(Qt::ImSurroundingText).toString();
+    int cpos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+
+    if (surrounding.isEmpty()) { 
+        autoUpper = true;
+        sendHildonCommand(HILDON_IM_UPP, w);
+        return;
+    }
+
+    QRegExp r(".*[!?.][\\s]+");
+    QRegExp c("[]");
+    //Improve performance: Don't make sense analyzing more than N chars before the cursor
+    QString left = surrounding.left(cpos).right(10);
+    QString right = left.right(1);
+    QString notRemoved = left.remove(r);
+
+    if(!notRemoved.count() || right.contains(c)){
+        autoUpper = options & HILDON_IM_AUTOCASE;
+        sendHildonCommand(HILDON_IM_UPP, w);
+    }else{
+        autoUpper = false;
+        sendHildonCommand(HILDON_IM_LOW, w);
+    }
+}
+
+void QHildonInputContext::commitPreeditData()
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::commitPreeditData()";
+#endif
+
+    if (!preEditBuffer.isNull())
+        preEditBuffer = QString("");
+}
+
+void QHildonInputContext::checkCommitMode() //### REMOVE?
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::checkCommitMode()" << commitMode;
+#endif
+    //if (m_commitMode == HILDON_IM_COMMIT_REDIRECT)
+    //    m_commitMode = HILDON_IM_COMMIT_SURROUNDING;
+        
+}
+
+/*! Send the text of the client widget surrounding the active cursor position,
+ *  as well as the cursor position in the surrounding, to the IM
+ */
+void QHildonInputContext::sendSurrounding(bool sendAllContents)
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::sendSurrounding sendAllContents=" << sendAllContents 
+             << "focusWidget=" << focusWidget();
+#endif
+    QWidget *w = focusWidget();
+
+    if (!w)
+        return;
+    
+    QString surrounding;
+    int cpos;
+    if (sendAllContents){
+
+         //Try to detect the kind of widget
+        QTextEdit *te = qobject_cast<QTextEdit*>(w);
+        QPlainTextEdit *pte = qobject_cast<QPlainTextEdit*>(w);
+
+        if (te){
+            surrounding = te->text();
+            cpos = te->textCursor().position();      
+        }else if (pte){
+            surrounding = pte->toPlainText();
+            cpos = pte->textCursor().position(); 
+        }else{
+            surrounding = w->inputMethodQuery(Qt::ImSurroundingText).toString();
+            cpos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+        }
+    }else{
+        surrounding = w->inputMethodQuery(Qt::ImSurroundingText).toString();
+        cpos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+    }
+
+    XEvent xev;
+    HildonIMSurroundingContentMessage *surroundingContentMsg = 0;
+    int flag = HILDON_IM_MSG_START;
+
+    //Sending a null to clean the plugin.
+    if (surrounding.isEmpty()) {
+        memset(&xev, 0, sizeof(XEvent));
+        xev.xclient.message_type = ATOM(_HILDON_IM_SURROUNDING_CONTENT);
+        xev.xclient.format = HILDON_IM_SURROUNDING_CONTENT_FORMAT;
+
+        surroundingContentMsg = reinterpret_cast<HildonIMSurroundingContentMessage*>(&xev.xclient.data);
+        surroundingContentMsg->msg_flag = flag;
+        surroundingContentMsg->surrounding[0] = '\0';
+
+        sendX11Event(&xev);
+        
+        sendSurroundingHeader(0);
+        return;
+    }
+    
+    // Split surrounding context into pieces that are small enough
+    // to send in a x message
+    QByteArray ba = surrounding.toUtf8(); 
+    const char *utf8 = ba.data();
+    while (*utf8){
+        const char *nextStart = getNextPacketStart(utf8);
+        unsigned int len = nextStart - utf8;
+
+        //this call will take care of adding the null terminator
+        memset(&xev, 0, sizeof(XEvent));
+        xev.xclient.message_type = ATOM(_HILDON_IM_SURROUNDING_CONTENT);
+        xev.xclient.format = HILDON_IM_SURROUNDING_CONTENT_FORMAT;
+
+        surroundingContentMsg = reinterpret_cast<HildonIMSurroundingContentMessage*>(&xev.xclient.data);
+        surroundingContentMsg->msg_flag = flag;
+        memcpy(surroundingContentMsg->surrounding, utf8, len);
+
+        sendX11Event(&xev);
+
+        utf8 = nextStart;
+        flag = HILDON_IM_MSG_CONTINUE;
+    } 
+    sendSurroundingHeader(cpos);
+}
+
+void QHildonInputContext::sendSurroundingHeader(int offset)
+{
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::sendSurroundingHeader offset=" << offset;
+#endif
+    XEvent xev;
+    /* Send the cursor offset in the surrounding */
+    memset(&xev, 0, sizeof(XEvent));
+    xev.xclient.message_type = ATOM(_HILDON_IM_SURROUNDING);
+    xev.xclient.format = HILDON_IM_SURROUNDING_FORMAT;
+
+    HildonIMSurroundingMessage *surroundingMsg = reinterpret_cast<HildonIMSurroundingMessage *>(&xev.xclient.data);
+    surroundingMsg->commit_mode = commitMode;
+    surroundingMsg->cursor_offset = offset;
+
+    sendX11Event(&xev);
+}
+
+/*! Notify IM of any input mode changes 
+ */
+void QHildonInputContext::inputModeChanged(){
+    sendHildonCommand(HILDON_IM_MODE, focusWidget());
+}
+
+/*! In redirect mode we use a proxy widget (fullscreen vkb). When the cursor position
+ *  changes there, the HIM update the cursor position in the client (Qt application)
+ */
+void QHildonInputContext::setClientCursorLocation(int offsetIsRelative, int cursorOffset)
+{   
+#ifdef HIM_DEBUG
+    qDebug() << "QHildonInputContext::setClientCursorLocation offsetIsRelative=" << offsetIsRelative 
+             << "cursorOffset" << cursorOffset;
+#endif
+    if (!offsetIsRelative){
+        qWarning("setClientCursorLocation can't manage absolute cursor Offsets");
+        return;
+    }
+
+    //Move the cursor
+    //NOTE: To move the cursor changes in customWidget::inputMethodEvent(QInputMethodEvent *e) are needed.
+    QInputMethodEvent e;
+    e.setCommitString(QString(), cursorOffset,0);
+    sendEvent(e);
+}
+#endif
diff --git a/src/gui/inputmethod/qhildoninputmethodprotocol_p.h b/src/gui/inputmethod/qhildoninputmethodprotocol_p.h
new file mode 100644
index 0000000..406a447
--- /dev/null
+++ b/src/gui/inputmethod/qhildoninputmethodprotocol_p.h
@@ -0,0 +1,227 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+**
+** This file is part of the QtGui module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifdef Q_WS_HILDON
+
+#include "qx11info_x11.h"
+#include "private/qt_x11_p.h"
+
+/******* these are copied from hildon-im-protocol **********/
+
+#define HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE (20 - sizeof(int))
+
+/* Commit modes
+   Determines how text is inserted into the client widget
+
+   Buffered mode:  Each new commit replaces any previous commit to the
+   client widget until FLUSH_PREEDIT is called.
+
+   Direct mode (default): Each commit is immediately appended to the
+   client widget at the cursor position.
+
+   Redirect mode: Proxies input and cursor movement from one text widget
+   into another (potentially off-screen) widget. Used when implementing
+   fullscreen IM plugins for widgets that contain text formatting.
+
+   Surrounding mode: Each commit replaces the current text surrounding
+   the cursor position (see gtk_im_context_get_surrounding).
+*/
+typedef enum
+{
+  HILDON_IM_COMMIT_DIRECT,
+  HILDON_IM_COMMIT_REDIRECT,
+  HILDON_IM_COMMIT_SURROUNDING,
+  HILDON_IM_COMMIT_BUFFERED,
+  HILDON_IM_COMMIT_PREEDIT
+} HildonIMCommitMode;
+
+/* Type markers for IM messages that span several ClientMessages */
+enum
+{
+  HILDON_IM_MSG_START,
+  HILDON_IM_MSG_CONTINUE,
+  HILDON_IM_MSG_END
+};
+
+/* Message carrying surrounding interpretation info, sent by both IM and context */
+typedef struct
+{
+  HildonIMCommitMode commit_mode;
+  int offset_is_relative;
+  int cursor_offset;
+} HildonIMSurroundingMessage;
+
+/* The surrounding text, sent by both IM and context */
+typedef struct
+{
+  int msg_flag;
+  char surrounding[HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE];
+} HildonIMSurroundingContentMessage;
+
+enum
+{
+    HILDON_IM_ACTIVATE_FORMAT = 8,
+//  HILDON_IM_COM_FORMAT =8,
+    HILDON_IM_INSERT_UTF8_FORMAT = 8,
+    HILDON_IM_KEY_EVENT_FORMAT = 8,
+    HILDON_IM_SURROUNDING_CONTENT_FORMAT = 8,
+    HILDON_IM_SURROUNDING_FORMAT = 8,
+    HILDON_IM_CLIPBOARD_SELECTION_REPLY_FORMAT = 32,
+//  HILDON_IM_CLIPBOARD_FORMAT = 32
+    HILDON_IM_WINDOW_ID_FORMAT = 32,
+    HILDON_IM_DEFAULT_LAUNCH_DELAY = 70
+}; /* IM ClientMessage formats */
+
+/* IM commands, from context to IM process */
+enum HildonIMCommand
+{
+    HILDON_IM_MODE,       // Update the hildon-input-mode property
+    HILDON_IM_SHOW,       // Show the IM UI
+    HILDON_IM_HIDE,       // Hide the IM UI
+    HILDON_IM_UPP,        // Uppercase autocap state at cursor
+    HILDON_IM_LOW,        // Lowercase autocap state at cursor
+    HILDON_IM_DESTROY,    // DEPRECATED
+    HILDON_IM_CLEAR,      // Clear the IM UI state
+    HILDON_IM_SETCLIENT,  // Set the client window
+    HILDON_IM_SETNSHOW,   // Set the client and show the IM window 
+    HILDON_IM_SELECT_ALL, // Select the text in the plugin
+
+    /* always last */
+    HILDON_IM_NUM_COMMANDS
+};
+
+enum HildonIMTrigger
+{
+    HILDON_IM_TRIGGER_NONE = -1,
+    HILDON_IM_TRIGGER_STYLUS,
+    HILDON_IM_TRIGGER_FINGER,
+    HILDON_IM_TRIGGER_KEYBOARD
+};
+
+struct HildonIMActivateMessage
+{
+    Window input_window;
+    Window app_window;
+    HildonIMCommand cmd;
+    int input_mode;
+    HildonIMTrigger trigger;
+};
+
+struct HildonIMInsertUtf8Message
+{
+    int msg_flag;
+    char utf8_str[HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE];
+};
+
+/* IM communications, from IM process to context */
+typedef enum
+{
+  HILDON_IM_CONTEXT_HANDLE_ENTER,           /* Virtual enter activated */
+  HILDON_IM_CONTEXT_HANDLE_TAB,             /* Virtual tab activated */
+  HILDON_IM_CONTEXT_HANDLE_BACKSPACE,       /* Virtual backspace activated */
+  HILDON_IM_CONTEXT_HANDLE_SPACE,           /* Virtual space activated */
+  HILDON_IM_CONTEXT_CONFIRM_SENTENCE_START, /* Query the autocap state at cursor */
+  HILDON_IM_CONTEXT_FLUSH_PREEDIT,          /* Finalize the preedit to the client widget */
+#ifdef Q_OS_FREMANTLE
+  HILDON_IM_CONTEXT_CANCEL_PREEDIT,          /* Clean the preedit buffer */
+#endif
+
+  /* See HildonIMCommitMode for a description of the commit modes */
+  HILDON_IM_CONTEXT_BUFFERED_MODE,
+  HILDON_IM_CONTEXT_DIRECT_MODE,
+  HILDON_IM_CONTEXT_REDIRECT_MODE,
+  HILDON_IM_CONTEXT_SURROUNDING_MODE,
+#ifdef Q_OS_FREMANTLE
+  HILDON_IM_CONTEXT_PREEDIT_MODE,
+#endif
+
+  HILDON_IM_CONTEXT_CLIPBOARD_COPY,            /* Copy client selection to clipboard */
+  HILDON_IM_CONTEXT_CLIPBOARD_CUT,             /* Cut client selection to clipboard */
+  HILDON_IM_CONTEXT_CLIPBOARD_PASTE,           /* Paste clipboard selection to client */
+  HILDON_IM_CONTEXT_CLIPBOARD_SELECTION_QUERY, /* Query if the client has an active selection */
+  HILDON_IM_CONTEXT_REQUEST_SURROUNDING,       /* Request the content surrounding the cursor */
+#ifdef Q_OS_FREMANTLE
+  HILDON_IM_CONTEXT_REQUEST_SURROUNDING_FULL,          /* Request the contents of the text widget */
+#endif
+  HILDON_IM_CONTEXT_WIDGET_CHANGED,            /* IM detected that the client widget changed */
+  HILDON_IM_CONTEXT_OPTION_CHANGED,            /* The OptionMask for the active context is updated */
+  HILDON_IM_CONTEXT_CLEAR_STICKY,              /* Clear the sticky key state */
+  HILDON_IM_CONTEXT_ENTER_ON_FOCUS,            /* Generate a virtual enter key event on focus in */
+
+  /* always last */
+  HILDON_IM_CONTEXT_NUM_COM
+} HildonIMCommunication;
+
+enum HildonIMOptionMask
+{
+  HILDON_IM_AUTOCASE          = 1 << 0,
+  HILDON_IM_AUTOCORRECT       = 1 << 1,
+  HILDON_IM_AUTOLEVEL_NUMERIC = 1 << 2,
+  HILDON_IM_LOCK_LEVEL        = 1 << 3
+};
+
+struct HildonIMComMessage
+{
+    Window input_window;
+    HildonIMCommunication type;
+    HildonIMOptionMask options;
+};
+
+/* Key event message, from context to IM */
+typedef struct
+{
+  Window input_window;
+  int type;
+  unsigned int state;
+  unsigned int keyval;
+  unsigned int hardware_keycode;
+} HildonIMKeyEventMessage;
+
+
+typedef enum {
+  HILDON_IM_SHIFT_STICKY_MASK     = 1 << 0,
+  HILDON_IM_SHIFT_LOCK_MASK       = 1 << 1,
+  HILDON_IM_LEVEL_STICKY_MASK     = 1 << 2,
+  HILDON_IM_LEVEL_LOCK_MASK       = 1 << 3,
+  HILDON_IM_COMPOSE_MASK          = 1 << 4,
+  HILDON_IM_DEAD_KEY_MASK         = 1 << 5,
+} HildonIMInternalModifierMask;
+
+
+#endif
diff --git a/src/gui/inputmethod/qinputcontext.h b/src/gui/inputmethod/qinputcontext.h
index 1270d26..a158df4 100644
--- a/src/gui/inputmethod/qinputcontext.h
+++ b/src/gui/inputmethod/qinputcontext.h
@@ -76,6 +76,24 @@ class QFont;
 class QPopupMenu;
 class QInputContextPrivate;
 
+#if defined(Q_WS_HILDON)
+// this one is from GtkIMContext
+enum HildonGtkInputMode
+{
+    HILDON_GTK_INPUT_MODE_ALPHA        = 1 << 0,
+    HILDON_GTK_INPUT_MODE_NUMERIC      = 1 << 1,
+    HILDON_GTK_INPUT_MODE_SPECIAL      = 1 << 2,
+    HILDON_GTK_INPUT_MODE_HEXA         = 1 << 3,
+    HILDON_GTK_INPUT_MODE_TELE         = 1 << 4,
+
+    HILDON_GTK_INPUT_MODE_FULL         = (HILDON_GTK_INPUT_MODE_ALPHA | HILDON_GTK_INPUT_MODE_NUMERIC | HILDON_GTK_INPUT_MODE_SPECIAL),
+
+    HILDON_GTK_INPUT_MODE_MULTILINE    = 1 << 28,
+    HILDON_GTK_INPUT_MODE_INVISIBLE    = 1 << 29,
+    HILDON_GTK_INPUT_MODE_AUTOCAP      = 1 << 30,
+    HILDON_GTK_INPUT_MODE_DICTIONARY   = 1 << 31
+};
+#endif
 
 class Q_GUI_EXPORT QInputContext : public QObject
 {
diff --git a/src/gui/inputmethod/qinputcontextfactory.cpp b/src/gui/inputmethod/qinputcontextfactory.cpp
index f11c1b8..7af1d71 100644
--- a/src/gui/inputmethod/qinputcontextfactory.cpp
+++ b/src/gui/inputmethod/qinputcontextfactory.cpp
@@ -71,6 +71,9 @@
 #ifdef Q_WS_MAC
 #include "qmacinputcontext_p.h"
 #endif
+#ifdef Q_WS_HILDON
+#include "qhildoninputcontext_p.h"
+#endif
 
 #include "private/qfactoryloader_p.h"
 #include "qmutex.h"
@@ -145,6 +148,11 @@ QInputContext *QInputContextFactory::create( const QString& key, QObject *parent
         result = new QMacInputContext;
     }
 #endif
+#if defined(Q_WS_HILDON)
+    if (key == QLatin1String("hildon")) {
+        result = new QHildonInputContext;
+    }
+#endif
 #if defined(QT_NO_LIBRARY) || defined(QT_NO_SETTINGS)
     Q_UNUSED(key);
 #else
@@ -182,6 +190,9 @@ QStringList QInputContextFactory::keys()
 #if defined(Q_WS_MAC)
     result << QLatin1String("mac");
 #endif
+#if defined (Q_WS_HILDON)
+    result << QLatin1String("hildon");
+#endif
 #if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
     result += loader()->keys();
 #endif // QT_NO_LIBRARY
@@ -217,6 +228,10 @@ QStringList QInputContextFactory::languages( const QString &key )
     if (key == QLatin1String("mac"))
         return QStringList(QString());
 #endif
+#if defined (Q_WS_HILDON)
+    if (key == QLatin1String("hildon"))
+        return QStringList(QString());
+#endif
 #if defined(QT_NO_LIBRARY) || defined(QT_NO_SETTINGS)
     Q_UNUSED(key);
 #else
@@ -272,6 +287,10 @@ QString QInputContextFactory::description( const QString &key )
     if (key == QLatin1String("mac"))
         return QInputContext::tr( "Mac OS X input method" );
 #endif
+#if defined(Q_WS_HILDON)
+    if (key == QLatin1String("hildon"))
+        return QInputContext::tr("Hildon input method");
+#endif
 #if defined(QT_NO_LIBRARY) || defined(QT_NO_SETTINGS)
     Q_UNUSED(key);
 #else
diff --git a/src/gui/itemviews/qtableview.cpp b/src/gui/itemviews/qtableview.cpp
index 597ce04..c5a2729 100644
--- a/src/gui/itemviews/qtableview.cpp
+++ b/src/gui/itemviews/qtableview.cpp
@@ -2455,6 +2455,39 @@ void QTableViewPrivate::selectColumn(int column, bool anchor)
     }
 }
 
+#ifdef Q_WS_HILDON
+void QTableViewPrivate::drawOvershoot(int horizontal, int vertical)
+{
+	Q_Q(QTableView);
+	int overshoot_x = horizontal;
+	int overshoot_y = vertical;
+	int header_x = 0;
+	int header_y = 0;
+	if (overshoot_x >= 0) {
+		if (q->isRightToLeft())
+			overshoot_x += right;
+		else
+			overshoot_x += left;
+		header_x = horizontal;
+	} else {
+		if (q->isRightToLeft())
+			overshoot_x -= left;
+		else
+			overshoot_x -= right;
+	}
+	if (overshoot_y >= 0) {
+		overshoot_y += top;
+		header_y = vertical;
+	} else
+		overshoot_y -= bottom;
+
+	q->viewport()->move(overshoot_x, overshoot_y);
+	horizontalHeader->move(overshoot_x, header_y);
+	verticalHeader->move(header_x, overshoot_y);
+	cornerWidget->move(header_x, header_y);
+}
+#endif
+
 /*!
   \reimp
  */
diff --git a/src/gui/itemviews/qtableview_p.h b/src/gui/itemviews/qtableview_p.h
index ef1ae7a..14a2bf7 100644
--- a/src/gui/itemviews/qtableview_p.h
+++ b/src/gui/itemviews/qtableview_p.h
@@ -201,6 +201,10 @@ public:
 
     void selectRow(int row, bool anchor);
     void selectColumn(int column, bool anchor);
+
+#ifdef Q_WS_HILDON
+	void drawOvershoot(int horizontal, int vertical);
+#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/gui/itemviews/qtreeview.cpp b/src/gui/itemviews/qtreeview.cpp
index cdcce83..a5549d5 100644
--- a/src/gui/itemviews/qtreeview.cpp
+++ b/src/gui/itemviews/qtreeview.cpp
@@ -6,11 +6,11 @@
 ** This file is part of the QtGui module of the Qt Toolkit.
 **
 ** $QT_BEGIN_LICENSE:LGPL$
-** No Commercial Usage
-** This file contains pre-release code and may not be distributed.
-** You may use this file in accordance with the terms and conditions
-** contained in the either Technology Preview License Agreement or the
-** Beta Release License Agreement.
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
 **
 ** GNU Lesser General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU Lesser
@@ -596,13 +596,13 @@ void QTreeView::setRowHidden(int row, const QModelIndex &parent, bool hide)
     Q_D(QTreeView);
     if (!d->model)
         return;
-    QModelIndex index = d->model->index(row, 0, parent);
+    QPersistentModelIndex index = d->model->index(row, 0, parent);
     if (!index.isValid())
         return;
 
     if (hide) {
         d->hiddenIndexes.insert(index);
-    } else if(d->isPersistent(index)) { //if the index is not persistent, it cannot be in the set
+    } else {
         d->hiddenIndexes.remove(index);
     }
 
@@ -782,7 +782,7 @@ void QTreeView::collapse(const QModelIndex &index)
 
     if (d->delayedPendingLayout) {
         //A complete relayout is going to be performed, just un-store the expanded index, no need to layout.
-        if (d->isPersistent(index) && d->expandedIndexes.remove(index))
+        if (d->expandedIndexes.remove(index))
             emit collapsed(index);
         return;
     }
@@ -794,7 +794,7 @@ void QTreeView::collapse(const QModelIndex &index)
             viewport()->update();
         }
     } else {
-        if (d->isPersistent(index) && d->expandedIndexes.remove(index))
+        if (d->expandedIndexes.remove(index))
             emit collapsed(index);
     }
 }
@@ -1241,23 +1241,16 @@ bool QTreeView::viewportEvent(QEvent *event)
         int oldBranch = d->hoverBranch;
         d->hoverBranch = d->itemDecorationAt(he->pos());
         if (oldBranch != d->hoverBranch) {
-            QModelIndex oldIndex = d->modelIndex(oldBranch),
-                newIndex = d->modelIndex(d->hoverBranch);
-            if (oldIndex != newIndex) {
-                QRect oldRect = visualRect(oldIndex);
-                QRect newRect = visualRect(newIndex);
-                viewport()->update(oldRect.left() - d->indent, oldRect.top(), d->indent, oldRect.height());
-                viewport()->update(newRect.left() - d->indent, newRect.top(), d->indent, newRect.height());
-            }
+            QRect oldRect = visualRect(d->modelIndex(oldBranch));
+            QRect newRect = visualRect(d->modelIndex(d->hoverBranch));
+            viewport()->update(oldRect.left() - d->indent, oldRect.top(), d->indent, oldRect.height());
+            viewport()->update(newRect.left() - d->indent, newRect.top(), d->indent, newRect.height());
         }
         if (selectionBehavior() == QAbstractItemView::SelectRows) {
-            QModelIndex newHoverIndex = indexAt(he->pos());
-            if (d->hover != newHoverIndex) {
-                QRect oldHoverRect = visualRect(d->hover);
-                QRect newHoverRect = visualRect(newHoverIndex);
-                viewport()->update(QRect(0, newHoverRect.y(), viewport()->width(), newHoverRect.height()));
-                viewport()->update(QRect(0, oldHoverRect.y(), viewport()->width(), oldHoverRect.height()));
-            }
+            QRect oldHoverRect = visualRect(d->hover);
+            QRect newHoverRect = visualRect(indexAt(he->pos()));
+            viewport()->update(QRect(0, newHoverRect.y(), viewport()->width(), newHoverRect.height()));
+            viewport()->update(QRect(0, oldHoverRect.y(), viewport()->width(), oldHoverRect.height()));
         }
         break; }
     default:
@@ -1386,7 +1379,7 @@ void QTreeView::drawTree(QPainter *painter, const QRegion &region) const
         // start at the top of the viewport  and iterate down to the update area
         for (; i < viewItems.count(); ++i) {
             const int itemHeight = d->itemHeight(i);
-            if (y + itemHeight > area.top())
+            if (y + itemHeight >= area.top())
                 break;
             y += itemHeight;
         }
@@ -2021,7 +2014,6 @@ int QTreeView::verticalOffset() const
         // If we are scrolling per item and have non-uniform row heights,
         // finding the vertical offset in pixels is going to be relatively slow.
         // ### find a faster way to do this
-        d->executePostedLayout();
         int offset = 0;
         for (int i = 0; i < d->viewItems.count(); ++i) {
             if (i == verticalScrollBar()->value())
@@ -2052,7 +2044,8 @@ QModelIndex QTreeView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifie
         while (c < d->header->count() && d->header->isSectionHidden(c))
             ++c;
         if (i < d->viewItems.count() && c < d->header->count()) {
-            return d->modelIndex(i, c);
+            QModelIndex index = d->viewItems.value(i).index;
+            return (c == index.column() ? index : index.sibling(index.row(), c));
         }
         return QModelIndex();
     }
@@ -2093,16 +2086,16 @@ QModelIndex QTreeView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifie
     case MoveDown:
 #ifdef QT_KEYPAD_NAVIGATION
         if (vi == d->viewItems.count()-1 && QApplication::keypadNavigationEnabled())
-            return d->model->index(0, current.column(), d->root);
+            return d->model->index(0, 0, d->root);
 #endif
-        return d->modelIndex(d->below(vi), current.column());
+        return d->modelIndex(d->below(vi));
     case MovePrevious:
     case MoveUp:
 #ifdef QT_KEYPAD_NAVIGATION
         if (vi == 0 && QApplication::keypadNavigationEnabled())
-            return d->modelIndex(d->viewItems.count() - 1, current.column());
+            return d->modelIndex(d->viewItems.count() - 1);
 #endif
-        return d->modelIndex(d->above(vi), current.column());
+        return d->modelIndex(d->above(vi));
     case MoveLeft: {
         QScrollBar *sb = horizontalScrollBar();
         if (vi < d->viewItems.count() && d->viewItems.at(vi).expanded && d->itemsExpandable && sb->value() == sb->minimum())
@@ -2117,16 +2110,6 @@ QModelIndex QTreeView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifie
                     descend = false;
             }
             if (!descend) {
-                if (d->selectionBehavior == SelectItems || d->selectionBehavior == SelectColumns) {
-                    int visualColumn = d->header->visualIndex(current.column()) - 1;
-                    while (visualColumn >= 0 && isColumnHidden(d->header->logicalIndex(visualColumn)))
-                        visualColumn--;
-                    int newColumn = d->header->logicalIndex(visualColumn);
-                    QModelIndex next = current.sibling(current.row(), newColumn);
-                    if (next.isValid())
-                        return next;
-                }
-
                 sb->setValue(sb->value() - sb->singleStep());
             }
 
@@ -2149,17 +2132,6 @@ QModelIndex QTreeView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifie
                     descend = false;
             }
             if (!descend) {
-                if (d->selectionBehavior == SelectItems || d->selectionBehavior == SelectColumns) {
-                    int visualColumn = d->header->visualIndex(current.column()) + 1;
-                    while (visualColumn < d->model->columnCount(current.parent()) && isColumnHidden(d->header->logicalIndex(visualColumn)))
-                        visualColumn++;
-
-                    QModelIndex next = current.sibling(current.row(), visualColumn);
-                    if (next.isValid())
-                        return next;
-                }
-
-                //last restort: we change the scrollbar value
                 QScrollBar *sb = horizontalScrollBar();
                 sb->setValue(sb->value() + sb->singleStep());
             }
@@ -2168,13 +2140,13 @@ QModelIndex QTreeView::moveCursor(CursorAction cursorAction, Qt::KeyboardModifie
         viewport()->update();
         break;
     case MovePageUp:
-        return d->modelIndex(d->pageUp(vi), current.column());
+        return d->modelIndex(d->pageUp(vi));
     case MovePageDown:
-        return d->modelIndex(d->pageDown(vi), current.column());
+        return d->modelIndex(d->pageDown(vi));
     case MoveHome:
-        return d->model->index(0, current.column(), d->root);
+        return d->model->index(0, 0, d->root);
     case MoveEnd:
-        return d->modelIndex(d->viewItems.count() - 1, current.column());
+        return d->modelIndex(d->viewItems.count() - 1);
     }
     return current;
 }
@@ -2317,16 +2289,15 @@ void QTreeView::scrollContentsBy(int dx, int dy)
         }
     }
 
-    const int itemHeight = d->defaultItemHeight <= 0 ? sizeHintForRow(0) : d->defaultItemHeight;
-    if (d->viewItems.isEmpty() || itemHeight == 0)
+    if (d->viewItems.isEmpty() || d->defaultItemHeight == 0)
         return;
 
     // guestimate the number of items in the viewport
-    int viewCount = d->viewport->height() / itemHeight;
+    int viewCount = d->viewport->height() / d->defaultItemHeight;
     int maxDeltaY = qMin(d->viewItems.count(), viewCount);
     // no need to do a lot of work if we are going to redraw the whole thing anyway
     if (qAbs(dy) > qAbs(maxDeltaY) && d->editors.isEmpty()) {
-        verticalScrollBar()->update();
+        verticalScrollBar()->repaint();
         d->viewport->update();
         return;
     }
@@ -2569,13 +2540,41 @@ void QTreeView::sortByColumn(int column, Qt::SortOrder order)
 {
     Q_D(QTreeView);
 
-    //If sorting is enabled  will emit a signal connected to _q_sortIndicatorChanged, which then actually sorts
+    //will emit a signal connected to _q_sortIndicatorChanged, which then actually sorts
     d->header->setSortIndicator(column, order);
-    //If sorting is not enabled, force to sort now.
-    if (!d->sortingEnabled)
-        d->model->sort(column, order);
 }
 
+#ifdef Q_WS_HILDON
+void QTreeViewPrivate::drawOvershoot(int horizontal, int vertical)
+{
+	Q_Q(QTreeView);
+	int overshoot_x = horizontal;
+	int overshoot_y = vertical;
+	int header_x = 0;
+	int header_y = 0;
+	if (overshoot_x >= 0) {
+		if (q->isRightToLeft())
+			overshoot_x += right;
+		else
+			overshoot_x += left;
+		header_x = horizontal;
+	} else {
+		if (q->isRightToLeft())
+			overshoot_x -= left;
+		else
+			overshoot_x -= right;
+	}
+	if (overshoot_y >= 0) {
+		overshoot_y += top;
+		header_y = vertical;
+	} else
+		overshoot_y -= bottom;
+
+	q->viewport()->move(overshoot_x, overshoot_y);
+	header->move(overshoot_x, header_y);
+}
+#endif
+
 /*!
   \reimp
 */
@@ -2597,7 +2596,7 @@ void QTreeView::selectAll()
   Expands all expandable items.
 
   Warning: if the model contains a large number of items,
-  this function will take some time to execute.
+  this function will be take time to execute.
 
   \sa collapseAll() expand()  collapse() setExpanded()
 */
@@ -2901,13 +2900,8 @@ void QTreeViewPrivate::collapse(int item, bool emitSignal)
     if (item == -1 || expandedIndexes.isEmpty())
         return;
 
-    //if the current item is now invisible, the autoscroll will expand the tree to see it, so disable the autoscroll
-    delayedAutoScroll.stop();
-
     int total = viewItems.at(item).total;
     const QModelIndex &modelIndex = viewItems.at(item).index;
-    if (!isPersistent(modelIndex))
-        return; // if the index is not persistent, no chances it is expanded
     QSet<QPersistentModelIndex>::iterator it = expandedIndexes.find(modelIndex);
     if (it == expandedIndexes.end() || viewItems.at(item).expanded == false)
         return; // nothing to do
@@ -3374,15 +3368,10 @@ int QTreeViewPrivate::viewIndex(const QModelIndex &_index) const
     return -1;
 }
 
-QModelIndex QTreeViewPrivate::modelIndex(int i, int column) const
+QModelIndex QTreeViewPrivate::modelIndex(int i) const
 {
-    if (i < 0 || i >= viewItems.count())
-        return QModelIndex();
-
-    QModelIndex ret = viewItems.at(i).index;
-    if (column)
-        ret = ret.sibling(ret.row(), column);
-    return ret;
+    return ((i < 0 || i >= viewItems.count())
+            ? QModelIndex() : viewItems.at(i).index);
 }
 
 int QTreeViewPrivate::firstVisibleItem(int *offset) const
@@ -3510,7 +3499,6 @@ void QTreeViewPrivate::updateScrollBars()
 
 int QTreeViewPrivate::itemDecorationAt(const QPoint &pos) const
 {
-    const_cast<QTreeView *>(q_func())->executeDelayedItemsLayout();
     int x = pos.x();
     int column = header->logicalIndexAt(x);
     if (column != 0)
diff --git a/src/gui/itemviews/qtreeview.h b/src/gui/itemviews/qtreeview.h
index 35a205c..dbe443d 100644
--- a/src/gui/itemviews/qtreeview.h
+++ b/src/gui/itemviews/qtreeview.h
@@ -6,11 +6,11 @@
 ** This file is part of the QtGui module of the Qt Toolkit.
 **
 ** $QT_BEGIN_LICENSE:LGPL$
-** No Commercial Usage
-** This file contains pre-release code and may not be distributed.
-** You may use this file in accordance with the terms and conditions
-** contained in the either Technology Preview License Agreement or the
-** Beta Release License Agreement.
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
 **
 ** GNU Lesser General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU Lesser
@@ -51,7 +51,6 @@ QT_BEGIN_NAMESPACE
 QT_MODULE(Gui)
 
 #ifndef QT_NO_TREEVIEW
-
 class QTreeViewPrivate;
 class QHeaderView;
 
diff --git a/src/gui/itemviews/qtreeview_p.h b/src/gui/itemviews/qtreeview_p.h
index 6a1dfe5..d9be7f3 100644
--- a/src/gui/itemviews/qtreeview_p.h
+++ b/src/gui/itemviews/qtreeview_p.h
@@ -6,11 +6,11 @@
 ** This file is part of the QtGui module of the Qt Toolkit.
 **
 ** $QT_BEGIN_LICENSE:LGPL$
-** No Commercial Usage
-** This file contains pre-release code and may not be distributed.
-** You may use this file in accordance with the terms and conditions
-** contained in the either Technology Preview License Agreement or the
-** Beta Release License Agreement.
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
 **
 ** GNU Lesser General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU Lesser
@@ -131,7 +131,7 @@ public:
     int itemAtCoordinate(int coordinate) const;
 
     int viewIndex(const QModelIndex &index) const;
-    QModelIndex modelIndex(int i, int column = 0) const;
+    QModelIndex modelIndex(int i) const;
 
     int firstVisibleItem(int *offset = 0) const;
     int columnAt(int x) const;
@@ -231,6 +231,10 @@ public:
 
     // used for blocking recursion when calling setViewportMargins from updateGeometries
     bool geometryRecursionBlock;
+ 
+#ifdef Q_WS_HILDON
+	void drawOvershoot(int horizontal, int vertical);
+#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/gui/kernel/qapplication.cpp b/src/gui/kernel/qapplication.cpp
index 40795d1..51a938f 100644
--- a/src/gui/kernel/qapplication.cpp
+++ b/src/gui/kernel/qapplication.cpp
@@ -4952,6 +4952,10 @@ uint QApplicationPrivate::currentPlatform(){
     if (X11->desktopEnvironment == DE_CDE)
         platform |= KB_CDE;
 #endif
+#ifdef Q_WS_HILDON
+    if (X11->desktopEnvironment == DE_HILDON)
+       platform |= KB_Hildon;
+#endif
     return platform;
 }
 
diff --git a/src/gui/kernel/qapplication.h b/src/gui/kernel/qapplication.h
index 3c0e598..c32e762 100644
--- a/src/gui/kernel/qapplication.h
+++ b/src/gui/kernel/qapplication.h
@@ -382,6 +382,9 @@ private:
 #if defined(Q_WS_MAC) || defined(Q_WS_X11)
     Q_PRIVATE_SLOT(d_func(), void _q_alertTimeOut())
 #endif
+#ifdef Q_WS_HILDON
+    Q_PRIVATE_SLOT(d_func(), void _q_longPushTimeOut())
+#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/gui/kernel/qapplication_p.h b/src/gui/kernel/qapplication_p.h
index ddd5624..d4fc3ad 100644
--- a/src/gui/kernel/qapplication_p.h
+++ b/src/gui/kernel/qapplication_p.h
@@ -234,6 +234,10 @@ public:
     void createEventDispatcher();
     QString appName() const;
 
+#ifdef Q_WS_HILDON
+    static bool areXInputEventsUsed();
+#endif
+
     static void dispatchEnterLeave(QWidget *enter, QWidget *leave);
 
     //modality
@@ -270,6 +274,9 @@ public:
         KB_KDE = 8,
         KB_Gnome = 16,
         KB_CDE = 32,
+#ifdef Q_WS_HILDON
+        KB_Hildon = 64,
+#endif
         KB_All = 0xffff
     };
 
@@ -411,6 +418,9 @@ public:
 #if defined(QT_MAC_USE_COCOA)
     void _q_runModalWindow();
 #endif
+#ifdef Q_WS_HILDON
+    void _q_longPushTimeOut();
+#endif
 #ifndef QT_NO_STYLE_STYLESHEET
     static QString styleSheet;
 #endif
diff --git a/src/gui/kernel/qapplication_x11.cpp b/src/gui/kernel/qapplication_x11.cpp
old mode 100644
new mode 100755
index 163ceb6..082507a
--- a/src/gui/kernel/qapplication_x11.cpp
+++ b/src/gui/kernel/qapplication_x11.cpp
@@ -126,6 +126,10 @@ extern "C" {
 
 #include "qwidget_p.h"
 
+#ifdef Q_WS_HILDON
+#  include "qmainwindow.h"
+#endif
+
 #include <private/qbackingstore_p.h>
 
 QT_BEGIN_NAMESPACE
@@ -253,6 +257,11 @@ static const char * x11_atomnames = {
 
     "_NET_SYSTEM_TRAY_VISUAL\0"
 
+    // Hildon Menu
+#ifdef Q_WS_HILDON
+    "_MB_GRAB_TRANSFER\0"
+#endif
+
     // Property formats
     "COMPOUND_TEXT\0"
     "TEXT\0"
@@ -291,6 +300,30 @@ static const char * x11_atomnames = {
     // Xkb
     "_XKB_RULES_NAMES\0"
 
+    //Hildon Input Method Protocol
+#ifdef Q_WS_HILDON
+    // find the global im window
+    "_HILDON_IM_WINDOW\0"
+    // activate the input method
+    "_HILDON_IM_ACTIVATE\0"
+    //send sourrounding
+    "_HILDON_IM_SURROUNDING\0"
+    //send sourrounding header
+    "_HILDON_IM_SURROUNDING_CONTENT\0"
+    // send key event to im
+    "_HILDON_IM_KEY_EVENT\0"
+    // input method wants to insert data
+    "_HILDON_IM_INSERT_UTF8\0"
+    // input method wants to communicate with us
+    "_HILDON_IM_COM\0"
+    //### NOT USED YET
+    "_HILDON_IM_CLIPBOARD_COPIED\0"
+    //### NOT USED YET
+    "_HILDON_IM_CLIPBOARD_SELECTION_QUERY\0"
+    // tell im whether we have a selection or not
+    "_HILDON_IM_CLIPBOARD_SELECTION_REPLY\0"
+#endif
+
     // XEMBED
     "_XEMBED\0"
     "_XEMBED_INFO\0"
@@ -318,7 +351,10 @@ static bool        appDoGrab        = false;        // X11 grabbing override (gd
 static bool        app_save_rootinfo = false;        // save root info
 static bool        app_do_modal        = false;        // modal mode
 static Window        curWin = 0;                        // current window
-
+#ifdef Q_WS_HILDON
+//XInput events are managed by Qt for some input devices (eg. touchscreen)
+static bool are_xinput_events_used = false; 
+#endif
 
 // function to update the workarea of the screen - in qdesktopwidget_x11.cpp
 extern void qt_desktopwidget_update_workarea();
@@ -343,6 +379,11 @@ static Qt::MouseButtons mouseButtonState     = Qt::NoButton; // mouse button sta
 static Time        mouseButtonPressTime = 0;        // when was a button pressed
 static short        mouseXPos, mouseYPos;                // mouse pres position in act window
 static short        mouseGlobalXPos, mouseGlobalYPos; // global mouse press position
+#ifdef Q_WS_HILDON
+#define RIGHT_CLICK_TIME 2000
+static QPointer<QTimer> longPushTimer = 0; // hildon emulates right click with long press - needs a timer
+static QPointer<QWidget> qetWidget=0; 
+#endif
 
 extern QWidgetList *qt_modal_stack;                // stack of modal widgets
 
@@ -988,6 +1029,7 @@ bool QApplicationPrivate::x11_apply_settings()
             qt_xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
     }
 #endif
+#ifndef Q_WS_HILDON // hildon has its own input method
     QStringList inputMethods = QInputContextFactory::keys();
     if (inputMethods.size() > 2 && inputMethods.contains(QLatin1String("imsw-multi"))) {
         X11->default_im = QLatin1String("imsw-multi");
@@ -995,6 +1037,7 @@ bool QApplicationPrivate::x11_apply_settings()
         X11->default_im = settings.value(QLatin1String("DefaultInputMethod"),
                                          QLatin1String("xim")).toString();
     }
+#endif
 
     settings.endGroup(); // Qt
 
@@ -1688,8 +1731,11 @@ void qt_init(QApplicationPrivate *priv, int,
     X11->seen_badwindow = false;
 
     X11->motifdnd_active = false;
-
+#ifdef Q_WS_HILDON
+    X11->default_im = QLatin1String("hildon");
+#else
     X11->default_im = QLatin1String("imsw-multi");
+#endif
     priv->inputContext = 0;
 
     // colormap control
@@ -1954,10 +2000,18 @@ void qt_init(QApplicationPrivate *priv, int,
             // engine to work on a QImage with BGR layout.
             bool local = displayName.isEmpty() || displayName.lastIndexOf(QLatin1Char(':')) == 0;
             if (local && (qgetenv("QT_X11_NO_MITSHM").toInt() == 0)) {
+
+#ifdef Q_WS_HILDON
+				// The original code assumes 24bit color but NIT is 16 color,
+				// so X11->use_mitshm is set as false, and it causes a slowness issue
+				// for raster drawing.
+				X11->use_mitshm = mitshm_pixmaps;
+#else
                 Visual *defaultVisual = DefaultVisual(X11->display, DefaultScreen(X11->display));
                 X11->use_mitshm = mitshm_pixmaps && (defaultVisual->red_mask == 0xff0000
                                                      && defaultVisual->green_mask == 0xff00
                                                      && defaultVisual->blue_mask == 0xff);
+#endif // Q_WS_HILDON
             }
         }
 #endif // QT_NO_MITSHM
@@ -2271,6 +2325,10 @@ void qt_init(QApplicationPrivate *priv, int,
                         X11->desktopEnvironment = DE_KDE;
                     if (wmName == QLatin1String("Metacity"))
                         X11->desktopEnvironment = DE_GNOME;
+#ifdef Q_WS_HILDON
+                    if (wmName == QLatin1String("matchbox") || wmName == QLatin1String("hildon-desktop"))
+                        X11->desktopEnvironment = DE_HILDON;
+#endif
                 }
             }
         }
@@ -2340,7 +2398,9 @@ void qt_init(QApplicationPrivate *priv, int,
                 i,
                 j;
             bool gotStylus,
-                gotEraser;
+                 gotEraser,
+                 gotTouchscreen; //Maemo changes: Using XInput to get Touchscreen events
+
             XDeviceInfo *devices = 0, *devs;
             XInputClassInfo *ip;
             XAnyClassPtr any;
@@ -2354,6 +2414,9 @@ void qt_init(QApplicationPrivate *priv, int,
             const QString XFREENAMEPEN = QLatin1String("pen");
             const QString XFREENAMEERASER = QLatin1String("eraser");
 #endif
+#ifdef Q_WS_HILDON
+            const QString XFREENAMETOUCHSCREEN = QLatin1String("touchscreen");
+#endif
 
             if (X11->ptrXListInputDevices) {
                 devices = X11->ptrXListInputDevices(X11->display, &ndev);
@@ -2384,17 +2447,32 @@ void qt_init(QApplicationPrivate *priv, int,
                     deviceType = QTabletEvent::XFreeEraser;
                     gotEraser = true;
                 }
+#ifdef Q_WS_HILDON
+                else if (devName.endsWith(XFREENAMETOUCHSCREEN)) {
+                    deviceType = QTabletEvent::Stylus;
+                    gotTouchscreen = true;
+                }
 #endif
+#endif //Q_OS_IRIX
+
                 if (deviceType == QTabletEvent::NoDevice)
                     continue;
 
+#ifdef Q_WS_HILDON
+                if (gotStylus || gotEraser || gotTouchscreen) {
+#else
                 if (gotStylus || gotEraser) {
+#endif
                     if (X11->ptrXOpenDevice)
                         dev = X11->ptrXOpenDevice(X11->display, devs->id);
 
                     if (!dev)
                         continue;
 
+#ifdef Q_WS_HILDON
+                    are_xinput_events_used = true;
+#endif
+
                     QTabletDeviceData device_data;
                     device_data.deviceType = deviceType;
                     device_data.eventCount = 0;
@@ -2599,6 +2677,11 @@ void QApplicationPrivate::x11_initialize_style()
         case DE_CDE:
             QApplicationPrivate::app_style = QStyleFactory::create(QLatin1String("cde"));
             break;
+#ifdef Q_WS_HILDON
+        case DE_HILDON:
+            QApplicationPrivate::app_style = QStyleFactory::create(QLatin1String("hildon"));
+        break;
+#endif
         default:
             // Don't do anything
             break;
@@ -2757,6 +2840,12 @@ QString QApplicationPrivate::appName() const
     return QString::fromLocal8Bit(QT_PREPEND_NAMESPACE(appName));
 }
 
+#ifdef Q_WS_HILDON
+bool QApplicationPrivate::areXInputEventsUsed(){
+    return are_xinput_events_used;
+}
+#endif
+
 const char *QX11Info::appClass()                                // get application class
 {
     return QT_PREPEND_NAMESPACE(appClass);
@@ -3031,6 +3120,50 @@ void QApplicationPrivate::_q_alertTimeOut()
     }
 }
 
+#ifdef Q_WS_HILDON
+void QApplicationPrivate::_q_longPushTimeOut(){
+
+    const int radius= 15;
+    const QPoint globalMousePressPos(mouseGlobalXPos,mouseGlobalYPos);
+    const QPoint globalCurrentPos= QCursor::pos();
+
+    // Exits if the cursor is not in the surrounding area
+    // of the press event
+    const QPoint deltaPos= globalMousePressPos - globalCurrentPos;
+    if ( qAbs(deltaPos.x())  >= radius ||
+         qAbs(deltaPos.y())  >= radius){
+        return;
+    }
+
+    // Gets the Widget under the mouse and the relative cursor position
+    QWidget *w;
+    QPoint pos;
+
+    if (qetWidget.isNull()){
+        return;
+    }
+
+    pos = qetWidget->mapFromGlobal(globalMousePressPos);
+    w = qetWidget->childAt(pos);
+    if (!w) {
+        w= qetWidget;
+        pos= w->mapFromGlobal(globalMousePressPos);
+    }
+
+    //Emulates the following events in the correct order
+    QMouseEvent mpe( QEvent::MouseButtonPress, pos, Qt::RightButton, 
+                     mouse_buttons, modifier_buttons );
+    QApplication::sendSpontaneousEvent(w, &mpe);
+
+    QContextMenuEvent e(QContextMenuEvent::Mouse, pos, modifier_buttons);
+    QApplication::sendSpontaneousEvent(w, &e);
+
+    QMouseEvent mre( QEvent::MouseButtonPress, pos, Qt::RightButton, 
+                     mouse_buttons, modifier_buttons );
+    QApplication::sendSpontaneousEvent(w, &mre);
+}
+#endif
+
 /*****************************************************************************
   Special lookup functions for windows that have been reparented recently
  *****************************************************************************/
@@ -3124,10 +3257,30 @@ int QApplication::x11ClientMessage(QWidget* w, XEvent* event, bool passive_only)
             X11->xdndHandleDrop(widget, event, passive_only);
         } else if (event->xclient.message_type == ATOM(XdndFinished)) {
             X11->xdndHandleFinished(widget, event, passive_only);
+#ifdef Q_WS_HILDON
+        } else if (event->xclient.message_type == ATOM(_MB_GRAB_TRANSFER)) {
+
+            if (passive_only || !QApplicationPrivate::active_window)
+                return 0;
+
+            QMainWindow *mw=qobject_cast<QMainWindow*>(widget);
+            if (mw)
+              mw->showApplicationContextMenu();
+#endif
         } else {
             if (passive_only) return 0;
             // All other are interactions
+
         }
+#ifdef Q_WS_HILDON
+    } else if (event->xclient.message_type == ATOM(_HILDON_IM_INSERT_UTF8)
+            || event->xclient.message_type == ATOM(_HILDON_IM_COM)
+            || event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING)
+            || event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING_CONTENT)) {
+        QInputContext *qic = w->inputContext();
+        if (qic && qic->x11FilterEvent(w, event))
+            return 0;
+#endif
     } else {
         X11->motifdndHandle(widget, event, passive_only);
     }
@@ -4254,13 +4407,26 @@ bool QETWidget::translateMouseEvent(const XEvent *event)
                 mouseButtonPressed == button &&
                 (long)event->xbutton.time -(long)mouseButtonPressTime
                 < QApplication::doubleClickInterval() &&
+#ifndef Q_WS_HILDON
                 qAbs(event->xbutton.x - mouseXPos) < 5 &&
                 qAbs(event->xbutton.y - mouseYPos) < 5) {
+#else
+                //Increasing the double click radius for fingers taps
+                qAbs(event->xbutton.x - mouseXPos) < 20 &&
+                qAbs(event->xbutton.y - mouseYPos) < 20) {
+#endif
                 type = QEvent::MouseButtonDblClick;
                 mouseButtonPressTime -= 2000;        // no double-click next time
             } else {
                 type = QEvent::MouseButtonPress;
                 mouseButtonPressTime = event->xbutton.time;
+#ifdef Q_WS_HILDON
+                qetWidget=this;
+                longPushTimer= new QTimer(qApp);// RMB emulation
+                longPushTimer->setSingleShot(true);
+                connect(longPushTimer, SIGNAL(timeout()),qApp, SLOT(_q_longPushTimeOut()));
+                longPushTimer->start(RIGHT_CLICK_TIME);
+#endif
             }
             mouseButtonPressed = button;        // save event params for
             mouseXPos = event->xbutton.x;                // future double click tests
@@ -4286,6 +4452,11 @@ bool QETWidget::translateMouseEvent(const XEvent *event)
             }
 #endif
             type = QEvent::MouseButtonRelease;
+#ifdef Q_WS_HILDON
+            //Prevent crashes when the application doesn't receive a mouse press button
+            if (longPushTimer)
+                longPushTimer->stop();
+#endif
         }
     }
     mouseActWindow = effectiveWinId();                        // save some event params
diff --git a/src/gui/kernel/qkeysequence.cpp b/src/gui/kernel/qkeysequence.cpp
index 22dd30b..67e7ee9 100644
--- a/src/gui/kernel/qkeysequence.cpp
+++ b/src/gui/kernel/qkeysequence.cpp
@@ -519,8 +519,14 @@ const QKeyBinding QKeySequencePrivate::keyBindings[] = {
     {QKeySequence::WhatsThis,               1,          Qt::SHIFT | Qt::Key_F1,                 QApplicationPrivate::KB_All},
     {QKeySequence::FindPrevious,            0,          Qt::SHIFT | Qt::Key_F3,                 QApplicationPrivate::KB_X11},
     {QKeySequence::FindPrevious,            1,          Qt::SHIFT | Qt::Key_F3,                 QApplicationPrivate::KB_Win},
+#ifdef Q_WS_HILDON
+    {QKeySequence::ZoomIn,                  1,          Qt::Key_F7,                             QApplicationPrivate::KB_Hildon},
+#endif
     {QKeySequence::ZoomIn,                  1,          Qt::CTRL | Qt::Key_Plus,                QApplicationPrivate::KB_All},
     {QKeySequence::NextChild,               0,          Qt::CTRL | Qt::Key_Comma,               QApplicationPrivate::KB_KDE},
+#ifdef Q_WS_HILDON
+    {QKeySequence::ZoomOut,                 1,          Qt::Key_F8,                             QApplicationPrivate::KB_Hildon},
+#endif
     {QKeySequence::ZoomOut,                 1,          Qt::CTRL | Qt::Key_Minus,               QApplicationPrivate::KB_All},
     {QKeySequence::PreviousChild,           0,          Qt::CTRL | Qt::Key_Period,              QApplicationPrivate::KB_KDE},
     {QKeySequence::HelpContents,            1,          Qt::CTRL | Qt::Key_Question,            QApplicationPrivate::KB_Mac},
diff --git a/src/gui/kernel/qt_x11_p.h b/src/gui/kernel/qt_x11_p.h
index b36b3f4..1593fa3 100644
--- a/src/gui/kernel/qt_x11_p.h
+++ b/src/gui/kernel/qt_x11_p.h
@@ -324,6 +324,9 @@ enum DesktopEnvironment {
     DE_KDE,
     DE_GNOME,
     DE_CDE,
+#ifdef Q_WS_HILDON
+    DE_HILDON,
+#endif
     DE_4DWM
 };
 
@@ -610,6 +613,11 @@ struct QX11Data
 
         _NET_SYSTEM_TRAY_VISUAL,
 
+        // Hildon Menu
+#ifdef Q_WS_HILDON
+        _MB_GRAB_TRANSFER,
+#endif
+
         // Property formats
         COMPOUND_TEXT,
         TEXT,
@@ -648,6 +656,19 @@ struct QX11Data
         // Xkb
         _XKB_RULES_NAMES,
 
+#ifdef Q_WS_HILDON
+        _HILDON_IM_WINDOW,
+        _HILDON_IM_ACTIVATE,
+        _HILDON_IM_SURROUNDING,
+        _HILDON_IM_SURROUNDING_CONTENT,
+        _HILDON_IM_KEY_EVENT,
+        _HILDON_IM_INSERT_UTF8,
+        _HILDON_IM_COM,
+        _HILDON_IM_CLIPBOARD_COPIED,          //### NOT USED
+        _HILDON_IM_CLIPBOARD_SELECTION_QUERY, //### NOT USED
+        _HILDON_IM_CLIPBOARD_SELECTION_REPLY,
+#endif
+
         // XEMBED
         _XEMBED,
         _XEMBED_INFO,
diff --git a/src/gui/kernel/qwidget.cpp b/src/gui/kernel/qwidget.cpp
index e6a5ae0..f2320a0 100644
--- a/src/gui/kernel/qwidget.cpp
+++ b/src/gui/kernel/qwidget.cpp
@@ -8480,6 +8480,10 @@ QVariant QWidget::inputMethodQuery(Qt::InputMethodQuery query) const
         return QRect(width()/2, 0, 1, height());
     case Qt::ImFont:
         return font();
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:
+        return QVariant(HILDON_GTK_INPUT_MODE_FULL);
+#endif
     default:
         return QVariant();
     }
diff --git a/src/gui/kernel/qwidget_p.h b/src/gui/kernel/qwidget_p.h
index d6cc4f7..6f2da38 100644
--- a/src/gui/kernel/qwidget_p.h
+++ b/src/gui/kernel/qwidget_p.h
@@ -149,6 +149,9 @@ struct QTLWExtra {
     HICON winIconBig; // internal big Windows icon
     HICON winIconSmall; // internal small Windows icon
 #endif
+#ifdef Q_WS_HILDON
+    bool customContextSet;
+#endif
     QRect normalGeometry; // used by showMin/maximized/FullScreen
     QWindowSurface *windowSurface;
     QPainter *sharedPainter;
@@ -223,6 +226,9 @@ public:
     void setMaxWindowState_helper();
     void setFullScreenSize_helper();
 #endif
+#ifdef Q_WS_HILDON
+    bool setCustomContext();
+#endif
     void init(QWidget *desktopWidget, Qt::WindowFlags f);
     void create_sys(WId window, bool initializeWindow, bool destroyOldWindow);
     void createRecursively();
diff --git a/src/gui/kernel/qwidget_x11.cpp b/src/gui/kernel/qwidget_x11.cpp
index c7b32f2..27c134e 100644
--- a/src/gui/kernel/qwidget_x11.cpp
+++ b/src/gui/kernel/qwidget_x11.cpp
@@ -68,6 +68,10 @@
 
 #include <stdlib.h>
 
+#ifdef Q_WS_HILDON
+#  include "qvarlengtharray.h"
+#endif
+
 //#define ALIEN_DEBUG
 
 // defined in qapplication_x11.cpp
@@ -757,7 +761,10 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
         Atom protocols[4];
         int n = 0;
         protocols[n++] = ATOM(WM_DELETE_WINDOW);        // support del window protocol
+#ifndef Q_OS_FREMANTLE
+	//This is just a workaround
         protocols[n++] = ATOM(WM_TAKE_FOCUS);                // support take focus window protocol
+#endif
         protocols[n++] = ATOM(_NET_WM_PING);                // support _NET_WM_PING protocol
         if (flags & Qt::WindowContextHelpButtonHint)
             protocols[n++] = ATOM(_NET_WM_CONTEXT_HELP);
@@ -2003,9 +2010,11 @@ void QWidgetPrivate::setNetWmWindowTypes()
         windowTypes.append(ATOM(_KDE_NET_WM_WINDOW_TYPE_OVERRIDE));
     }
 
-    // normal netwm type - default
-    windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_NORMAL));
+    if (windowTypes.isEmpty()) {
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_NORMAL));
+    }
 
+    //FIXME Upstream Qt bug: XDeleteProperty won't never executed.
     if (!windowTypes.isEmpty()) {
         XChangeProperty(X11->display, q->winId(), ATOM(_NET_WM_WINDOW_TYPE), XA_ATOM, 32,
                         PropModeReplace, (unsigned char *) windowTypes.constData(),
@@ -2624,6 +2633,9 @@ void QWidgetPrivate::createTLSysExtra()
     extra->topextra->validWMState = 0;
     extra->topextra->waitingForMapNotify = 0;
     extra->topextra->userTimeWindow = 0;
+#ifdef Q_WS_HILDON
+    extra->topextra->customContextSet = 0;
+#endif
 }
 
 void QWidgetPrivate::deleteTLSysExtra()
@@ -2853,6 +2865,48 @@ void QWidgetPrivate::setModal_sys()
 {
 }
 
+#ifdef Q_WS_HILDON
+/*
+    Sets the _NET_WM_CONTEXT_CUSTOM atom on the root window
+    then Hildon knows that the app is capable to display a global menu
+ */
+bool QWidgetPrivate::setCustomContext()
+{
+    Q_Q(QWidget);
+
+    QWidget *window = q->window();
+    QTLWExtra *x = window->d_func()->topData();
+    Q_ASSERT(x);
+
+    if (x->customContextSet)
+        return true;
+
+    WId windowHandle = window->winId();
+    Atom *oldAtoms = 0;
+    int count = 0;
+
+    if (!XGetWMProtocols(QX11Info::display(), windowHandle, &oldAtoms, &count)) {
+        qWarning("Hildon Integration: Unable to get WM Protocols");
+        return false;
+    }
+    Atom customContext = XInternAtom (QX11Info::display(), "_NET_WM_CONTEXT_CUSTOM", false);
+
+    // create a new list of atoms
+    QVarLengthArray<Atom, 8> newAtoms; //FIXME is the prealloc value okay?
+    newAtoms.append(oldAtoms, count);
+    newAtoms.append(customContext);
+    XFree(oldAtoms);
+
+    if (!XSetWMProtocols(QX11Info::display(), windowHandle, newAtoms.data(), newAtoms.count())) {
+        qWarning("Hildon Integration: Unable to set WM Protocols");
+        return false;
+    }
+
+    x->customContextSet = 1;
+    return true;
+}
+#endif
+
 void qt_x11_getX11InfoForWindow(QX11Info * xinfo, const QX11WindowAttributes &att)
 {
     QX11InfoData* xd = xinfo->getX11Data(true);
diff --git a/src/gui/styles/gtksymbols.cpp b/src/gui/styles/gtksymbols.cpp
index be9b10a..daf9888 100644
--- a/src/gui/styles/gtksymbols.cpp
+++ b/src/gui/styles/gtksymbols.cpp
@@ -103,6 +103,9 @@ Ptr_gtk_frame_new QGtk::gtk_frame_new = 0;
 Ptr_gtk_expander_new QGtk::gtk_expander_new = 0;
 Ptr_gtk_statusbar_new QGtk::gtk_statusbar_new = 0;
 Ptr_gtk_entry_new QGtk::gtk_entry_new = 0;
+#ifdef Q_OS_FREMANTLE
+Ptr_gtk_text_view_new QGtk::gtk_text_view_new = 0;
+#endif
 Ptr_gtk_hscale_new QGtk::gtk_hscale_new = 0;
 Ptr_gtk_vscale_new QGtk::gtk_vscale_new = 0;
 Ptr_gtk_hscrollbar_new QGtk::gtk_hscrollbar_new = 0;
@@ -173,6 +176,9 @@ Ptr_gtk_file_chooser_get_filenames QGtk::gtk_file_chooser_get_filenames = 0;
 Ptr_gtk_file_chooser_set_current_name QGtk::gtk_file_chooser_set_current_name = 0;
 Ptr_gtk_dialog_run QGtk::gtk_dialog_run = 0;
 Ptr_gtk_file_chooser_set_filename QGtk::gtk_file_chooser_set_filename = 0;
+#ifdef Q_WS_HILDON
+Ptr_hildon_file_chooser_dialog_new QGtk::hildon_file_chooser_dialog_new = 0;
+#endif
 
 Ptr_gdk_pixbuf_get_pixels QGtk::gdk_pixbuf_get_pixels = 0;
 Ptr_gdk_pixbuf_get_width QGtk::gdk_pixbuf_get_width = 0;
@@ -192,6 +198,11 @@ Ptr_gdk_x11_drawable_get_xdisplay QGtk::gdk_x11_drawable_get_xdisplay = 0;
 Ptr_gconf_client_get_default QGtk::gconf_client_get_default = 0;
 Ptr_gconf_client_get_string QGtk::gconf_client_get_string = 0;
 
+#ifdef Q_WS_HILDON
+Ptr_hildon_number_editor_new QGtk::hildon_number_editor_new = 0;
+Ptr_gtk_widget_set_name QGtk::gtk_widget_set_name = 0;
+#endif
+
 static QString classPath(GtkWidget *widget)
 {
     char* class_path;
@@ -208,6 +219,11 @@ static QString classPath(GtkWidget *widget)
 static void resolveGtk()
 {
     const QString GTK_PATH(QLS("gtk-x11-2.0"));
+#ifdef Q_WS_HILDON
+    const QString HILDON_PATH(QLS("hildon-1"));
+    const QString HILDONFM_PATH("hildonfm");
+#endif
+
     QGtk::gtk_init = (Ptr_gtk_init)QLibrary::resolve(GTK_PATH, 0, "gtk_init");
     QGtk::gtk_window_new = (Ptr_gtk_window_new)QLibrary::resolve(GTK_PATH, 0, "gtk_window_new");
     QGtk::gtk_style_attach = (Ptr_gtk_style_attach)QLibrary::resolve(GTK_PATH, 0, "gtk_style_attach");
@@ -227,6 +243,9 @@ static void resolveGtk()
     QGtk::gtk_file_chooser_set_current_name = (Ptr_gtk_file_chooser_set_current_name)QLibrary::resolve(GTK_PATH, 0, "gtk_file_chooser_set_current_name");
     QGtk::gtk_dialog_run = (Ptr_gtk_dialog_run)QLibrary::resolve(GTK_PATH, 0, "gtk_dialog_run");
     QGtk::gtk_file_chooser_set_filename = (Ptr_gtk_file_chooser_set_filename)QLibrary::resolve(GTK_PATH, 0, "gtk_file_chooser_set_filename");
+#ifdef Q_WS_HILDON
+    QGtk::hildon_file_chooser_dialog_new = (Ptr_hildon_file_chooser_dialog_new)QLibrary::resolve(HILDONFM_PATH, 2, "hildon_file_chooser_dialog_new");
+#endif
 
     QGtk::gdk_pixbuf_get_pixels = (Ptr_gdk_pixbuf_get_pixels)QLibrary::resolve(GTK_PATH, 0, "gdk_pixbuf_get_pixels");
     QGtk::gdk_pixbuf_get_width = (Ptr_gdk_pixbuf_get_width)QLibrary::resolve(GTK_PATH, 0, "gdk_pixbuf_get_width");
@@ -268,6 +287,9 @@ static void resolveGtk()
     QGtk::gtk_scrolled_window_new = (Ptr_gtk_scrolled_window_new)QLibrary::resolve(GTK_PATH, 0, "gtk_scrolled_window_new");
     QGtk::gtk_menu_shell_append = (Ptr_gtk_menu_shell_append)QLibrary::resolve(GTK_PATH, 0, "gtk_menu_shell_append");
     QGtk::gtk_entry_new = (Ptr_gtk_entry_new)QLibrary::resolve(GTK_PATH, 0, "gtk_entry_new");
+#ifdef Q_OS_FREMANTLE
+    QGtk::gtk_text_view_new  = (Ptr_gtk_text_view_new)QLibrary::resolve(GTK_PATH, 0, "gtk_text_view_new");
+#endif
     QGtk::gtk_tree_view_new = (Ptr_gtk_tree_view_new)QLibrary::resolve(GTK_PATH, 0, "gtk_tree_view_new");
     QGtk::gtk_combo_box_new = (Ptr_gtk_combo_box_new)QLibrary::resolve(GTK_PATH, 0, "gtk_combo_box_new");
     QGtk::gtk_progress_set_adjustment = (Ptr_gtk_progress_set_adjustment)QLibrary::resolve(GTK_PATH, 0, "gtk_progress_set_adjustment");
@@ -319,6 +341,10 @@ static void resolveGtk()
     QGtk::pango_font_description_get_weight = (Ptr_pango_font_description_get_weight)QLibrary::resolve(GTK_PATH, 0, "pango_font_description_get_weight");
     QGtk::pango_font_description_get_family = (Ptr_pango_font_description_get_family)QLibrary::resolve(GTK_PATH, 0, "pango_font_description_get_family");
     QGtk::pango_font_description_get_style = (Ptr_pango_font_description_get_style)QLibrary::resolve(GTK_PATH, 0, "pango_font_description_get_style");
+#ifdef Q_WS_HILDON
+    QGtk::hildon_number_editor_new = (Ptr_hildon_number_editor_new)QLibrary::resolve(HILDON_PATH, 0, "hildon_number_editor_new");
+    QGtk::gtk_widget_set_name = (Ptr_gtk_widget_set_name)QLibrary::resolve(GTK_PATH, 0, "gtk_widget_set_name");
+#endif
 }
 
 void QGtk::cleanup_gtk_widgets()
@@ -369,10 +395,17 @@ static QString getThemeName()
         foreach (const QString &rcPath, paths) {
             if (!rcPath.isEmpty()) {
                 QFile rcFile(rcPath);
+#ifdef Q_WS_HILDON //Fremantle
+                if (rcPath.contains(QLS("/etc/hildon/theme/gtk-2.0/gtkrc"))){
+                    QString slt = QFile::symLinkTarget("/etc/hildon/theme");
+                    themeName = slt.split(QLS("/")).last();
+                }else
+#endif
                 if (rcFile.exists() && rcFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
                     QTextStream in(&rcFile);
                     while(!in.atEnd()) {
                         QString line = in.readLine();
+#ifndef Q_WS_HILDON //Diablo
                         if (line.contains(QLS("gtk-theme-name"))) {
                             line = line.right(line.length() - line.indexOf(QLS("=")) - 1);
                             line.remove(QLS("\""));
@@ -380,6 +413,13 @@ static QString getThemeName()
                             themeName = line;
                             break;
                         }
+#else
+                        QRegExp rx("include \"/usr/share/themes/([\\d\\w]*)/gtk-2.0/gtkrc\"");
+                        if (rx.indexIn(line, 0) != -1) {
+                            themeName = rx.cap(1);
+                        }
+#endif
+
                     }
                 }
             }
@@ -470,6 +510,13 @@ static void init_gtk_menu()
     GtkWidget *gtkMenu = QGtk::gtk_menu_new();
     QGtk::gtk_menu_item_set_submenu((GtkMenuItem*)(gtkMenuBarItem), gtkMenu);
     QGtk::gtk_widget_realize(gtkMenu);
+#ifdef Q_WS_HILDON
+    //Application context menu.
+    GtkWidget *gtkContainerMenu = QGtk::gtk_menu_new();
+    QGtk::gtk_widget_set_name(gtkContainerMenu, "menu_force_with_corners");
+    QGtk::gtk_widget_realize(gtkContainerMenu);
+    add_widget_to_map(gtkContainerMenu);
+#endif
 
     GtkWidget *gtkMenuItem = QGtk::gtk_menu_item_new();
     QGtk::gtk_menu_shell_append((GtkMenuShell*)gtkMenu, gtkMenuItem);
@@ -667,6 +714,9 @@ void QGtk::initGtkWidgets()
             add_widget(QGtk::gtk_combo_box_new());
             add_widget(QGtk::gtk_combo_box_entry_new());
             add_widget(QGtk::gtk_entry_new());
+#ifdef Q_OS_FREMANTLE
+            add_widget(QGtk::gtk_text_view_new());
+#endif
             add_widget(QGtk::gtk_frame_new(NULL));
             add_widget(QGtk::gtk_expander_new(""));
             add_widget(QGtk::gtk_statusbar_new());
@@ -684,6 +734,10 @@ void QGtk::initGtkWidgets()
             init_gtk_treeview();
             add_widget(QGtk::gtk_vscale_new((GtkAdjustment*)(QGtk::gtk_adjustment_new(1, 0, 1, 0, 0, 0))));
             add_widget(QGtk::gtk_vscrollbar_new(NULL));
+#ifdef Q_WS_HILDON
+            //ComboBoxes buttons
+            add_widget(QGtk::hildon_number_editor_new(0,1));
+#endif
         }
         else // Rebuild map
         {
@@ -756,7 +810,11 @@ static void setupGtkFileChooser(GtkWidget* gtkFileChooser, QWidget *parent,
 
     QFileInfo fileinfo(dir);
     if (dir.isEmpty())
+#ifndef Q_WS_HILDON
+        return;
+#else
         fileinfo.setFile(QDir::currentPath());
+#endif
     fileinfo.makeAbsolute();
     if (fileinfo.isDir()) {
         QGtk::gtk_file_chooser_set_current_folder((GtkFileChooser*)gtkFileChooser, qPrintable(dir));
@@ -767,18 +825,20 @@ static void setupGtkFileChooser(GtkWidget* gtkFileChooser, QWidget *parent,
         QGtk::gtk_file_chooser_set_filename((GtkFileChooser*)gtkFileChooser, qPrintable(dir));
     }
 }
-
+#include <QDebug>
 QString QGtk::openFilename(QWidget *parent, const QString &caption, const QString &dir, const QString &filter,
                             QString *selectedFilter, QFileDialog::Options options)
 {
-
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_OPEN);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_OPEN,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                              NULL);
-
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, filter, selectedFilter, options);
 
     QWidget modal_widget;
@@ -787,27 +847,35 @@ QString QGtk::openFilename(QWidget *parent, const QString &caption, const QStrin
     QApplicationPrivate::enterModal(&modal_widget);
 
     QString filename;
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         char *gtk_filename = QGtk::gtk_file_chooser_get_filename ((GtkFileChooser*)gtkFileChooser);
         filename = QString::fromUtf8(gtk_filename);
         g_free (gtk_filename);
     }
-
     QApplicationPrivate::leaveModal(&modal_widget);
     gtk_widget_destroy (gtkFileChooser);
     return filename;
+
 }
 
 
 QString QGtk::openDirectory(QWidget *parent, const QString &caption, const QString &dir, QFileDialog::Options options)
 {
+ qDebug() << "DIR" << dir;
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                              NULL);
-
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, QString(), 0, options);
     QWidget modal_widget;
     modal_widget.setAttribute(Qt::WA_NoChildEventsForParent, true);
@@ -815,7 +883,11 @@ QString QGtk::openDirectory(QWidget *parent, const QString &caption, const QStri
     QApplicationPrivate::enterModal(&modal_widget);
 
     QString filename;
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         char *gtk_filename = QGtk::gtk_file_chooser_get_filename ((GtkFileChooser*)gtkFileChooser);
         filename = QString::fromUtf8(gtk_filename);
         g_free (gtk_filename);
@@ -830,13 +902,16 @@ QStringList QGtk::openFilenames(QWidget *parent, const QString &caption, const Q
                                  QString *selectedFilter, QFileDialog::Options options)
 {
     QStringList filenames;
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_OPEN);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_OPEN,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                              NULL);
-
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, filter, selectedFilter, options);
     g_object_set(gtkFileChooser, "select-multiple", gboolean(true), NULL);
 
@@ -845,7 +920,11 @@ QStringList QGtk::openFilenames(QWidget *parent, const QString &caption, const Q
     modal_widget.setParent(parent, Qt::Window);
     QApplicationPrivate::enterModal(&modal_widget);
 
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         GSList *gtk_file_names = QGtk::gtk_file_chooser_get_filenames((GtkFileChooser*)gtkFileChooser);
         for (GSList *iterator  = gtk_file_names ; iterator; iterator = iterator->next)
             filenames << QString::fromUtf8((const char*)iterator->data);
@@ -860,12 +939,19 @@ QStringList QGtk::openFilenames(QWidget *parent, const QString &caption, const Q
 QString QGtk::saveFilename(QWidget *parent, const QString &caption, const QString &dir, const QString &filter,
                            QString *selectedFilter, QFileDialog::Options options)
 {
+    qDebug() << "DIR" << dir
+             << "filter" << filter
+             << "selected filter" << selectedFilter;
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_SAVE);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_SAVE,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
                                                              NULL);
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, filter, selectedFilter, options, true);
 
     QWidget modal_widget;
@@ -874,7 +960,11 @@ QString QGtk::saveFilename(QWidget *parent, const QString &caption, const QStrin
     QApplicationPrivate::enterModal(&modal_widget);
 
     QString filename;
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         char *gtk_filename = QGtk::gtk_file_chooser_get_filename ((GtkFileChooser*)gtkFileChooser);
         filename = QString::fromUtf8(gtk_filename);
         g_free (gtk_filename);
diff --git a/src/gui/styles/gtksymbols_p.h b/src/gui/styles/gtksymbols_p.h
index b0195d2..4dd1c78 100644
--- a/src/gui/styles/gtksymbols_p.h
+++ b/src/gui/styles/gtksymbols_p.h
@@ -108,6 +108,9 @@ typedef GtkWidget* (*Ptr_gtk_scrolled_window_new)(GtkAdjustment*, GtkAdjustment*
 typedef gchar* (*Ptr_gtk_check_version)(guint, guint, guint);
 typedef GtkToolItem* (*Ptr_gtk_separator_tool_item_new) (void);
 typedef GtkWidget* (*Ptr_gtk_entry_new)(void);
+#ifdef Q_OS_FREMANTLE
+typedef GtkWidget* (*Ptr_gtk_text_view_new)(void);
+#endif
 typedef GtkWidget* (*Ptr_gtk_tree_view_new)(void);
 typedef GtkTreeViewColumn* (*Ptr_gtk_tree_view_get_column)(GtkTreeView *, gint);
 typedef GtkWidget* (*Ptr_gtk_combo_box_new)(void);
@@ -156,6 +159,7 @@ typedef gint (*Ptr_pango_font_description_get_size) (const PangoFontDescription
 typedef PangoWeight (*Ptr_pango_font_description_get_weight) (const PangoFontDescription *);
 typedef const char* (*Ptr_pango_font_description_get_family) (const PangoFontDescription *);
 typedef PangoStyle (*Ptr_pango_font_description_get_style) (const PangoFontDescription *desc);
+
 typedef gboolean (*Ptr_gtk_file_chooser_set_current_folder)(GtkFileChooser *, const gchar *);
 typedef GtkFileFilter* (*Ptr_gtk_file_filter_new)(void);
 typedef void (*Ptr_gtk_file_filter_set_name)(GtkFileFilter *, const gchar *);
@@ -173,6 +177,11 @@ typedef void (*Ptr_gtk_file_chooser_set_current_name) (GtkFileChooser *, const g
 typedef gboolean (*Ptr_gtk_file_chooser_set_filename) (GtkFileChooser *chooser, const gchar *name);
 typedef gint (*Ptr_gtk_dialog_run) (GtkDialog*);
 
+#ifdef Q_WS_HILDON
+typedef GtkWidget* (*Ptr_hildon_file_chooser_dialog_new)(GtkWindow *parent,
+                                                         GtkFileChooserAction action);
+
+#endif
 typedef guchar* (*Ptr_gdk_pixbuf_get_pixels) (const GdkPixbuf *pixbuf);
 typedef int (*Ptr_gdk_pixbuf_get_width) (const GdkPixbuf *pixbuf);
 typedef void (*Ptr_gdk_color_free) (const GdkColor *);
@@ -193,6 +202,11 @@ typedef void (*Ptr_gdk_x11_window_set_user_time) (GdkWindow *window, guint32);
 typedef XID  (*Ptr_gdk_x11_drawable_get_xid) (GdkDrawable *);
 typedef Display* (*Ptr_gdk_x11_drawable_get_xdisplay) ( GdkDrawable *);
 
+#ifdef Q_WS_HILDON
+typedef GtkWidget* (*Ptr_hildon_number_editor_new) (int,int);
+typedef void (*Ptr_gtk_widget_set_name) (GtkWidget *, const gchar *);
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QGtk
@@ -241,6 +255,9 @@ public:
     static Ptr_gtk_frame_new gtk_frame_new;
     static Ptr_gtk_statusbar_new gtk_statusbar_new;
     static Ptr_gtk_entry_new gtk_entry_new;
+#ifdef Q_OS_FREMANTLE
+    static Ptr_gtk_text_view_new gtk_text_view_new;
+#endif
     static Ptr_gtk_hscale_new gtk_hscale_new;
     static Ptr_gtk_vscale_new gtk_vscale_new;
     static Ptr_gtk_hscrollbar_new gtk_hscrollbar_new;
@@ -309,6 +326,9 @@ public:
     static Ptr_gtk_file_chooser_set_current_name gtk_file_chooser_set_current_name;
     static Ptr_gtk_dialog_run gtk_dialog_run;
     static Ptr_gtk_file_chooser_set_filename gtk_file_chooser_set_filename;
+#ifdef Q_WS_HILDON
+    static Ptr_hildon_file_chooser_dialog_new hildon_file_chooser_dialog_new;
+#endif
 
     static Ptr_gdk_pixbuf_get_pixels gdk_pixbuf_get_pixels;
     static Ptr_gdk_pixbuf_get_width gdk_pixbuf_get_width;
@@ -327,6 +347,12 @@ public:
 
     static Ptr_gconf_client_get_default gconf_client_get_default;
     static Ptr_gconf_client_get_string gconf_client_get_string;
+
+#ifdef Q_WS_HILDON
+    static Ptr_hildon_number_editor_new hildon_number_editor_new;
+    static Ptr_gtk_widget_set_name gtk_widget_set_name;
+#endif
+
 };
 
 // Helper to ensure that we have polished all our gtk widgets
diff --git a/src/gui/styles/qgtkstyle.cpp b/src/gui/styles/qgtkstyle.cpp
index 218f651..6c05edb 100644
--- a/src/gui/styles/qgtkstyle.cpp
+++ b/src/gui/styles/qgtkstyle.cpp
@@ -263,8 +263,11 @@ QPalette QGtkStyle::standardPalette() const
     if (QGtk::isThemeAvailable()) {
         GtkStyle *style = QGtk::gtkStyle();
         GtkWidget *gtkButton = QGtk::gtkWidget(QLS("GtkButton"));
+#ifndef Q_OS_FREMANTLE
         GtkWidget *gtkEntry = QGtk::gtkWidget(QLS("GtkEntry"));
-
+#else
+        GtkWidget *gtkEntry = QGtk::gtkWidget(QLS("GtkTextView"));
+#endif
         GdkColor gdkBg, gdkBase, gdkText, gdkForeground, gdkSbg, gdkSfg;
         QColor bg, base, text, fg, highlight, highlightText;
         gdkBg = style->bg[GTK_STATE_NORMAL];
@@ -272,6 +275,8 @@ QPalette QGtkStyle::standardPalette() const
 
         // Our base and selected color is primarily used for text
         // so we assume a gtkEntry will have the most correct value
+        //NOTE: Reverse color in fremantle themes are set only for
+        //      GtkTextView widgets. GtkEntry returns a dark base color.
         gdkBase = gtkEntry->style->base[GTK_STATE_NORMAL];
         gdkText = gtkEntry->style->text[GTK_STATE_NORMAL];
         gdkSbg = gtkEntry->style->base[GTK_STATE_SELECTED];
@@ -1357,6 +1362,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     // Required for inner blue highlight with clearlooks
                     if (focus)
                         GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+#ifndef Q_OS_FREMANTLE
+                    // Required for inner blue highlight with clearlooks
+                    if (focus)
+                        GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
 
                     if (widget && widget->testAttribute(Qt::WA_SetPalette) &&
                         resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
@@ -1366,7 +1375,18 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                                                 option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
                                                 GTK_SHADOW_NONE, style, entryPath + QString::number(focus));
                     }
-
+#else
+                    //This code fill a rectangle in the middle of the combobox.
+                    //Using custom palette will draw a colored rectangle in the middle of the combobox.
+                    //The borders will be painted by paintShadow
+                    if (!comboBox->editable) {
+                        GdkColor gdkBg;
+                        QColor bg;
+                        gdkBg = gtkCombo->style->base[GTK_STATE_NORMAL];
+                        bg = QColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8);
+                        p->fillRect(contentRect, bg);
+                    }
+#endif 
                     gtkCachedPainter.paintShadow(gtkEntry, comboBox->editable ? "entry" : "frame", frameRect, frameState,
                                            GTK_SHADOW_IN, gtkEntry->style, entryPath +
                                            QString::number(focus) + QString::number(comboBox->editable) +
@@ -1911,8 +1931,13 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
                                    -focusFrameMargin, -outerSize - focusFrameMargin);
 
+#ifdef Q_OS_FREMANTLE
+                gtkPainter.paintBox( scaleWidget, "trough-upper", grooveRect, state,
+                                     GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+#else
                 gtkPainter.paintBox( scaleWidget, "trough", grooveRect, state,
                                      GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+#endif
 
                 gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
                 if (!QGtk::gtk_check_version(2, 10, 0))
@@ -2699,9 +2724,16 @@ void QGtkStyle::drawControl(ControlElement element,
                                    pixelMetric(PM_ButtonShiftVertical, option, widget));
 
                 QFontMetrics fm(menuitem->font);
+#ifdef Q_WS_HILDON
+                int arrow_size = fm.ascent() + fm.descent();
+                gfloat arrow_scaling;
+                QGtk::gtk_widget_style_get(gtkMenu, "maemo-arrow-scaling", &arrow_scaling, NULL);
+                if (arrow_scaling == 0.0)
+                    arrow_scaling = 1.0;
+#else
                 int arrow_size = fm.ascent() + fm.descent() - 2 * gtkMenuItem->style->ythickness;
                 gfloat arrow_scaling = 0.8;
-
+#endif
                 // "arrow-scaling" is actually hardcoded and fails on hardy (see gtk+-2.12/gtkmenuitem.c)
                 // though the current documentation states otherwise
                 int horizontal_padding;
diff --git a/src/gui/styles/qhildonstyle.cpp b/src/gui/styles/qhildonstyle.cpp
new file mode 100644
index 0000000..ce50316
--- /dev/null
+++ b/src/gui/styles/qhildonstyle.cpp
@@ -0,0 +1,424 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the unofficial Maemo Qt Toolkit.
+**
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the either Technology Preview License Agreement or the
+** Beta Release License Agreement.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the file LICENSE.GPL included in
+** the packaging of this file.  Please review the following information
+** to ensure GNU General Public Licensing requirements will be met:
+** http://www.fsf.org/licensing/licenses/info/GPLv2.html and
+** http://www.gnu.org/copyleft/gpl.html.  In addition, as a special
+** exception, Nokia gives you certain additional rights. These rights
+** are described in the Nokia Qt GPL Exception version 1.3, included in
+** the file GPL_EXCEPTION.txt in this package.
+**
+** Qt for Windows(R) Licensees
+** As a special exception, Nokia, as the sole copyright holder for Qt
+** Designer, grants users of the Qt/Eclipse Integration plug-in the
+** right for the Qt/Eclipse Integration to link to functionality
+** provided by Qt Designer and its related libraries.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+**
+****************************************************************************/
+
+#include "qhildonstyle.h"
+
+#include <QtGui/QStyleOption>
+#include <QDebug>
+
+#include "qgtkpainter_p.h"
+
+#if !defined(QT_NO_STYLE_HILDON) && defined(Q_WS_HILDON)
+
+QT_BEGIN_NAMESPACE
+
+//Belongs to QGTKStyle
+static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
+{
+    const int maxFactor = 100;
+    QColor tmp = colorA;
+    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
+    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
+    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
+    return tmp;
+}
+
+/*!
+    \class QHildonStyle
+    \brief The QHildonStyle class provides a widget style rendered by GTK+
+
+    The QHildonStyle style provides a look and feel that integrates well
+    into Hildon-based desktop environments.
+
+    It's based on QGTKStyle.
+
+    Note: The style requires GTK+ version 2.10 or later.
+          The Qt3-based "Qt" GTK+ theme engine will not work with QGtkStyle.
+*/
+
+/*!
+    Constructs a QGtkStyle object.
+*/
+QHildonStyle::QHildonStyle()
+{
+}
+
+/*!
+    Destroys the QHildonStyle object.
+*/
+QHildonStyle::~QHildonStyle()
+{
+}
+
+QPalette QHildonStyle::standardPalette() const
+{
+    return QGtkStyle::standardPalette();
+}
+
+void QHildonStyle::polish(QPalette &palette)
+{
+    QGtkStyle::polish(palette);
+}
+
+void QHildonStyle::polish(QApplication *app)
+{
+    QGtkStyle::polish(app);
+}
+
+void QHildonStyle::unpolish(QApplication *app)
+{
+    QGtkStyle::unpolish(app);
+}
+
+void QHildonStyle::polish(QWidget *widget)
+{
+    QGtkStyle::polish(widget);
+}
+
+void QHildonStyle::unpolish(QWidget *widget)
+{
+    QGtkStyle::unpolish(widget);
+}
+
+int QHildonStyle::pixelMetric(PixelMetric metric,
+                           const QStyleOption *option,
+                           const QWidget *widget) const
+{
+   if (!QGtk::isThemeAvailable())
+        return QCleanlooksStyle::pixelMetric(metric, option, widget);
+   
+   switch (metric) {
+    //coordinate of the Application Context Menu upper left corner.
+    case PM_MenuOffsetHorizontal:
+    {
+        GtkWidget *gtkMenu = QGtk::gtkWidget("menu_force_with_corners");
+        gint horizontal_offset;
+        QGtk::gtk_widget_style_get(gtkMenu, "horizontal-offset", &horizontal_offset, NULL);
+        return horizontal_offset;
+    }
+    case PM_MenuOffsetVertical:
+    {
+        GtkWidget *gtkMenu = QGtk::gtkWidget("menu_force_with_corners");
+        gint vertical_offset;
+        QGtk::gtk_widget_style_get(gtkMenu, "vertical-offset", &vertical_offset, NULL);
+        return vertical_offset;
+    }
+    default:
+        return  QGtkStyle::pixelMetric(metric, option, widget);
+    }
+}
+
+int QHildonStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
+                         QStyleHintReturn *returnData = 0) const
+{
+    if (!QGtk::isThemeAvailable())
+        return QCleanlooksStyle::styleHint(hint, option, widget, returnData);
+
+    switch (hint) {
+    case SH_Menu_Scrollable:
+        return int(true);
+    case SH_DialogButtonBox_ButtonsHaveIcons:
+    case SH_ScrollBar_ContextMenu:
+        return int(false);
+    default:
+        return QGtkStyle::styleHint(hint, option, widget, returnData);
+    }
+}
+
+void QHildonStyle::drawPrimitive(PrimitiveElement element,
+                              const QStyleOption *option,
+                              QPainter *painter,
+                              const QWidget *widget) const
+{
+    if (!QGtk::isThemeAvailable()) {
+        QCleanlooksStyle::drawPrimitive(element, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = QGtk::gtkStyle();
+    QGtkPainter gtkPainter(painter);
+
+    switch (element) {
+    case PE_FrameLineEdit: {
+        GtkWidget *gtkEntry = QGtk::gtkWidget(QLS("GtkEntry"));
+
+        if (option->state & State_HasFocus)
+            GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+        else
+            GTK_WIDGET_UNSET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+
+        gboolean interior_focus;
+        gint focus_line_width;
+        QRect rect = option->rect;
+        QGtk::gtk_widget_style_get(gtkEntry,
+                               "interior-focus", &interior_focus,
+                               "focus-line-width", &focus_line_width, NULL);
+        
+        //Paint the LineEdits borders.
+        gtkPainter.paintFlatBox(gtkEntry, "entry_bg", rect,
+                                  option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, gtkEntry->style);
+
+        if (!interior_focus && option->state & State_HasFocus)
+            rect.adjust(focus_line_width, focus_line_width, -focus_line_width, -focus_line_width);
+
+        gtkPainter.paintShadow(gtkEntry, "entry", rect, option->state & State_Enabled ? 
+                               GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, 
+                               GTK_SHADOW_IN, gtkEntry->style,
+                               option->state & State_HasFocus ? QLS("focus") : QString());
+
+        if (!interior_focus && option->state & State_HasFocus)
+            gtkPainter.paintShadow(gtkEntry, "entry", option->rect, option->state & State_Enabled ? 
+                                   GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                                   GTK_SHADOW_IN, gtkEntry->style, QLS("GtkEntryShadowIn"));
+
+    }
+    break;
+
+    case PE_PanelLineEdit: {
+        QCleanlooksStyle::drawPrimitive(element, option, painter, widget);
+    }
+    break;
+
+    default:
+        QGtkStyle::drawPrimitive(element, option, painter, widget);
+    }
+}
+
+void QHildonStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                                   QPainter *painter, const QWidget *widget) const
+{
+    if (!QGtk::isThemeAvailable()) {
+        QCleanlooksStyle::drawComplexControl(control, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = QGtk::gtkStyle();
+    QGtkPainter gtkPainter(painter);
+    QColor button = option->palette.button().color();
+    QColor dark;
+    QColor grooveColor;
+    QColor darkOutline;
+    dark.setHsv(button.hue(),
+                qMin(255, (int)(button.saturation()*1.9)),
+                qMin(255, (int)(button.value()*0.7)));
+    grooveColor.setHsv(button.hue(),
+                       qMin(255, (int)(button.saturation()*2.6)),
+                       qMin(255, (int)(button.value()*0.9)));
+    darkOutline.setHsv(button.hue(),
+                       qMin(255, (int)(button.saturation()*3.0)),
+                       qMin(255, (int)(button.value()*0.6)));
+
+    QColor alphaCornerColor;
+
+    if (widget)
+        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), darkOutline);
+    else
+        alphaCornerColor = mergedColors(option->palette.background().color(), darkOutline);
+
+    QPalette palette = option->palette;
+
+    switch (control) {
+    #ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            GtkWidget *gtkSpinButton = QGtk::gtkWidget(QLS("GtkSpinButton"));
+            bool isEnabled = (spinBox->state & State_Enabled);
+            bool hover = isEnabled && (spinBox->state & State_MouseOver);
+            bool sunken = (spinBox->state & State_Sunken);
+            bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+            bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+            bool reverse = (spinBox->direction == Qt::RightToLeft);
+
+            GtkWidget *gtkEntry = QGtk::gtkWidget("HildonNumberEditor.GtkEntry");
+            GtkWidget *gtkMinusButton = QGtk::gtkWidget("HildonNumberEditor.ne-minus-button");
+            GtkWidget *gtkPlusButton = QGtk::gtkWidget("HildonNumberEditor.ne-plus-button");
+            int xt = gtkEntry->style->xthickness;
+            int yt = gtkEntry->style->ythickness;
+            QRect plusRect = subControlRect(CC_SpinBox, option, SC_SpinBoxUp, widget);
+            QRect minusRect = subControlRect(CC_SpinBox, option, SC_SpinBoxDown, widget);
+            QRect entryRect = subControlRect(CC_SpinBox, option, SC_SpinBoxEditField, widget).adjusted(-xt, -yt, xt, yt);
+
+            /* TODO: Do not replicate code from PE_FrameLineEdit */
+            gboolean interior_focus;
+            gint focus_line_width;
+            QRect rect = entryRect;
+            QGtk::gtk_widget_style_get(gtkEntry,
+                                "interior-focus", &interior_focus,
+                                "focus-line-width", &focus_line_width,
+                                NULL);
+
+            if (option->state & State_HasFocus)
+                GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+            else
+                GTK_WIDGET_UNSET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+
+#if defined Q_WS_HILDON && !defined Q_OS_FREMANTLE
+            gtkPainter.paintFlatBox(gtkEntry, "entry_bg", entryRect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, gtkEntry->style);
+
+            if (!interior_focus && option->state & State_HasFocus)
+                rect.adjust(focus_line_width, focus_line_width, -focus_line_width, -focus_line_width);
+
+            gtkPainter.paintShadow(gtkEntry, "entry", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_IN, gtkEntry->style);
+
+            if (!interior_focus && option->state & State_HasFocus)
+                gtkPainter.paintShadow(gtkEntry, "entry", option->rect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, gtkEntry->style);
+#endif
+            /* Plus button */
+            GtkStateType state = (upIsActive && sunken) ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;
+            if (!isEnabled)
+                state = GTK_STATE_INSENSITIVE;
+
+            gtkPainter.paintBox(gtkPlusButton, "button",  plusRect, state, GTK_SHADOW_OUT, gtkPlusButton->style);
+
+            /* Minus button */
+            state = (downIsActive && sunken) ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;
+            if (!isEnabled)
+                state = GTK_STATE_INSENSITIVE;
+            gtkPainter.paintBox(gtkMinusButton, "button",  minusRect, state, GTK_SHADOW_OUT, gtkMinusButton->style);
+        }
+        break;
+#endif // QT_NO_SPINBOX
+
+    default:
+        QGtkStyle::drawComplexControl(control, option, painter, widget);
+    }
+}
+
+void QHildonStyle::drawControl(ControlElement element,
+                            const QStyleOption *option,
+                            QPainter *painter,
+                            const QWidget *widget) const
+{
+    QGtkStyle::drawControl(element, option, painter, widget);
+}
+
+QRect QHildonStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                                SubControl subControl, const QWidget *widget) const
+{
+    QRect rect = QWindowsStyle::subControlRect(control, option, subControl, widget);
+    if (!QGtk::isThemeAvailable())
+        return QCleanlooksStyle::subControlRect(control, option, subControl, widget);
+
+    switch (control) {
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            GtkWidget *gtkEntry = QGtk::gtkWidget("HildonNumberEditor.GtkEntry");
+            int buttonSize = 30;
+            int padding = 2;
+            int h = qMax(spinbox->rect.height(), buttonSize);
+            int w = qMax(spinbox->rect.width(), (buttonSize + padding) * 2);
+            int x = spinbox->rect.x();
+            int y = spinbox->rect.y();
+            int buttonY = y + (h - buttonSize) / 2;
+            int xt = gtkEntry->style->xthickness;
+            int yt = gtkEntry->style->ythickness;
+
+            switch (subControl) {
+            case SC_SpinBoxUp:
+                rect = QRect(x + w - buttonSize, buttonY, buttonSize, buttonSize);
+                break;
+            case SC_SpinBoxDown:
+                rect = QRect(x, buttonY, buttonSize, buttonSize);
+                break;
+            case SC_SpinBoxEditField:
+                rect = QRect(x + buttonSize + padding + xt, y + yt, w - 2 * (buttonSize + padding + xt), h - 2 * yt);
+                break;
+            case SC_SpinBoxFrame:
+                rect = spinbox->rect;
+            default:
+                break;
+            }
+            rect = visualRect(spinbox->direction, spinbox->rect, rect);
+        }
+        break;
+#endif // Qt_NO_SPINBOX
+    default:
+        return  QGtkStyle::subControlRect(control, option, subControl, widget);
+    }
+    return rect;
+}
+
+QSize QHildonStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
+                                  const QSize &size, const QWidget *widget) const
+{
+   return  QGtkStyle::sizeFromContents(type, option, size, widget);
+}
+
+QPixmap QHildonStyle::standardPixmap(StandardPixmap sp, const QStyleOption *option,
+                                  const QWidget *widget) const
+{
+   return  QGtkStyle::standardPixmap(sp, option, widget);
+}
+
+QRect QHildonStyle::subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const
+{
+    return  QGtkStyle::subElementRect(element, option, widget);
+}
+
+QRect QHildonStyle::itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const
+{
+    return QGtkStyle::itemPixmapRect(r, flags, pixmap);
+}
+
+void QHildonStyle::drawItemPixmap(QPainter *painter, const QRect &rect,
+                            int alignment, const QPixmap &pixmap) const
+{
+    QGtkStyle::drawItemPixmap(painter, rect, alignment, pixmap);
+}
+
+QStyle::SubControl QHildonStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                              const QPoint &pt, const QWidget *w) const
+{
+    return QGtkStyle::hitTestComplexControl(cc, opt, pt, w);
+}
+
+QPixmap QHildonStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                        const QStyleOption *opt) const
+{
+    return QGtkStyle::generatedIconPixmap(iconMode, pixmap, opt);
+}
+
+void QHildonStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    QGtkStyle::drawItemText(painter, rect, alignment, pal, enabled, text, textRole);
+}
+
+QT_END_NAMESPACE
+
+#endif
+
diff --git a/src/gui/styles/qhildonstyle.h b/src/gui/styles/qhildonstyle.h
new file mode 100644
index 0000000..cf88d1d
--- /dev/null
+++ b/src/gui/styles/qhildonstyle.h
@@ -0,0 +1,113 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the either Technology Preview License Agreement or the
+** Beta Release License Agreement.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the file LICENSE.GPL included in
+** the packaging of this file.  Please review the following information
+** to ensure GNU General Public Licensing requirements will be met:
+** http://www.fsf.org/licensing/licenses/info/GPLv2.html and
+** http://www.gnu.org/copyleft/gpl.html.  In addition, as a special
+** exception, Nokia gives you certain additional rights. These rights
+** are described in the Nokia Qt GPL Exception version 1.3, included in
+** the file GPL_EXCEPTION.txt in this package.
+**
+** Qt for Windows(R) Licensees
+** As a special exception, Nokia, as the sole copyright holder for Qt
+** Designer, grants users of the Qt/Eclipse Integration plug-in the
+** right for the Qt/Eclipse Integration to link to functionality
+** provided by Qt Designer and its related libraries.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+**
+****************************************************************************/
+
+#ifndef QHILDONSTYLE_H
+#define QHILDONSTYLE_H
+
+#include <QtGui/QGtkStyle>
+#include <QtGui/QPalette>
+#include <QtGui/QFont>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+#if !defined(QT_NO_STYLE_HILDON)
+
+class QPainterPath;
+class QHildonStylePrivate;
+
+class Q_GUI_EXPORT QHildonStyle : public QGtkStyle
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QHildonStyle)
+
+public:
+    QHildonStyle();
+    ~QHildonStyle();
+
+    QPalette standardPalette() const;
+
+    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
+                       QPainter *painter, const QWidget *widget) const;
+    void drawControl(ControlElement control, const QStyleOption *option,
+                     QPainter *painter, const QWidget *widget) const;
+    void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                            QPainter *painter, const QWidget *widget) const;
+    void drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
+                        const QPixmap &pixmap) const;
+    void drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                      bool enabled, const QString& text, QPalette::ColorRole textRole) const;
+
+    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
+                    const QWidget *widget = 0) const;
+    int styleHint(StyleHint hint, const QStyleOption *option,
+                  const QWidget *widget, QStyleHintReturn *returnData) const;
+
+    QStyle::SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                              const QPoint &pt, const QWidget *w) const;
+
+    QRect subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                         SubControl subControl, const QWidget *widget) const;
+    QRect subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *w) const;
+    QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;
+
+
+    QSize sizeFromContents(ContentsType type, const QStyleOption *option,
+                           const QSize &size, const QWidget *widget) const;
+    QPixmap standardPixmap(StandardPixmap sp, const QStyleOption *option,
+                           const QWidget *widget) const;
+    QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                const QStyleOption *opt) const;
+
+    void polish(QWidget *widget);
+    void polish(QApplication *app);
+    void polish(QPalette &palette);
+
+    void unpolish(QWidget *widget);
+    void unpolish(QApplication *app);
+};
+
+
+#endif //!defined(QT_NO_STYLE_QGTK)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif //QGTKSTYLE_H
diff --git a/src/gui/styles/qstyle.h b/src/gui/styles/qstyle.h
index 133ad37..3e6255d 100644
--- a/src/gui/styles/qstyle.h
+++ b/src/gui/styles/qstyle.h
@@ -511,6 +511,10 @@ public:
         PM_MenuPanelWidth,
         PM_MenuTearoffHeight,
         PM_MenuDesktopFrameWidth,
+#ifdef Q_WS_HILDON
+        PM_MenuOffsetHorizontal,        // X offset beetween upper left corners of the hildon app menu and its app
+        PM_MenuOffsetVertical,          //
+#endif
 
         PM_MenuBarPanelWidth,
         PM_MenuBarItemSpacing,
diff --git a/src/gui/styles/qstylefactory.cpp b/src/gui/styles/qstylefactory.cpp
index 1db7f8e..111dca1 100644
--- a/src/gui/styles/qstylefactory.cpp
+++ b/src/gui/styles/qstylefactory.cpp
@@ -57,6 +57,9 @@
 #ifndef QT_NO_STYLE_GTK
 #include "qgtkstyle.h"
 #endif
+#ifndef QT_NO_STYLE_HILDON
+#include "qhildonstyle.h"
+#endif
 #ifndef QT_NO_STYLE_WINDOWSXP
 #include "qwindowsxpstyle.h"
 #endif
@@ -169,6 +172,11 @@ QStyle *QStyleFactory::create(const QString& key)
         ret = new QGtkStyle;
     else
 #endif
+#ifndef QT_NO_STYLE_GTK
+    if (style == QLatin1String("hildon"))
+        ret = new QHildonStyle;
+    else
+#endif
 #ifndef QT_NO_STYLE_MAC
     if (style.left(9) == QLatin1String("macintosh")) {
         ret = new QMacStyle;
@@ -241,6 +249,10 @@ QStringList QStyleFactory::keys()
     if (!list.contains(QLatin1String("GTK+")))
         list << QLatin1String("GTK+");
 #endif
+#ifndef QT_NO_STYLE_HILDON
+    if (!list.contains(QLatin1String("Hildon")))
+        list << QLatin1String("Hildon");
+#endif
 #ifndef QT_NO_STYLE_CLEANLOOKS
     if (!list.contains(QLatin1String("Cleanlooks")))
         list << QLatin1String("Cleanlooks");
diff --git a/src/gui/styles/styles.pri b/src/gui/styles/styles.pri
index 376f834..1e33094 100644
--- a/src/gui/styles/styles.pri
+++ b/src/gui/styles/styles.pri
@@ -32,7 +32,7 @@ x11|embedded|!macx-*:styles -= mac
 x11{
     QMAKE_CXXFLAGS += $$QT_CFLAGS_QGTKSTYLE
     LIBS += $$QT_LIBS_QGTKSTYLE
-    styles += gtk
+    styles += gtk hildon
 }
 
 contains( styles, mac ) {
@@ -115,6 +115,17 @@ contains( styles, gtk ) {
 	DEFINES += QT_NO_STYLE_GTK
 }
 
+contains( styles, hildon ) {
+        HEADERS += styles/qhildonstyle.h
+        SOURCES += styles/qhildonstyle.cpp
+        !contains( styles, gtk ) {
+                styles += gtk
+                DEFINES+= QT_STYLE_GTK
+        }
+} else {
+        DEFINES += QT_NO_STYLE_GTK
+}
+
 contains( styles, cleanlooks ) {
         HEADERS += styles/qcleanlooksstyle.h
         HEADERS += styles/qcleanlooksstyle_p.h
diff --git a/src/gui/text/qtextcontrol.cpp b/src/gui/text/qtextcontrol.cpp
index 9a3fc1f..0b5ae3b 100644
--- a/src/gui/text/qtextcontrol.cpp
+++ b/src/gui/text/qtextcontrol.cpp
@@ -915,6 +915,10 @@ void QTextControl::processEvent(QEvent *e, const QMatrix &matrix, QWidget *conte
         case QEvent::MouseButtonRelease: {
             QMouseEvent *ev = static_cast<QMouseEvent *>(e);
             d->mouseReleaseEvent(ev->button(), matrix.map(ev->pos()));
+#ifdef Q_OS_FREMANTLE
+            //MouseButtonRelease activate the Hildon Input Method
+            ev->ignore();
+#endif
             break; }
         case QEvent::MouseButtonDblClick: {
             QMouseEvent *ev = static_cast<QMouseEvent *>(e);
@@ -1817,6 +1821,12 @@ void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
         e->ignore();
         return;
     }
+#ifdef Q_WS_HILDON
+    //This code permits to set the cursor position via QInputMethodEvent
+    //In Hildon we need to do it when the user select the text from right to left
+    //with the fingers and so the fullscreen on-screen keyboard plugins is shown
+    int textCursorPosition= cursor.position();
+#endif
     cursor.beginEditBlock();
 
     cursor.removeSelectedText();
@@ -1827,7 +1837,14 @@ void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
         c.setPosition(c.position() + e->replacementStart());
         c.setPosition(c.position() + e->replacementLength(), QTextCursor::KeepAnchor);
         c.insertText(e->commitString());
+#ifndef Q_WS_HILDON
+    }
+#else
+         textCursorPosition= c.position();
+    }else if (e->replacementStart()){
+        textCursorPosition += e->replacementStart();
     }
+#endif   
 
     QTextBlock block = cursor.block();
     QTextLayout *layout = block.layout();
@@ -1853,6 +1870,9 @@ void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
     }
     layout->setAdditionalFormats(overrides);
     cursor.endEditBlock();
+#ifdef Q_WS_HILDON
+    cursor.setPosition(textCursorPosition);
+#endif
 }
 
 QVariant QTextControl::inputMethodQuery(Qt::InputMethodQuery property) const
@@ -1870,6 +1890,12 @@ QVariant QTextControl::inputMethodQuery(Qt::InputMethodQuery property) const
         return QVariant(block.text());
     case Qt::ImCurrentSelection:
         return QVariant(d->cursor.selectedText());
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:{
+        int mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_AUTOCAP | HILDON_GTK_INPUT_MODE_DICTIONARY | HILDON_GTK_INPUT_MODE_MULTILINE;
+        return QVariant(mode);
+    }
+#endif
     default:
         return QVariant();
     }
diff --git a/src/gui/util/qdesktopservices_x11.cpp b/src/gui/util/qdesktopservices_x11.cpp
index 1a97a41..a83c117 100644
--- a/src/gui/util/qdesktopservices_x11.cpp
+++ b/src/gui/util/qdesktopservices_x11.cpp
@@ -63,10 +63,7 @@ static bool openDocument(const QUrl &url)
 {
     if (!url.isValid())
         return false;
-
-    if (launch(url, QLatin1String("xdg-open")))
-        return true;
-
+    
     if (X11->desktopEnvironment == DE_GNOME && launch(url, QLatin1String("gnome-open"))) {
         return true;
     } else {
@@ -74,6 +71,10 @@ static bool openDocument(const QUrl &url)
             return true;
     }
 
+#ifndef Q_WS_HILDON
+    if (launch(url, QLatin1String("xdg-open")))
+        return true;
+
     if (launch(url, QLatin1String("firefox")))
         return true;
     if (launch(url, QLatin1String("mozilla")))
@@ -82,7 +83,10 @@ static bool openDocument(const QUrl &url)
         return true;
     if (launch(url, QLatin1String("opera")))
         return true;
-
+#else
+    if (launch(url, QLatin1String("browser --url")))
+        return true;
+#endif
     return false;
 }
 
@@ -93,13 +97,15 @@ static bool launchWebBrowser(const QUrl &url)
     if (url.scheme() == QLatin1String("mailto"))
         return openDocument(url);
 
-    if (launch(url, QLatin1String("xdg-open")))
-        return true;
     if (launch(url, QString::fromLocal8Bit(getenv("DEFAULT_BROWSER"))))
         return true;
     if (launch(url, QString::fromLocal8Bit(getenv("BROWSER"))))
         return true;
 
+#ifndef Q_WS_HILDON
+    if (launch(url, QLatin1String("xdg-open")))
+        return true;
+
     if (X11->desktopEnvironment == DE_GNOME && launch(url, QLatin1String("gnome-open"))) {
         return true;
     } else {
@@ -115,6 +121,10 @@ static bool launchWebBrowser(const QUrl &url)
         return true;
     if (launch(url, QLatin1String("opera")))
         return true;
+#else
+    if (launch(url, QLatin1String("browser --url")))
+        return true;
+#endif
     return false;
 }
 
@@ -194,13 +204,25 @@ QString QDesktopServices::storageLocation(StandardLocation type)
     QString path;
     switch (type) {
     case DesktopLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs");
+#else
         path = QDir::homePath() + QLatin1String("/Desktop");
+#endif
         break;
     case DocumentsLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.documents");
+#else
         path = QDir::homePath() + QLatin1String("/Documents");
+#endif
        break;
     case PicturesLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.images");
+#else
         path = QDir::homePath() + QLatin1String("/Pictures");
+#endif
         break;
 
     case FontsLocation:
@@ -208,11 +230,19 @@ QString QDesktopServices::storageLocation(StandardLocation type)
         break;
 
     case MusicLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.sounds");
+#else
         path = QDir::homePath() + QLatin1String("/Music");
+#endif
         break;
 
     case MoviesLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.videos");
+#else
         path = QDir::homePath() + QLatin1String("/Videos");
+#endif
         break;
 
     case ApplicationsLocation:
diff --git a/src/gui/widgets/qabstractscrollarea.cpp b/src/gui/widgets/qabstractscrollarea.cpp
index ead8285..cf7e955 100644
--- a/src/gui/widgets/qabstractscrollarea.cpp
+++ b/src/gui/widgets/qabstractscrollarea.cpp
@@ -60,6 +60,19 @@
 #include <private/qt_cocoa_helpers_mac_p.h>
 #endif
 
+#ifdef Q_WS_HILDON
+#include <QGraphicsView>
+#include <QPlainTextEdit>
+#include <QTextEdit>
+#include <QScrollArea>
+#include <QListView>
+#include "private/qlistview_p.h"
+#include <QTableView>
+#include <QTreeView>
+#include "private/qtreeview_p.h"
+#include <QHeaderView>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 /*!
@@ -288,6 +301,12 @@ void QAbstractScrollAreaPrivate::init()
     q->setFrameStyle(QFrame::StyledPanel | QFrame::Sunken);
     q->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
     layoutChildren();
+#ifdef Q_WS_HILDON
+//	qDebug() << "Setting fingerscroll property";
+	fingerScroller = 0;
+	q->setProperty("FingerScrollable", true); // sets fingerscroller
+	q->setProperty("FingerScrollBars", true); // sets fingerscrollbars
+#endif
 }
 
 void QAbstractScrollAreaPrivate::layoutChildren()
@@ -462,6 +481,117 @@ void QAbstractScrollAreaPrivate::layoutChildren()
 // ### Fix for 4.4, talk to Bjoern E or Girish.
 void QAbstractScrollAreaPrivate::scrollBarPolicyChanged(Qt::Orientation, Qt::ScrollBarPolicy) {}
 
+#ifdef Q_WS_HILDON
+/*!
+    This enables or disables finger scrolling; it should only be
+    called from within the DynamicPropertyChangeEvent handler.
+
+    These methods are only available on platforms supporting
+    Fingerscrolling and can be detected by looking for the
+    "FingerScrollable" property.
+*/
+
+void QAbstractScrollAreaPrivate::setFingerScrollable(bool setFingerScroller)
+{
+    Q_Q(QAbstractScrollArea);
+
+	if (setFingerScroller) {
+		if (! fingerScroller) {
+			fingerScroller = new QAbstractScrollAreaPrivateScroller(viewport, q, this);
+		}
+	} else if (fingerScroller) {
+		delete fingerScroller;
+		fingerScroller = 0;
+	}
+}
+
+/*!
+    This enables or disables finger scroll bars (narrow bars that
+    mainly only show position); it should only be called from within
+    the DynamicPropertyChangeEvent handler.
+
+    These methods are only available on platforms supporting
+    Fingerscrolling and can be detected by looking for the
+    "FingerScrollBars" property.
+*/
+
+void QAbstractScrollAreaPrivate::setFingerScrollBars(bool setting)
+{
+	Q_Q(QAbstractScrollArea);
+	
+	if (setting) {
+		if (!fingerScrollBars)
+		{
+			scrollAreaStyle = q->styleSheet();
+		}
+		q->setStyleSheet(
+			"QScrollBar:horizontal { "
+			"background: palette(window); "
+			"height: 8px; "
+			"margin: 0px 0px 0px 0px; "
+			"padding: 0px 0px 0px 0px; "
+			"}" 
+			"QScrollBar::vertical { "
+			"background: palette(window); "
+			"width: 8px; "
+			"margin: 0px 0px 0px 0px; "
+			"padding: 0px 0px 0px 0px; "
+			"} "
+			"QScrollBar::handle:horizontal { "
+			"background: palette(window-text); "
+			"min-width: 40px; "
+			"} "
+			"QScrollBar::handle::vertical { "
+			"background: palette(window-text); "
+			"min-height: 40px; "
+			"} "
+			"QScrollBar::add-line::horizontal { "
+			"width: 0px; "
+			"} "
+			"QScrollBar::sub-line::horizontal { "
+			"width: 0px; "
+			"} "
+			"QScrollBar::add-line::vertical { "
+			"height: 0px; "
+			"} "
+			"QScrollBar::sub-line::vertical { "
+			"height: 0px; "
+			"} ");
+	} else {
+		q->setStyleSheet(scrollAreaStyle);
+	}
+	fingerScrollBars = setting;
+}
+
+void QAbstractScrollAreaPrivate::drawOvershoot(int horizontal, int vertical)
+{
+	Q_Q(QAbstractScrollArea);
+	int overshoot_x = horizontal;
+	int overshoot_y = vertical;
+	if (overshoot_x >= 0)
+	{
+		if (q->isRightToLeft())
+			overshoot_x += right;
+		else
+			overshoot_x += left;
+	}
+	else
+	{
+		if (q->isRightToLeft())
+			overshoot_x -= left;
+		else
+			overshoot_x -= right;
+	}
+	if (overshoot_y >= 0)
+		overshoot_y += top;
+	else
+		overshoot_y -= bottom;
+
+	q->viewport()->move(overshoot_x, overshoot_y);
+}
+
+#endif
+
 /*!
     \internal
 
@@ -518,6 +648,13 @@ void QAbstractScrollArea::setViewport(QWidget *widget)
         d->viewport->setParent(this);
         d->viewport->setFocusProxy(this);
         d->viewport->installEventFilter(d->viewportFilter);
+#ifdef Q_WS_HILDON
+		if (d->fingerScroller) {
+			delete d->fingerScroller;
+			d->fingerScroller = 0;
+			setProperty("FingerScrollable", true); // sets a fingerscroller on the new viewport
+		}
+#endif
         d->layoutChildren();
         if (isVisible())
             d->viewport->show();
@@ -909,6 +1046,16 @@ bool QAbstractScrollArea::event(QEvent *e)
     case QEvent::DragLeave:
 #endif
         return false;
+#ifdef Q_WS_HILDON
+	case QEvent::DynamicPropertyChange: {
+		QString p = static_cast<QDynamicPropertyChangeEvent *>(e)->propertyName();
+		if (p == "FingerScrollBars") { // use some boolean short-circuit so !isValid == False
+			d->setFingerScrollBars(property("FingerScrollBars").isValid() and property("FingerScrollBars").toBool());
+		} else if (p == "FingerScrollable" and property("FingerScrollable").isValid()) {
+			d->setFingerScrollable(property("FingerScrollable").isValid() and property("FingerScrollable").toBool());
+		}
+	}
+#endif
     case QEvent::StyleChange:
     case QEvent::LayoutDirectionChange:
     case QEvent::ApplicationLayoutDirectionChange:
@@ -1295,6 +1442,495 @@ void QAbstractScrollArea::setupViewport(QWidget *viewport)
     Q_UNUSED(viewport);
 }
 
+#ifdef Q_WS_HILDON
+
+const int QAbstractScrollAreaPrivateScroller::START_WITHIN    = 300;  // must move within X ms to scroll
+const int QAbstractScrollAreaPrivateScroller::SENSITIVITY     = 20;   // pixels before we scroll
+const int QAbstractScrollAreaPrivateScroller::KINETIC_REFRESH = 50;   // ms
+const int QAbstractScrollAreaPrivateScroller::VSCALE          = 100;  // velocity scaling to ensure not lost in int rounding
+const int QAbstractScrollAreaPrivateScroller::DECEL_PC        = 93;   // velocity reduction factor/kinetic refresh (%)
+const int QAbstractScrollAreaPrivateScroller::DECEL_DURATION  = 1500; // ms
+const int QAbstractScrollAreaPrivateScroller::VMAX            = 500;  // Max velocity
+//const int QAbstractScrollAreaPrivateScroller::OVERSHOOT_DECEL_PC = 40;   // velocity reduction factor/kinetic refresh (%)
+#define OVERSHOOT_DECEL_PC 50
+#define REBOUND_ACCEL 10
+	
+QAbstractScrollAreaPrivateScroller::QAbstractScrollAreaPrivateScroller(QWidget *parent_viewport, QAbstractScrollArea *a, QAbstractScrollAreaPrivate *d) :
+	QObject(parent_viewport),
+	qabstractscrollarea(a),
+	qabstractscrollarea_d(d),
+	scrollState(NotScrolling),
+	xScrollState(NotScrolling),
+	yScrollState(NotScrolling),
+	scrollBase(0,0),
+	start(0,0),
+	curr(0,0),
+	scrollFactor(),
+	last(0,0),
+	vel(0,0),
+	vel1(0,0),
+	last_ev_time(0),
+	curr_time(0)
+{
+	registerChildrenForFingerScrolling(parent_viewport);
+
+	// If the property is not set then use the qapp default or hard default
+	if (! qabstractscrollarea->property("FingerScrollBars").isValid()) {
+		if (qApp->property("FingerScrollBars").isValid()) {
+			d->fingerScrollBars = qApp->property("FingerScrollBars").toBool();
+		}
+		qabstractscrollarea->setProperty("FingerScrollBars", d->fingerScrollBars);
+	} else {
+		d->fingerScrollBars = qabstractscrollarea->property("FingerScrollBars").toBool();
+	}
+
+}
+////////////////////////////////////////////////////////////////
+// Finger scroll - touches, moves and child events
+bool QAbstractScrollAreaPrivateScroller::eventFilter(QObject *obj, QEvent *event)
+{
+	if (scrollState == ReissuingEvents or ! obj->isWidgetType()) {
+		return false ; // ignore events during re-issue. Should this be QObject::eventFilter(obj, event); 
+	}
+	
+	QMouseEvent * mEv = dynamic_cast<QMouseEvent *>(event);
+
+	QScrollBar* vsb = qabstractscrollarea->verticalScrollBar(); 
+	QScrollBar* hsb = qabstractscrollarea->horizontalScrollBar();
+
+	if (scrollState == AutoScroll) {
+		// We're already doing a kinetic movement. A click resets.
+		if (event->type() == QEvent::MouseButtonPress and
+			mEv and mEv->button() == Qt::LeftButton){
+			scrollState = NotScrolling;
+			xScrollState = NotScrolling;
+			yScrollState = NotScrolling;
+			// Fall through to maybe start another scroll
+			// Would it be safer to kill the kinetic timer or just let it die?
+		}
+	}
+	
+	if (scrollState == NotScrolling) {
+		if (event->type() == QEvent::MouseButtonPress and
+			mEv and mEv->button() == Qt::LeftButton){
+			start = mEv->globalPos();
+			scrollBase.ry() = vsb->value(); // Record scrollbar at first touch - reduces jitter errors
+			scrollBase.rx() = hsb->value();
+
+			scrollFactor = QPointF();
+			xScrollState = NotScrolling;
+			yScrollState = NotScrolling;
+			// We need to know the how much scrollBar->value changes per pixel of movement
+			if ( vsb->minimum() < vsb->maximum()) {
+				scrollFactor.ry() = (qreal) vsb->pageStep() / qabstractscrollarea->viewport()->height();
+//				qDebug() << "scrollFactor.y =" << scrollFactor.ry();
+				yScrollState = Maybe;
+			}
+			if ( hsb->minimum() < hsb->maximum() ) {
+				scrollFactor.rx() = (qreal) hsb->pageStep() / qabstractscrollarea->viewport()->width();
+//				qDebug() << "scrollFactor.x =" << scrollFactor.rx();
+				xScrollState = Maybe;
+			}
+
+			if (xScrollState == NotScrolling and yScrollState == NotScrolling)
+				return false; // We have no ability to scroll so don't try.
+			
+			if (! (eventSourceWidget = dynamic_cast<QWidget *>(obj)))
+				return false; // just to be sure the object is a widget
+
+			// We're definitely going to try and scroll if we get a move in time
+			scrollState = Maybe;
+			storedEvents.enqueue(new QMouseEvent(*mEv)); // store the event for maybe replaying
+
+			QTimer::singleShot(START_WITHIN, this, SLOT(replayEvents())); // this *will* fire..
+
+			event_time.start();
+			last_ev_time=0;
+			mEv->accept(); // it's handled. The copy may be replayed.
+			return true;  
+		}
+	}
+
+	if (scrollState == Maybe ) {
+		if (event->type() == QEvent::MouseButtonRelease) {
+//			qDebug() << "    QAbstractScrollArea::Released";
+			if (mEv->button() != Qt::LeftButton) return false; // fall through, allow onward handling
+			storedEvents.enqueue(new QMouseEvent(*mEv));
+			QTimer::singleShot(0, this, SLOT(replayEvents())); // immediate replay...
+			mEv->accept(); // it's handled. The copy may be replayed.
+			return true;  
+		}
+		if (event->type() == QEvent::MouseMove) {
+			handleMoveEvent(mEv);
+			mEv->accept(); // it's handled. The copy may be replayed.
+			return true;
+		}
+	}
+	
+	if (scrollState == ManualScroll) {
+		if (event->type() == QEvent::MouseButtonRelease) {
+			scrollState = NotScrolling;
+			mEv->accept(); // it's handled.
+			if (last_ev_time) { // Only do velocity if we had a last_ev_time
+				vel1.rx() = qBound(-VMAX, vel1.rx(), VMAX);
+				vel1.ry() = qBound(-VMAX, vel1.ry(), VMAX);
+				vel = vel1; // make a copy of the initial velocity for direction
+				curr_time = event_time.elapsed();
+				// Note the current scroll values, possibly overshot
+				curr = mEv->globalPos();
+				scrollBase.ry() = scrollBase.ry() + ((start.ry() - curr.ry()) * scrollFactor.ry());
+				scrollBase.rx() = scrollBase.rx() + ((start.rx() - curr.rx()) * scrollFactor.rx());
+				curr = QPoint(); // rebase the pointer for the kinetic phase
+				startTimer(KINETIC_REFRESH);
+				scrollState = AutoScroll;
+				if (xScrollState != NotScrolling) xScrollState = AutoScroll;
+				if (yScrollState != NotScrolling) yScrollState = AutoScroll;
+			}
+			return true;
+		}
+		if (event->type() == QEvent::MouseMove) {
+			handleMoveEvent(mEv);
+			mEv->accept(); // it's handled. The copy may be replayed.
+			return true;
+		}
+	}
+
+	// Handle eventFilter to added/removed children
+	
+	if (event->type() ==  QEvent::ChildAdded or
+		event->type() ==  70) { // FIX is this a Qt bug? 70 is ChildInserted which is
+		// deprecated in 4.4 but it appears from time to time...
+		registerChildrenForFingerScrolling(static_cast<QChildEvent *>(event)->child());
+		return false;
+	}
+	
+	if (event->type() == QEvent::ChildRemoved) {
+		// deregisterChildrenForFingerScrolling
+		QObject *obj = static_cast<QChildEvent *>(event)->child();
+		if (obj->isWidgetType())
+			obj->removeEventFilter(this);
+		QList<QObject *> children = obj->findChildren<QObject *>();
+		foreach (obj, children){
+			if (obj->isWidgetType())
+				obj->removeEventFilter(this);
+		}
+		return false;
+	}
+	return false;
+}
+
+
+void QAbstractScrollAreaPrivateScroller::handleMoveEvent ( QMouseEvent * event )
+{
+//	qDebug() << "    QAbstractScrollArea::Released";
+	if (scrollState == Maybe) {
+		QPoint delta = start - event->globalPos();
+		storedEvents.enqueue(new QMouseEvent(*event)); // we may need to play this back...
+
+		if (delta.manhattanLength () > SENSITIVITY) { // ...unless there's been enough movement
+			scrollState = ManualScroll;
+			if (xScrollState == Maybe) xScrollState = ManualScroll;
+			if (yScrollState == Maybe) yScrollState = ManualScroll;
+			while (!(storedEvents.isEmpty()))  // all previous events are ours; clean up
+				delete storedEvents.dequeue() ;
+
+		}
+	}
+	
+	if (scrollState == ManualScroll) {
+		curr = event->globalPos();
+
+		int min_y = qabstractscrollarea->verticalScrollBar()->minimum();
+		int max_y = qabstractscrollarea->verticalScrollBar()->maximum();// - qabstractscrollarea_d->overshootBottom;
+		int min_x = qabstractscrollarea->horizontalScrollBar()->minimum();
+		int max_x = qabstractscrollarea->horizontalScrollBar()->maximum();// - qabstractscrollarea_d->overshootRight;
+		int val_y = 0;
+		int val_x = 0;
+		int overshoot_x = 0;
+		int overshoot_y = 0;
+
+		if (yScrollState == ManualScroll) {
+			val_y = scrollBase.ry() + ((start.ry() - curr.ry()) * scrollFactor.ry());
+			if (val_y < min_y) {
+				overshoot_y = min_y - val_y;
+			} else if (val_y > max_y) {
+				overshoot_y = max_y - val_y;
+			}
+			qabstractscrollarea->verticalScrollBar()->setValue(val_y);
+		}
+		if (xScrollState == ManualScroll) {
+			val_x = scrollBase.rx() + ((start.rx() - curr.rx()) * scrollFactor.rx());
+			if (val_x < min_x) {
+				overshoot_x = min_x - val_x;
+			} else if (val_x > max_x) {
+				overshoot_x = max_x - val_x;
+			}
+			qabstractscrollarea->horizontalScrollBar()->setValue(val_x);
+		}
+
+		qabstractscrollarea_d->drawOvershoot(overshoot_x, overshoot_y);
+
+		curr_time = event_time.elapsed();
+		
+		if (curr_time >	last_ev_time){
+			if (last_ev_time){  // first time round we set v to zero
+				vel1 = vel;
+				vel = QPoint((last - curr)*VSCALE / (curr_time - last_ev_time));
+			} else {
+				vel = QPoint(0,0);
+				vel1 = QPoint(0,0);
+			}
+			// Store the last values
+			last_ev_time = 	curr_time;
+			last = curr; 
+		}
+		event->accept();
+	}
+}
+////////////////////////////////////////////////////////////////
+// Kinetics, reissue pending events
+void QAbstractScrollAreaPrivateScroller::timerEvent(QTimerEvent *event)
+{
+	// Track the projected position using curr. This will allow bounce effects and smooths non-pixel scrolled areas
+	// In general work in pixels and conver to scrollbar values at the end
+
+	// frequently used
+	QScrollBar* vsb = qabstractscrollarea->verticalScrollBar(); 
+	QScrollBar* hsb = qabstractscrollarea->horizontalScrollBar();
+
+	int min_y = vsb->minimum();
+	int max_y = vsb->maximum();// - qabstractscrollarea_d->overshootBottom;
+	int min_x = hsb->minimum();
+	int max_x = hsb->maximum();// - qabstractscrollarea_d->overshootRight;
+	int val_y = 0;
+	int val_x = 0;
+	int overshoot_x = 0;
+	int overshoot_y = 0;
+// Y
+	
+	if (yScrollState == NotScrolling)
+		vel1.ry() = 0;
+		
+	if (yScrollState == AutoScroll) {
+		// decelerate normally
+		int y = curr.ry();
+		curr.ry() += (vel1.ry() * KINETIC_REFRESH)/VSCALE;
+		val_y = scrollBase.ry() + curr.ry() * scrollFactor.ry();
+		if (min_y < val_y and val_y < max_y) { // in range
+			vsb->setValue(val_y);
+			vel1.ry() = (vel1.ry()*DECEL_PC)/100;
+			if (-1.0 < vel1.ry() and vel1.ry() < 1.0) // ie: stopped
+				yScrollState = NotScrolling;
+		} else { // we would have passed the min/max so set the target
+			if (min_y <= val_y)
+				rest.ry() = max_y;
+			else
+				rest.ry() = min_y;				
+			curr.ry()  = y; // reset the current position
+			yScrollState = OverShootDecel;
+		}
+	}
+
+	if (yScrollState == OverShootDecel) {
+		// Overshoot needs to track the virtual finger position over time and pull
+		// it back to a position that represents the start/end of the area
+		//qDebug() << "OverShootDecel y="  << curr.ry() << " v.y = " << vel1.ry();
+		if (-1.0 < vel1.ry() and vel1.ry() < 1.0) {
+			// we stopped (or we may have been placed here)
+			val_y=scrollBase.ry() + curr.ry() * scrollFactor.ry();
+			if (val_y < min_y) {
+				overshoot_y = min_y - val_y;
+			} else if (val_y > max_y) {
+				overshoot_y = max_y - val_y;
+			}
+			vel1.ry() = 0;
+			yScrollState = OverShootPause; // this actually stops us for a frame.
+		} else {
+			// we're slowing down
+			curr.ry() += (vel1.ry() * KINETIC_REFRESH)/VSCALE;
+			vel1.ry() = (vel1.ry()*OVERSHOOT_DECEL_PC)/100;
+			val_y=scrollBase.ry() + curr.ry() * scrollFactor.ry();
+			vsb->setValue(val_y); // Is this worth doing if we overshot
+			if (val_y < min_y) {
+				overshoot_y = min_y - val_y;
+			} else if (val_y > max_y) {
+				overshoot_y = max_y - val_y;
+			}
+		}
+	}
+
+	// rest is target resting place in val, not pixels
+	// if y>rest then reduce vel
+	if (yScrollState == OverShootStabilise) {
+		val_y=scrollBase.ry() + curr.ry() * scrollFactor.ry();
+		if (min_y <= val_y and val_y <= max_y) { // in range
+			// run out of braking... force setting to min/max
+			vsb->setValue(rest.ry());
+			overshoot_y = 0;
+			yScrollState = NotScrolling;
+		} else {
+			// accelerate towards rest
+			if (val_y < min_y)
+				vel1.ry() += 5;
+			else
+				vel1.ry() -= 5;
+			curr.ry() += vel1.ry();
+			val_y = scrollBase.ry() + curr.ry() * scrollFactor.ry();
+			vsb->setValue(val_y); // in overshoot?
+			if (val_y < min_y) {
+				overshoot_y = min_y - val_y;
+			} else if (val_y > max_y) {
+				overshoot_y = max_y - val_y;
+			}
+		}
+	}
+
+	// Pause is deliberately after OverShootStabilise to force a timerEvent cycle
+	if (yScrollState == OverShootPause)
+	{
+		// there won't be any change, we just need to get the previous amount of overshoot
+		val_y=scrollBase.ry() + curr.ry() * scrollFactor.ry();
+		if (val_y < min_y) {
+			overshoot_y = min_y - val_y;
+		} else if (val_y > max_y)	{
+			overshoot_y = max_y - val_y;
+		}
+		yScrollState = OverShootStabilise;
+	}
+
+// X
+
+	if (xScrollState == NotScrolling)
+		vel1.rx() = 0;
+		
+	if (xScrollState == AutoScroll) {
+		// decelerate normally
+		int x = curr.rx();
+		curr.rx() += (vel1.rx() * KINETIC_REFRESH)/VSCALE;
+		val_x = scrollBase.rx() + curr.rx() * scrollFactor.rx();
+		if (min_x < val_x and val_x < max_x) { // in range
+			hsb->setValue(val_x);
+			vel1.rx() = (vel1.rx()*DECEL_PC)/100;
+			if (-1.0 < vel1.rx() and vel1.rx() < 1.0) // ie: stopped
+				xScrollState = NotScrolling;
+		} else { // we would have passed the min/max so set the target
+			if (min_x <= val_x)
+				rest.rx() = max_x;
+			else
+				rest.rx() = min_x;				
+			curr.rx()  = x; // reset the current position
+			xScrollState = OverShootDecel;
+		}
+	}
+
+	if (xScrollState == OverShootDecel) {
+		// Overshoot needs to track the virtual finger position over time and pull
+		// it back to a position that represents the start/end of the list
+		//qDebug() << "OverShootDecel x="  << curr.rx() << " v.x = " << vel1.rx();
+		if (-1.0 < vel1.rx() and vel1.rx() < 1.0) {
+			// we stopped (or we may have been placed here)
+			val_x=scrollBase.rx() + curr.rx() * scrollFactor.rx();
+			if (val_x < min_x) {
+				overshoot_x = min_x - val_x;
+			} else if (val_x > max_x) {
+				overshoot_x = max_x - val_x;
+			}
+			vel1.rx() = 0;
+			xScrollState = OverShootPause;
+
+		} else {
+			// we're slowing down
+			curr.rx() += (vel1.rx() * KINETIC_REFRESH)/VSCALE;
+			vel1.rx() = (vel1.rx()*OVERSHOOT_DECEL_PC)/100;
+			val_x=scrollBase.rx() + curr.rx() * scrollFactor.rx();
+			hsb->setValue(val_x);
+			if (val_x < min_x) {
+				overshoot_x = min_x - val_x;
+			} else if (val_x > max_x) {
+				overshoot_x = max_x - val_x;
+			}
+		}
+	}
+
+	if (xScrollState == OverShootStabilise) {
+		val_x=scrollBase.rx() + curr.rx() * scrollFactor.rx();
+		if (min_x <= val_x and val_x <= max_x) { // in range
+			// run out of braking... force setting to min/max
+			hsb->setValue(rest.rx());
+			overshoot_x = 0;
+			xScrollState = NotScrolling;
+		} else {
+			// accelerate towards rest
+			if (val_x < min_x)
+				vel1.rx() += 5;
+			else
+				vel1.rx() -= 5;
+			curr.rx() += vel1.rx();
+			val_x = scrollBase.rx() + curr.rx() * scrollFactor.rx();
+			hsb->setValue(val_x); // in overshoot?
+			if (val_x < min_x) {
+				overshoot_x = min_x - val_x;
+			} else if (val_x > max_x) {
+				overshoot_x = max_x - val_x;
+			}
+		}
+	}
+
+	// Pause is deliberately after OverShootStabilise to force a timerEvent cycle
+	if (xScrollState == OverShootPause)
+	{
+		// there won't be any change, we just need to get the previous amount of overshoot
+		val_x=scrollBase.rx() + curr.rx() * scrollFactor.rx();
+		if (val_x < min_x) {
+			overshoot_x = min_x - val_x;
+		} else if (val_x > max_x) {
+			overshoot_x = max_x - val_x;
+		}
+		xScrollState = OverShootStabilise;
+	}
+
+	qabstractscrollarea_d->drawOvershoot(overshoot_x, overshoot_y);
+
+	qabstractscrollarea->show();
+
+	if (xScrollState == NotScrolling and yScrollState == NotScrolling) {
+		//qDebug() << "Stopped timer";
+		killTimer(event->timerId());
+		scrollState = NotScrolling;
+	}
+}
+
+void QAbstractScrollAreaPrivateScroller::registerChildrenForFingerScrolling(QObject *obj)
+{
+
+	if (qobject_cast<QAbstractScrollArea *>(obj)) return; // Ignore any QAbstractScrollArea derived objects and hence their children
+
+	if (obj->isWidgetType())
+		obj->installEventFilter(this);
+	
+	foreach (QObject* child, obj->children()){
+		registerChildrenForFingerScrolling(child);
+	}
+}
+void QAbstractScrollAreaPrivateScroller::replayEvents()
+{
+	if (scrollState != Maybe) return;
+
+	QEvent *ev;
+	scrollState = ReissuingEvents;
+	while (!storedEvents.isEmpty()) {
+		ev = storedEvents.dequeue() ;
+		if (! eventSourceWidget.isNull()) {
+			qApp->notify(eventSourceWidget, ev);
+		}
+		delete ev;
+	}
+	scrollState = NotScrolling;
+}
+
+
+#endif // Q_WS_HILDON
+
 QT_END_NAMESPACE
 
 #include "moc_qabstractscrollarea.cpp"
diff --git a/src/gui/widgets/qabstractscrollarea.h b/src/gui/widgets/qabstractscrollarea.h
index 3ec41d1..d893e8d 100644
--- a/src/gui/widgets/qabstractscrollarea.h
+++ b/src/gui/widgets/qabstractscrollarea.h
@@ -51,7 +51,6 @@ QT_BEGIN_NAMESPACE
 QT_MODULE(Gui)
 
 #ifndef QT_NO_SCROLLAREA
-
 class QScrollBar;
 class QAbstractScrollAreaPrivate;
 
diff --git a/src/gui/widgets/qabstractscrollarea_p.h b/src/gui/widgets/qabstractscrollarea_p.h
index 3c356e2..a14b6b9 100644
--- a/src/gui/widgets/qabstractscrollarea_p.h
+++ b/src/gui/widgets/qabstractscrollarea_p.h
@@ -6,11 +6,11 @@
 ** This file is part of the QtGui module of the Qt Toolkit.
 **
 ** $QT_BEGIN_LICENSE:LGPL$
-** No Commercial Usage
-** This file contains pre-release code and may not be distributed.
-** You may use this file in accordance with the terms and conditions
-** contained in the either Technology Preview License Agreement or the
-** Beta Release License Agreement.
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
 **
 ** GNU Lesser General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU Lesser
@@ -60,6 +60,14 @@ QT_BEGIN_NAMESPACE
 
 #ifndef QT_NO_SCROLLAREA
 
+#ifdef Q_WS_HILDON
+#include <QTime>
+#include <QQueue>
+class QTimerEvent;
+class QEvent;
+class QAbstractScrollAreaPrivateScroller;
+#endif
+
 class QScrollBar;
 class QAbstractScrollAreaScrollBarContainer;
 class Q_GUI_EXPORT QAbstractScrollAreaPrivate: public QFramePrivate
@@ -74,7 +82,17 @@ public:
     QAbstractScrollAreaScrollBarContainer *scrollBarContainers[Qt::Vertical + 1];
     QScrollBar *hbar, *vbar;
     Qt::ScrollBarPolicy vbarpolicy, hbarpolicy;
-
+	
+#ifdef Q_WS_HILDON
+	QAbstractScrollAreaPrivateScroller *fingerScroller;
+	bool fingerScrollBars;
+	bool fingerScrollable;
+	QString scrollAreaStyle;
+	void setFingerScrollable(bool);
+	void setFingerScrollBars(bool);
+	virtual void drawOvershoot(int horizontal, int vertical);
+#endif
+	
     QWidget *viewport;
     QWidget *cornerWidget;
     QRect cornerPaintingRect;
@@ -132,6 +150,61 @@ private:
     Qt::Orientation orientation;
 };
 
+#ifdef Q_WS_HILDON
+// This is the Kinetic fingerscroll implementation for Hildon
+
+class QAbstractScrollAreaPrivateScroller : public QObject
+{
+	Q_OBJECT
+public:
+	QAbstractScrollAreaPrivateScroller(QWidget *parent, QAbstractScrollArea *qabstractscrollarea, QAbstractScrollAreaPrivate *priv);
+	bool eventFilter(QObject *obj, QEvent *event);
+
+protected Q_SLOTS:
+	void replayEvents();
+
+protected:
+	void handleMoveEvent ( QMouseEvent * event );
+	void timerEvent(QTimerEvent *event);
+	void registerChildrenForFingerScrolling(QObject *top);
+
+	static const int SENSITIVITY, KINETIC_REFRESH, VSCALE,
+		DECEL_DURATION, DEBOUNCE, DECEL_PC, START_WITHIN,
+		VMAX;
+	
+	QAbstractScrollArea  *qabstractscrollarea;  // the area we're scrolling
+	QAbstractScrollAreaPrivate *qabstractscrollarea_d; // and its private data
+	
+	typedef enum { NotScrolling = 0, Maybe, ManualScroll, AutoScroll,
+				   OverShootDecel, OverShootPause, OverShootStabilise,
+				   ReissuingEvents } ScrollState;
+	ScrollState  scrollState, xScrollState, yScrollState;
+
+	QPointer<QWidget> eventSourceWidget; // who do we play events back to
+	QQueue<QEvent*>   storedEvents;      // events to play back
+
+	QPoint scrollBase;           // scrollbar value at fingerdown to establish base position
+	QPoint start;                // global event x,y at start
+	QPoint curr;                 // current x,y (kept to allow velocity calc)
+	QPoint rest;                 // rest x,y (resting place after overshoot
+
+	QPointF scrollFactor;        // scroll range factor - converts pixel delta to sb value delta
+
+	QTime event_time;
+	QPoint last;                 // global event x,y at start
+	QPoint vel;                  // Velocity
+	QPoint vel1;                 // Velocity before
+	int last_ev_time, curr_time; // timer for velocity
+		
+	int scrollingNotStartedTimer;
+	int x_braking_cycles;          // how long do we slow down for
+	int y_braking_cycles;          // how long do we slow down for
+};
+
+#endif // Q_WS_HILDON
+
+
+
 #endif // QT_NO_SCROLLAREA
 
 QT_END_NAMESPACE
diff --git a/src/gui/widgets/qabstractslider.cpp b/src/gui/widgets/qabstractslider.cpp
index 6865a56..23067f5 100644
--- a/src/gui/widgets/qabstractslider.cpp
+++ b/src/gui/widgets/qabstractslider.cpp
@@ -531,6 +531,33 @@ void QAbstractSlider::setValue(int value)
     emit valueChanged(value);
 }
 
+#ifdef Q_WS_HILDON
+/*!
+    Sets the value but allows out-of-bound values
+    This changes the slider position if the value is in bounds.
+*/
+void QAbstractSlider::setValueOvershoot(int value)
+{
+    Q_D(QAbstractSlider);
+    int v_bound = d->bound(value);
+	if (v_bound != value)
+		qDebug() << "setValue: bound() " << v_bound << " : " << value;
+    if (d->value == value && d->position == value)
+        return;
+    d->value = value;
+    if (d->position != v_bound) {
+        d->position = v_bound;
+        if (d->pressed)
+            emit sliderMoved((d->position = v_bound));
+    }
+#ifndef QT_NO_ACCESSIBILITY
+    QAccessible::updateAccessibility(this, 0, QAccessible::ValueChanged);
+#endif
+    sliderChange(SliderValueChange);
+    emit valueChanged(value);
+}
+#endif //Q_WS_HILDON
+
 /*!
     \property QAbstractSlider::invertedAppearance
     \brief whether or not a slider shows its values inverted.
diff --git a/src/gui/widgets/qabstractslider.h b/src/gui/widgets/qabstractslider.h
index 7e03b6e..e05a2f0 100644
--- a/src/gui/widgets/qabstractslider.h
+++ b/src/gui/widgets/qabstractslider.h
@@ -119,6 +119,9 @@ public:
     void triggerAction(SliderAction action);
 
 public Q_SLOTS:
+#ifdef Q_WS_HILDON
+	void setValueOvershoot(int);
+#endif
     void setValue(int);
     void setOrientation(Qt::Orientation);
 
diff --git a/src/gui/widgets/qabstractspinbox.cpp b/src/gui/widgets/qabstractspinbox.cpp
index e079271..2393904 100644
--- a/src/gui/widgets/qabstractspinbox.cpp
+++ b/src/gui/widgets/qabstractspinbox.cpp
@@ -62,6 +62,10 @@
 #include <limits.h>
 #endif
 
+#if defined (Q_WS_HILDON)
+#   include <qinputcontext.h>
+#endif
+
 //#define QABSTRACTSPINBOX_QSBDEBUG
 #ifdef QABSTRACTSPINBOX_QSBDEBUG
 #  define QASBDEBUG qDebug
@@ -619,9 +623,28 @@ void QAbstractSpinBox::stepBy(int steps)
 }
 
 /*!
+ */
+QVariant QAbstractSpinBox::inputMethodQuery(Qt::InputMethodQuery query) const
+{    
+    Q_D(const QAbstractSpinBox);
+
+    switch(query) {
+#ifdef Q_WS_HILDON
+        case Qt::ImMode:{
+            int mode = HILDON_GTK_INPUT_MODE_NUMERIC;
+            return QVariant(mode);
+        }
+#endif
+        default:
+            return d->edit->inputMethodQuery(query);
+    }
+}
+
+/*!
     This function returns a pointer to the line edit of the spin box.
 */
 
+
 QLineEdit *QAbstractSpinBox::lineEdit() const
 {
     Q_D(const QAbstractSpinBox);
@@ -659,7 +682,9 @@ void QAbstractSpinBox::setLineEdit(QLineEdit *lineEdit)
         d->edit->setParent(this);
 
     d->edit->setFrame(false);
+#ifndef Q_WS_HILDON
     d->edit->setAttribute(Qt::WA_InputMethodEnabled, false);
+#endif
     d->edit->setFocusProxy(this);
     d->edit->setAcceptDrops(false);
 
@@ -1182,7 +1207,7 @@ void QAbstractSpinBox::timerEvent(QTimerEvent *event)
 
 void QAbstractSpinBox::contextMenuEvent(QContextMenuEvent *event)
 {
-#ifdef QT_NO_CONTEXTMENU
+#if (defined(QT_NO_CONTEXTMENU) || defined(Q_WS_HILDON))
     Q_UNUSED(event);
 #else
     Q_D(QAbstractSpinBox);
diff --git a/src/gui/widgets/qabstractspinbox.h b/src/gui/widgets/qabstractspinbox.h
index d8b9757..6ca9a15 100644
--- a/src/gui/widgets/qabstractspinbox.h
+++ b/src/gui/widgets/qabstractspinbox.h
@@ -159,6 +159,11 @@ Q_SIGNALS:
 protected:
     QAbstractSpinBox(QAbstractSpinBoxPrivate &dd, QWidget *parent = 0);
 
+#ifdef Q_WS_HILDON
+public:
+    QVariant inputMethodQuery(Qt::InputMethodQuery) const;
+#endif
+
 private:
     Q_PRIVATE_SLOT(d_func(), void _q_editorTextChanged(const QString &))
     Q_PRIVATE_SLOT(d_func(), void _q_editorCursorPositionChanged(int, int))
diff --git a/src/gui/widgets/qcombobox.cpp b/src/gui/widgets/qcombobox.cpp
index f04a415..7f805f4 100644
--- a/src/gui/widgets/qcombobox.cpp
+++ b/src/gui/widgets/qcombobox.cpp
@@ -206,7 +206,11 @@ QRect QComboBoxPrivate::popupGeometry(int screen) const
 #ifdef Q_WS_WIN
     return QApplication::desktop()->screenGeometry(screen);
 #elif defined Q_WS_X11
-    if (X11->desktopEnvironment == DE_KDE)
+    if (X11->desktopEnvironment == DE_KDE
+#ifdef Q_WS_HILDON
+        || X11->desktopEnvironment == DE_HILDON
+#endif
+    )
         return QApplication::desktop()->screenGeometry(screen);
     else
         return QApplication::desktop()->availableGeometry(screen);
@@ -2920,7 +2924,7 @@ void QComboBox::wheelEvent(QWheelEvent *e)
 }
 #endif
 
-#ifndef QT_NO_CONTEXTMENU
+#if !defined(QT_NO_CONTEXTMENU) || !defined(Q_WS_HILDON)
 /*!
     \reimp
 */
diff --git a/src/gui/widgets/qlineedit.cpp b/src/gui/widgets/qlineedit.cpp
index 7e7c654..cad7b0a 100644
--- a/src/gui/widgets/qlineedit.cpp
+++ b/src/gui/widgets/qlineedit.cpp
@@ -544,6 +544,11 @@ void QLineEdit::setEchoMode(EchoMode mode)
     Q_D(QLineEdit);
     if (mode == (EchoMode)d->echoMode)
         return;
+#ifndef Q_WS_HILDON
+    setAttribute(Qt::WA_InputMethodEnabled, mode == Normal || mode == PasswordEchoOnEdit);
+#else
+    setAttribute(Qt::WA_InputMethodEnabled);
+#endif
     setAttribute(Qt::WA_InputMethodEnabled, shouldEnableInputMethod(this));
     d->echoMode = mode;
     d->passwordEchoEditing = false;
@@ -1749,6 +1754,15 @@ void QLineEdit::mouseReleaseEvent(QMouseEvent* e)
     Q_D(QLineEdit);
     if (d->sendMouseEventToInputContext(e))
 	return;
+#ifdef Q_WS_HILDON
+    //Propagate the event to the parent widget.
+    // QHildonInputMethod installs a filter in a widget  to get
+    // the mouseRelease event. 
+    // In complex widgets like QSpinBoxes or QComboBoxes, these events
+    // are consumed in the sub-widget so they don't reach the parent widget.
+    // Then the Hildon Input Main UI can not be shown if we can't receive them.
+    e->ignore();
+#endif
 #ifndef QT_NO_DRAGANDDROP
     if (e->button() == Qt::LeftButton) {
         if (d->dndTimer.isActive()) {
@@ -2312,6 +2326,10 @@ void QLineEdit::inputMethodEvent(QInputMethodEvent *e)
     if (!e->commitString().isEmpty())
         d->complete(Qt::Key_unknown);
 #endif
+#ifdef Q_WS_HILDON
+    // Sets the cursor position via QInputMethodEvent
+    d->cursor += e->replacementStart();
+#endif
 }
 
 /*!\reimp
@@ -2330,6 +2348,17 @@ QVariant QLineEdit::inputMethodQuery(Qt::InputMethodQuery property) const
         return QVariant(d->text);
     case Qt::ImCurrentSelection:
         return QVariant(selectedText());
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:{
+        int mode;
+        if (d->echoMode == Normal)
+            mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_AUTOCAP | HILDON_GTK_INPUT_MODE_DICTIONARY;
+        else
+            mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_INVISIBLE;
+            
+        return QVariant(mode);
+    }
+#endif
     default:
         return QVariant();
     }
@@ -2341,6 +2370,7 @@ QVariant QLineEdit::inputMethodQuery(Qt::InputMethodQuery property) const
 void QLineEdit::focusInEvent(QFocusEvent *e)
 {
     Q_D(QLineEdit);
+    
     if (e->reason() == Qt::TabFocusReason ||
          e->reason() == Qt::BacktabFocusReason  ||
          e->reason() == Qt::ShortcutFocusReason) {
diff --git a/src/gui/widgets/qmainwindow.cpp b/src/gui/widgets/qmainwindow.cpp
index 0a0faa0..b7fc05e 100644
--- a/src/gui/widgets/qmainwindow.cpp
+++ b/src/gui/widgets/qmainwindow.cpp
@@ -99,6 +99,9 @@ public:
     uint hasOldCursor : 1;
     uint cursorAdjusted : 1;
 #endif
+#ifdef Q_WS_HILDON
+    QPointer<QMenu> globalMenu;
+#endif
 };
 
 void QMainWindowPrivate::init()
@@ -110,6 +113,19 @@ void QMainWindowPrivate::init()
     explicitIconSize = false;
 
     q->setAttribute(Qt::WA_Hover);
+
+#ifdef Q_WS_HILDON
+    //Binding F4 button
+    QAction *showAppContextMenuAct = new QAction(q);
+    showAppContextMenuAct->setShortcut(Qt::Key_F4);
+    q->connect(showAppContextMenuAct, SIGNAL(triggered()),q , SLOT(showApplicationContextMenu()));
+    q->addAction(showAppContextMenuAct);
+    //Binding F6 button
+    QAction *toggleWindowStateAct = new QAction(q);
+    toggleWindowStateAct->setShortcut(Qt::Key_F6);
+    q->connect(toggleWindowStateAct, SIGNAL(triggered()),q , SLOT(toggleWindowState()));
+    q->addAction(toggleWindowStateAct);
+#endif
 }
 
 /*
@@ -674,6 +690,10 @@ void QMainWindow::removeToolBarBreak(QToolBar *before)
 */
 void QMainWindow::addToolBar(Qt::ToolBarArea area, QToolBar *toolbar)
 {
+#ifdef Q_WS_HILDON
+    area = Qt::BottomToolBarArea;
+    toolbar->setMovable(false);
+#endif
     if (!checkToolBarArea(area, "QMainWindow::addToolBar"))
         return;
 
@@ -874,6 +894,81 @@ void QMainWindow::setDockNestingEnabled(bool enabled)
     d->layout->setDockOptions(opts);
 }
 
+#ifdef Q_WS_HILDON
+void QMainWindow::showApplicationContextMenu(){
+    Q_D(QMainWindow);
+
+    static QPoint menuPos;
+    static QAction *quitAction = 0;
+
+    //Hides submenues. GlobalMenu will be destroyed as soons
+    //as QMenu::exec() terminates
+    if (!d->globalMenu.isNull()){
+	d->globalMenu->hide();
+        return;
+    }
+
+    if (!menuBar())
+        return;
+
+    //Getting the Menu position from the style
+    if (menuPos.isNull()){
+        int hMenuOffset = 0, 
+            vMenuOffset = 0;
+
+        hMenuOffset = style()->pixelMetric(QStyle::PM_MenuOffsetHorizontal, 0, this);
+        vMenuOffset = style()->pixelMetric(QStyle::PM_MenuOffsetVertical, 0, this);
+        menuPos = mapToGlobal(QPoint(0, 0));
+        menuPos += QPoint(hMenuOffset, vMenuOffset);
+    }
+
+    //Creating a new Application Context Menu
+    //so that is always updated
+    d->globalMenu = new QMenu(this);
+    QList<QAction*> actionList = menuBar()->actions();
+
+    //Filling the App context menu
+    if (!actionList.isEmpty()){
+        //Trying to get the quitAction from the file menu    
+        QMenu *fileMenu = actionList[0]->menu();
+
+        if (!quitAction && fileMenu){
+            QList<QAction*> fileActionList;
+
+            fileActionList = fileMenu->actions();
+            if (!fileActionList.isEmpty()){
+                QRegExp quitString("(?:close)|(?:exit)|(?:quit)", Qt::CaseInsensitive);
+
+                quitAction = fileActionList.last();   
+                if (quitAction && quitAction->text().remove(QChar('&')).contains(quitString)){
+                    fileMenu->removeAction(quitAction);
+                    if (fileActionList.isEmpty())
+                        actionList.removeFirst();   
+                }else{
+                    quitAction = 0;
+                }
+            }
+        }
+        d->globalMenu->addActions(actionList);
+    }else if (!quitAction){
+         //Minimal menu for application with empty menuBars
+         quitAction = new QAction(tr("Close"), menuBar());  
+         connect(quitAction, SIGNAL(triggered()), SLOT(close()));
+     }
+     
+     //Add quitAction in the last position
+     if (quitAction)
+         d->globalMenu->addAction(quitAction);
+
+     d->globalMenu->exec(menuPos);
+     delete static_cast<QMenu *>(d->globalMenu);
+}
+
+void QMainWindow::toggleWindowState() {
+    setWindowState(windowState() ^ Qt::WindowFullScreen);
+}
+#endif
+
 #if 0
 /*! \property QMainWindow::verticalTabsEnabled
     \brief whether left and right dock areas use vertical tabs
diff --git a/src/gui/widgets/qmainwindow.h b/src/gui/widgets/qmainwindow.h
index 9c2fb88..a71bfa5 100644
--- a/src/gui/widgets/qmainwindow.h
+++ b/src/gui/widgets/qmainwindow.h
@@ -185,12 +185,24 @@ public:
     QT3_SUPPORT_CONSTRUCTOR QMainWindow(QWidget *parent, const char *name, Qt::WindowFlags flags = 0);
 #endif
 
+#ifdef Q_WS_HILDON
+public Q_SLOTS:
+    //NOTE API Changed.
+    void showApplicationContextMenu();
+#endif
+
 #ifndef QT_NO_DOCKWIDGET
 public Q_SLOTS:
     void setAnimated(bool enabled);
     void setDockNestingEnabled(bool enabled);
 #endif
 
+#ifdef Q_WS_HILDON
+public Q_SLOTS:
+    //NOTE API Changed.
+    void toggleWindowState();
+#endif
+
 Q_SIGNALS:
     void iconSizeChanged(const QSize &iconSize);
     void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);
diff --git a/src/gui/widgets/qmenu.cpp b/src/gui/widgets/qmenu.cpp
index 28645b4..0471ed3 100644
--- a/src/gui/widgets/qmenu.cpp
+++ b/src/gui/widgets/qmenu.cpp
@@ -79,6 +79,9 @@
 #   include <private/qt_cocoa_helpers_mac_p.h>
 #endif
 
+#ifdef Q_WS_HILDON
+#   include <qmainwindow.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -170,7 +173,11 @@ QRect QMenuPrivate::popupGeometry(int screen) const
 #ifdef Q_WS_WIN
     return QApplication::desktop()->screenGeometry(screen);
 #elif defined Q_WS_X11
-    if (X11->desktopEnvironment == DE_KDE)
+    if (X11->desktopEnvironment == DE_KDE
+#ifdef Q_WS_HILDON
+        || X11->desktopEnvironment == DE_HILDON
+#endif
+    )
         return QApplication::desktop()->screenGeometry(screen);
     else
         return QApplication::desktop()->availableGeometry(screen);
@@ -2315,6 +2322,16 @@ QMenu::event(QEvent *e)
             keyPressEvent(ke);
             return true;
         }
+#ifdef Q_WS_HILDON
+        //HACK
+        if (ke->key() == Qt::Key_F4){
+            QMainWindow *mw = qobject_cast<QMainWindow*>(parent());
+            if (mw){
+                mw->showApplicationContextMenu();
+                return true;
+            }
+        }
+#endif
     } break;
     case QEvent::ContextMenu:
         if(QMenuPrivate::menuDelayTimer.isActive()) {
diff --git a/src/gui/widgets/qmenubar.cpp b/src/gui/widgets/qmenubar.cpp
index f58ea50..b427a15 100644
--- a/src/gui/widgets/qmenubar.cpp
+++ b/src/gui/widgets/qmenubar.cpp
@@ -725,6 +725,10 @@ void QMenuBarPrivate::init()
     if(mac_menubar)
         q->hide();
 #endif
+#ifdef Q_WS_HILDON
+    if (setCustomContext())
+        q->hide();
+#endif
 #ifdef Q_OS_WINCE
     if (qt_wince_is_mobile()) {
         wceCreateMenuBar(q->parentWidget());
@@ -1374,6 +1378,10 @@ void QMenuBarPrivate::handleReparent()
     macCreateMenuBar(newParent);
 #endif
 
+#ifdef Q_WS_HILDON
+    setCustomContext();
+#endif
+
 #ifdef Q_OS_WINCE
     if (qt_wince_is_mobile() && wce_menubar)
         wce_menubar->rebuild();
diff --git a/src/gui/widgets/qstatusbar.cpp b/src/gui/widgets/qstatusbar.cpp
index 9544c19..748f214 100644
--- a/src/gui/widgets/qstatusbar.cpp
+++ b/src/gui/widgets/qstatusbar.cpp
@@ -248,6 +248,9 @@ QStatusBar::QStatusBar(QWidget * parent, const char *name)
 #else
     reformat();
 #endif
+#ifdef Q_WS_HILDON
+    hide();
+#endif
 }
 
 
@@ -286,6 +289,9 @@ QStatusBar::QStatusBar(QWidget * parent)
 #else
     reformat();
 #endif
+#ifdef Q_WS_HILDON
+    hide();
+#endif
 }
 
 /*!
diff --git a/src/network/maemo/gconfsymbols.cpp b/src/network/maemo/gconfsymbols.cpp
new file mode 100644
index 0000000..1204997
--- /dev/null
+++ b/src/network/maemo/gconfsymbols.cpp
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "gconfsymbols_p.h"
+
+#include <QtCore/qlibrary.h>
+#include <QDebug>
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+static QLibrary *qgconf_libgconf = 0;
+
+bool qgconf_loadLibGConf()
+{
+    g_type_init();
+
+    static volatile bool triedToLoadLibrary = false;
+
+    QLibrary *&lib = qgconf_libgconf;
+    if (triedToLoadLibrary)
+        return lib && lib->isLoaded();
+
+    lib = new QLibrary(QLatin1String("gconf-2"), 4);
+    triedToLoadLibrary = true;
+
+    if (lib->load() && lib->resolve("gconf_client_get_default"))
+       return true;
+
+    lib->unload();
+    delete lib;
+    lib = 0;
+    return false;
+}
+
+void qgconf_unloadLibGConf()
+{
+    qgconf_libgconf->unload();
+}
+
+void *qgconf_resolve_me(const char *name)
+{
+    void *ptr = 0;
+    if (!qgconf_loadLibGConf())
+        qFatal("Cannot find libgconf-2 in your system to resolve symbol '%s'.", name);
+
+    ptr = qgconf_libgconf->resolve(name);
+    if (!ptr)
+        qFatal("Cannot resolve '%s' in your libgconf-2.", name);
+
+    return ptr;
+}
+
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
diff --git a/src/network/maemo/gconfsymbols_p.h b/src/network/maemo/gconfsymbols_p.h
new file mode 100644
index 0000000..93c3117
--- /dev/null
+++ b/src/network/maemo/gconfsymbols_p.h
@@ -0,0 +1,99 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGCONF_SYMBOLS_P_H
+#define QGCONF_SYMBOLS_P_H
+
+#include <QtCore/qglobal.h>
+
+#ifdef Q_WS_HILDON
+
+#include <gconf/gconf.h>
+
+QT_BEGIN_NAMESPACE
+
+class GConf;
+class GConfClient;
+
+typedef enum {
+  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
+  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
+  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
+} GConfClientPreloadType;
+
+typedef void (*GConfClientNotifyFunc)(GConfClient* client,
+                                      guint cnxn_id,
+                                      GConfEntry *entry,
+                                      gpointer user_data);
+
+# define DEFINEFUNC(ret, func, args, argcall, funcret)          \
+    typedef ret (* _q_PTR_##func) args;                         \
+    static inline ret q_##func args                             \
+    {                                                           \
+        static _q_PTR_##func ptr;                               \
+        if (!ptr)                                               \
+            ptr = (_q_PTR_##func) qgconf_resolve_me(#func);     \
+        funcret ptr argcall;                                    \
+    }
+
+//Private Functions
+void *qgconf_resolve_me(const char *name);
+
+//Public Functions
+bool qgconf_loadLibGConf();
+void qgconf_unloadLibGConf();
+
+DEFINEFUNC(GConfClient*, gconf_client_get_default, (),() ,return )
+DEFINEFUNC(GConfValue*,  gconf_client_get, (GConfClient* a, const gchar* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(char* , gconf_client_get_string, (GConfClient* a, const char* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(gboolean, gconf_client_get_bool, (GConfClient* a, const char* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(gint, gconf_client_get_int, (GConfClient* a, const char* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(void, gconf_client_add_dir, (GConfClient* a, const gchar*b, GConfClientPreloadType c, GError** d), (a, b, c, d), )
+DEFINEFUNC(guint, gconf_client_notify_add, (GConfClient* a, const gchar* b, GConfClientNotifyFunc c, gpointer d, GFreeFunc e, GError** f),
+           (a, b, c, d, e, f), return)
+
+
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
+#endif // QGCONF_SYMBOLS_P_H
diff --git a/src/network/maemo/maemo.pri b/src/network/maemo/maemo.pri
new file mode 100644
index 0000000..5fcbe85
--- /dev/null
+++ b/src/network/maemo/maemo.pri
@@ -0,0 +1,15 @@
+# Qt network kernel module
+
+INCLUDEPATH += $$PWD
+
+HEADERS += maemo/qmaemointernetconnectivity.h \ 
+           maemo/qmaemointernetconnectivity_p.h \
+           maemo/qgconfbackend_p.h \
+           maemo/gconfsymbols_p.h
+
+SOURCES += maemo/qmaemointernetconnectivity.cpp \
+           maemo/qgconfbackend.cpp \
+           maemo/gconfsymbols.cpp
+
+CONFIG += link_pkgconfig
+PKGCONFIG += gconf-2.0
diff --git a/src/network/maemo/qgconfbackend.cpp b/src/network/maemo/qgconfbackend.cpp
new file mode 100755
index 0000000..7f850e5
--- /dev/null
+++ b/src/network/maemo/qgconfbackend.cpp
@@ -0,0 +1,179 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgconfbackend_p.h"
+
+#include <QDebug>
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+Q_GLOBAL_STATIC(QGConfBackend, gconfBackend);
+
+QGConfBackend::QGConfBackend()
+{
+    qgconf_loadLibGConf();
+    client = q_gconf_client_get_default();
+}
+
+QGConfBackend::~QGConfBackend()
+{
+    g_object_unref(client);
+    qgconf_unloadLibGConf();
+}
+
+QVariant QGConfBackend::getValue(const QString &key)
+{
+    QVariant retValue;
+    if (q_gconf_client_get_default != 0) {
+        GConfClient* client = q_gconf_client_get_default();
+        GError *err = 0;
+        //Getting the Gconf value type
+        GConfValue* value = 0;
+
+        value = q_gconf_client_get(client, qPrintable(key), &err);
+        if (err) {
+            //qDebug() << "ERROR: Unable to get the Value";
+            g_error_free (err);
+            return QVariant();
+        }
+        if (!value){
+            //qDebug() << "VALUE is 0";
+            return QVariant();
+        }
+        switch(value->type){
+        case GCONF_VALUE_STRING: {
+            char *str = q_gconf_client_get_string(client, qPrintable(key), &err);
+            if (!err) {
+                retValue.setValue(QString::fromUtf8(str));
+                g_free(str);
+            }
+        } break;
+        case GCONF_VALUE_BOOL: {
+            gboolean b = q_gconf_client_get_bool(client, qPrintable(key), &err);
+            if (!err) {
+                retValue.setValue((bool)b);
+            }
+        } break;
+        case GCONF_VALUE_INT: {
+            gint i = q_gconf_client_get_int(client, qPrintable(key), &err);
+            if (!err) {
+                retValue.setValue((int)i);
+            }
+        } break;
+        default:
+            //qDebug("QGConfBackend::getGConfValue: Sorry, the type %d has not been ported ", value->type);
+            return QVariant();
+        }
+
+        if (err)
+            g_error_free (err);
+
+        return retValue;
+    }
+
+    return QVariant();
+}
+
+bool QGConfBackend::connect(const QString& dir, slot funcToCall){
+    //TODO Dir Check
+
+    //Check if the dir exists already in the Map
+    /*
+    QMap<QString, slot>::const_iterator i = map.find(dir);
+    if (i != map.end()){
+        //qDebug() << "The key exists already in the Map.";
+        return false;
+    }*/
+
+    if ( map.value(dir))
+        return false;
+
+    gconfBackend()->map.insert(dir, funcToCall);
+    watch(dir, callback);
+    return true;
+}
+
+QGConfBackend* QGConfBackend::self(){
+    return gconfBackend();
+}
+
+void QGConfBackend::watch(const QString& dir, callbackFunc cPtr){
+    GError *err = 0;
+
+    q_gconf_client_add_dir(client, qPrintable(dir), GCONF_CLIENT_PRELOAD_NONE, &err);
+
+    if (err) {
+        //qDebug() <<  "Failed to add a watch to GCClient:" << err->message;
+        g_error_free (err);
+    }
+
+    q_gconf_client_notify_add(client, qPrintable(dir), cPtr, 0, 0, &err);
+
+    if (err) {
+        //qDebug() << "Failed to add register the callback" << err->message;
+        g_error_free (err);
+    }
+}
+
+void QGConfBackend::callback(GConfClient* a, guint b, GConfEntry* c, void* d){
+    Q_UNUSED(a);
+    Q_UNUSED(b);
+    Q_UNUSED(d);
+    //qDebug() << "KEY" << c->key << "VALUE TYPE" << c->value->type;
+
+    QVariant value;
+    const QString fullKey = c->key;
+    QString key, dir;
+
+    key = fullKey.split("/").last();
+    dir = fullKey;
+    dir.remove("/" + key);
+
+    slot slotToCall = gconfBackend()->map.value(dir);
+    value = gconfBackend()->getValue(fullKey);
+    (*slotToCall)(key, value);
+}
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
diff --git a/src/network/maemo/qgconfbackend_p.h b/src/network/maemo/qgconfbackend_p.h
new file mode 100644
index 0000000..406b969
--- /dev/null
+++ b/src/network/maemo/qgconfbackend_p.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QGCONFBACKEND_P_H
+#define QGCONFBACKEND_P_H
+
+#include "gconfsymbols_p.h"
+#include "QtCore/qstringlist.h"
+#include "QtCore/qvariant.h"
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+typedef void (*slot)(QString& key, QVariant value);
+
+class QGConfBackend
+{
+   typedef void (*callbackFunc)(GConfClient* a, guint b, GConfEntry* c , void* d);
+
+public:
+    QGConfBackend();
+    ~QGConfBackend();
+
+    //Read the value for the key stored in GConf
+    QVariant getValue(const QString &key);
+
+    //slotToCall is called when changes happen in the GConf dir.
+    bool connect(const QString& dir, slot slotToCall);
+
+    static QGConfBackend* self();
+
+private:
+    void watch(const QString& dir, callbackFunc cPtr);
+    static void callback(GConfClient* a, guint b, GConfEntry* c, void* d);
+    void callSlot(GConfEntry* entry);
+
+    GConfClient* client;
+    QMap<QString, slot> map;
+};
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
+#endif //QGCONFBACKEND_P_H
diff --git a/src/network/maemo/qmaemointernetconnectivity.cpp b/src/network/maemo/qmaemointernetconnectivity.cpp
new file mode 100755
index 0000000..3f614d4
--- /dev/null
+++ b/src/network/maemo/qmaemointernetconnectivity.cpp
@@ -0,0 +1,289 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+/*!
+    \class QMaemoInternetConnectivity
+
+    \since 4.5maemo
+
+    \brief The QMaemoInternetConnectivity TODO
+
+    \reentrant
+    \ingroup maemo
+    \inmodule QtNetwork
+
+    QMaemoInternetConnectivity TODO
+*/
+#include "qmaemointernetconnectivity.h"
+#include "qmaemointernetconnectivity_p.h"
+
+#ifdef Q_WS_HILDON
+
+
+QT_BEGIN_NAMESPACE
+
+Q_GLOBAL_STATIC(QMaemoICPrivate, maemoICInstance);
+
+bool QMaemoInternetConnectivity::isConnected(){
+    return maemoICInstance()->isConnected();
+}
+
+static QString currentAPName() {
+    return maemoICInstance()->currentAPName();
+}
+
+void QMaemoInternetConnectivity::connectionRequest(){
+    return maemoICInstance()->connectionRequest();
+}
+
+bool QMaemoInternetConnectivity::isHttpProxyUsed(){
+    return maemoICInstance()->isHttpProxyUsed();
+}
+
+QMaemoICPrivate::QMaemoICPrivate()
+	: connected(UNKNOWN)
+	, icdInterface(0)
+	, icdUiInterface(0)
+{
+	if (!QDBusConnection::systemBus().isConnected()) {
+		qFatal("Cannot connect to the D-BUS session bus.");
+	}
+
+	//Creating D-Bus interfeces
+	icdInterface = new QDBusInterface(ICD_DBUS_SERVICE, ICD_DBUS_PATH,
+			ICD_DBUS_INTERFACE, QDBusConnection::systemBus(), this);
+	icdUiInterface = new QDBusInterface(ICD_UI_DBUS_SERVICE, ICD_UI_DBUS_PATH,
+			ICD_UI_DBUS_INTERFACE, QDBusConnection::systemBus(), this);
+
+	QDBusConnection::systemBus().connect(ICD_DBUS_SERVICE, ICD_DBUS_PATH,
+			ICD_DBUS_INTERFACE, "status_changed",
+			this, SLOT(statusChangedSlot(QString, QString, QString, QString) ));
+
+	//Watching for changes in the proxy settings
+	QString httpProxyDir = QString("/system/http_proxy");
+	if (!QGConfBackend::self()->connect(httpProxyDir, proxySettingsChanged))
+		qWarning() << "QMaemoICPrivate fails to watch for GConf changes in " << httpProxyDir; 
+
+}
+
+QMaemoICPrivate::~QMaemoICPrivate()
+{
+}
+
+bool QMaemoICPrivate::isAutoConnect()
+{
+	QString auto_connect = QGConfBackend::self()->getValue(
+			"/system/osso/connectivity/network_type/auto_connect").toString();
+	//qDebug() << "auto_connect:" << auto_connect;
+
+	int search_interval = QGConfBackend::self()->getValue(
+			"/system/osso/connectivity/network_type/search_interval").toInt();
+	//qDebug() << "search_interval:" << search_interval;
+
+	// Connect automatically:
+	// Always ask -> empty
+	// WLAN -> WLAN_INFRA
+	// Phone -> DUM_... etc.
+	// Any Connection -> *
+	if (auto_connect.isEmpty())
+		return false;
+
+	if (search_interval == 0)
+		return false;
+
+	return true;
+}
+
+bool QMaemoICPrivate::isConnected()
+{
+	//qDebug() << "isConnected() :" << connected;
+	if (connected == UNKNOWN)
+		checkConnectionStatus();
+	return connected;
+}
+
+void QMaemoICPrivate::connectionRequest()
+{
+	if (isConnected()) {
+		//qDebug() << "The device is already connected";
+		return;
+	}
+
+	if (!isAutoConnect()) {
+		//qDebug() << "The device should not auto connect";
+		return;
+	}
+
+	QDBusMessage reply;
+
+	//Check last used network
+	//NOTE: Chinook needs lastApName
+	const QString lastNetwork = lastAPid();
+	//qDebug() << "Last used network is " << lastNetwork;
+	
+	if (lastNetwork.isEmpty()) {
+		//Show the the Access point list to the user
+		reply = icdUiInterface->call(ICD_UI_SHOW_CONNDLG_REQ, false);
+	} else {
+		//Connect to the last Access Point used
+		//qDebug() << "Connecting to" << lastNetwork;
+		quint32 i = 0;
+		reply = icdInterface->call(ICD_CONNECT_REQ, lastNetwork, i);
+	}
+	
+	
+	if (reply.type() == QDBusMessage::ErrorMessage) {
+		readErrorDBusErrorMsg(reply);
+		if (!lastNetwork.isEmpty())
+			icdUiInterface->call(ICD_UI_SHOW_CONNDLG_REQ, false);
+		return;
+	}
+}
+
+bool QMaemoICPrivate::isHttpProxyUsed()
+{
+	if (connected != CONNECTED)
+		return false;
+	return QGConfBackend::self()->getValue("/system/http_proxy/use_http_proxy").toBool();
+}
+
+QString QMaemoICPrivate::currentAPName()
+{
+	if (connected != CONNECTED)
+		return QString();
+	QString gconfKey = iap;
+	gconfKey.prepend("/system/osso/connectivity/IAP/");
+	gconfKey.append("/name");
+	return QGConfBackend::self()->getValue(gconfKey).toString();
+}
+
+QString QMaemoICPrivate::lastAPName()
+{
+	QString gconfKey = lastAPid();
+	if (gconfKey.isEmpty())
+		return QString();
+	gconfKey.prepend("/system/osso/connectivity/IAP/");
+	gconfKey.append("/name");
+	return QGConfBackend::self()->getValue(gconfKey).toString();
+}
+
+QString QMaemoICPrivate::lastAPid()
+{
+	return QGConfBackend::self()->getValue("/system/osso/connectivity/IAP/last_used_network").toString();
+}
+
+//Called by the QGConfBackend instance when the proxy parameters change.
+void QMaemoICPrivate::proxySettingsChanged(QString& key, QVariant value)
+{
+	//qDebug() << "PROXY SETTINGS CHANGED" << key << value;
+	//emit qmic->proxySettingsChangedSig(key, value);
+}
+
+void QMaemoICPrivate::checkConnectionStatus()
+{
+	//qDebug() << "echeckConnectionStatus()";
+	QDBusMessage reply = icdInterface->call(ICD_GET_STATE_REQ);
+
+	if (reply.type() == QDBusMessage::ErrorMessage) {
+		readErrorDBusErrorMsg(reply);
+		connected = UNKNOWN;
+		return;
+	}
+
+	QList<QVariant> values;
+	values = reply.arguments();
+	//qDebug() << "reply arg size:" << values.size();
+#if 0
+	if (values.takeFirst().toInt()) {
+		connected = CONNECTED;
+	} else {
+		connected = DISCONNECTED;
+	}
+#else
+	connected = DISCONNECTED;
+	while (!values.isEmpty()) {
+		int n = values.takeFirst().toInt();
+		//qDebug() << "status:" << n;
+		if (n) {
+		//if (values.takeFirst().toInt()) {
+			connected = CONNECTED;
+			break;
+		}
+	}
+#endif
+	//qDebug() << "echeckConnectionStatus() done";
+}
+
+void QMaemoICPrivate::readErrorDBusErrorMsg(const QDBusMessage& msg)
+{
+	qWarning() << "QMaemoInternetConnectivity has received an error message." << endl
+			   << "Name: " << msg.errorName() << endl
+			   << "Message: " << msg.errorMessage();
+}
+
+void QMaemoICPrivate::statusChangedSlot(QString IAPname, QString networkType, QString state, QString errorCode)
+{
+	//qDebug() << "STATUS CHANGED" << IAPname << networkType << state << errorCode;
+
+	Q_UNUSED(networkType); //TODO
+
+	iap = IAPname;
+
+	if (!errorCode.isEmpty()) {
+		connected= UNKNOWN;
+		qWarning() << errorCode;
+	} else if (state == "CONNECTED") {
+		connected = CONNECTED;
+		//emit icStatusChanged();
+	} else if (state == "CONNECTING") {
+		connected = CONNECTING;
+	} else if (state == "IDLE" && errorCode.isEmpty()) {
+		connected = DISCONNECTED;
+		//emit icStatusChanged();
+	} else if (state == "DISCONNECTING") {
+		connected = DISCONNECTING;
+	}
+	//qDebug() << "CHECK connected=" << connected;
+}
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
diff --git a/src/network/maemo/qmaemointernetconnectivity.h b/src/network/maemo/qmaemointernetconnectivity.h
new file mode 100755
index 0000000..4ac0bdd
--- /dev/null
+++ b/src/network/maemo/qmaemointernetconnectivity.h
@@ -0,0 +1,69 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the unofficial Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtCore/qobject.h>
+
+#ifndef QMAEMOINTERNETCONNECTIVITY_H
+#define QMAEMOINTERNETCONNECTIVITY_H
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Network)
+
+class Q_NETWORK_EXPORT QMaemoInternetConnectivity
+{
+    public: 
+    static bool isConnected();
+    static QString currentAPName(); 
+    static void connectionRequest();
+    static bool isHttpProxyUsed();
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif //Q_WS_HILDON
+
+#endif //QMAEMOINTERNETCONNECTIVITY_H
diff --git a/src/network/maemo/qmaemointernetconnectivity_p.h b/src/network/maemo/qmaemointernetconnectivity_p.h
new file mode 100755
index 0000000..c5218a9
--- /dev/null
+++ b/src/network/maemo/qmaemointernetconnectivity_p.h
@@ -0,0 +1,111 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMAEMOINTERNETCONNECTIVITY_P_H
+#define QMAEMOINTERNETCONNECTIVITY_P_H
+
+#include "QtCore/qobject.h"
+#include "QtDBus/qdbusinterface.h"
+#include <QDebug>
+#include "qgconfbackend_p.h"
+
+#include <icd/osso-ic-dbus.h>
+#include <icd/osso-ic-ui-dbus.h>
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+class QMaemoICPrivate : public QObject
+{
+   Q_OBJECT
+
+   enum connectStatus {
+        UNKNOWN = -1,
+        DISCONNECTED = 0,
+        CONNECTED = 1,
+        DISCONNECTING = 2,
+        CONNECTING = 3
+        //SCAN_START
+        //SCAN_STOP
+   };
+
+public:
+    QMaemoICPrivate();
+    ~QMaemoICPrivate();
+	
+    bool isConnected();
+	bool isAutoConnect();
+    
+    //Show connection dialog.
+    void connectionRequest();
+
+    bool isHttpProxyUsed();
+    QString currentAPName();
+    QString lastAPName();
+
+    QString lastAPid();
+
+    //Called by the QGConfBackend instance when the proxy parameters change.
+    static void proxySettingsChanged(QString& key, QVariant value);
+
+private:
+    void checkConnectionStatus();
+    void readErrorDBusErrorMsg(const QDBusMessage& msg);
+
+private Q_SLOTS:
+    //Update the internal vars with the status_changed signals sent by the daemon via D-Bus
+    void statusChangedSlot(QString IAPname, QString networkType,
+			QString state, QString errorCode);
+
+private:
+   int connected;
+   QDBusInterface *icdInterface;
+   QDBusInterface *icdUiInterface;
+   QString iap; //Internet Access Point
+
+};
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
+#endif //QMAEMOINTERNETCONNECTIVITY_P_H
diff --git a/src/network/network.pro b/src/network/network.pro
index d476b56..2960f22 100644
--- a/src/network/network.pro
+++ b/src/network/network.pro
@@ -3,7 +3,7 @@
 TARGET   = QtNetwork
 QPRO_PWD = $$PWD
 DEFINES += QT_BUILD_NETWORK_LIB QT_NO_USING_NAMESPACE
-QT = core
+QT = core dbus
 win32-msvc*|win32-icc:QMAKE_LFLAGS += /BASE:0x64000000
 
 unix:QMAKE_PKGCONFIG_REQUIRES = QtCore
@@ -13,5 +13,6 @@ include(access/access.pri)
 include(kernel/kernel.pri)
 include(socket/socket.pri)
 include(ssl/ssl.pri)
+include(maemo/maemo.pri)
 
 QMAKE_LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/src/network/socket/qabstractsocket.cpp b/src/network/socket/qabstractsocket.cpp
index 8281990..4eb3584 100644
--- a/src/network/socket/qabstractsocket.cpp
+++ b/src/network/socket/qabstractsocket.cpp
@@ -355,6 +355,10 @@
 
 #include <time.h>
 
+#ifdef Q_WS_HILDON
+#include <maemo/qmaemointernetconnectivity.h>
+#endif
+
 #define Q_CHECK_SOCKETENGINE(returnValue) do { \
     if (!d->socketEngine) { \
         return returnValue; \
@@ -1292,6 +1296,10 @@ void QAbstractSocket::connectToHostImplementation(const QString &hostName, quint
         d->hostLookupId = -1;
     }
 
+#ifdef Q_WS_HILDON
+    QMaemoInternetConnectivity::connectionRequest();
+#endif
+
 #ifndef QT_NO_NETWORKPROXY
     // Get the proxy information
     d->resolveProxy(hostName, port);
diff --git a/src/src.pro b/src/src.pro
old mode 100644
new mode 100755
index f40c6ad..fe72e0b
--- a/src/src.pro
+++ b/src/src.pro
@@ -6,9 +6,10 @@ win32:SRC_SUBDIRS += src_winmain
 wince*:{
   SRC_SUBDIRS += src_corelib src_xml src_gui src_sql src_network src_script src_testlib
 } else {
-    SRC_SUBDIRS += src_tools_bootstrap src_tools_moc src_tools_rcc src_tools_uic src_corelib src_xml src_network src_gui src_sql src_script src_testlib
+    SRC_SUBDIRS += src_tools_bootstrap src_tools_moc src_tools_rcc src_tools_uic src_corelib src_xml 
+    contains(QT_CONFIG, dbus): SRC_SUBDIRS += src_dbus 
+    SRC_SUBDIRS += src_network src_gui src_sql src_script src_testlib
     contains(QT_CONFIG, qt3support): SRC_SUBDIRS += src_qt3support
-    contains(QT_CONFIG, dbus):SRC_SUBDIRS += src_dbus
     !cross_compile {
         contains(QT_CONFIG, qt3support): SRC_SUBDIRS += src_tools_uic3
     }
diff --git a/tools/designer/src/lib/shared/widgetfactory.cpp b/tools/designer/src/lib/shared/widgetfactory.cpp
index 6fabe18..37c7677 100644
--- a/tools/designer/src/lib/shared/widgetfactory.cpp
+++ b/tools/designer/src/lib/shared/widgetfactory.cpp
@@ -838,9 +838,11 @@ bool WidgetFactory::isPassiveInteractor(QWidget *widget)
         if (isTabBarInteractor(tabBar))
             m_lastWasAPassiveInteractor = true;
         return m_lastWasAPassiveInteractor;
-    }  else if (qobject_cast<QSizeGrip*>(widget))
+#ifndef QT_NO_SIZEGRIP
+    }  else if (qobject_cast<QSizeGrip*>(widget)) {
         return (m_lastWasAPassiveInteractor = true);
-     else if (qobject_cast<QMdiSubWindow*>(widget))
+#endif
+    }  else if (qobject_cast<QMdiSubWindow*>(widget))
         return (m_lastWasAPassiveInteractor = true);
     else if (qobject_cast<QAbstractButton*>(widget) && (qobject_cast<QTabBar*>(widget->parent()) || qobject_cast<QToolBox*>(widget->parent())))
         return (m_lastWasAPassiveInteractor = true);
