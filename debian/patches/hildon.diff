diff --git a/configure b/configure
index e58180a..3a38d8a 100755
--- a/configure
+++ b/configure
@@ -1932,6 +1932,9 @@ while [ "$#" -gt 0 ]; do
             UNKNOWN_OPT=yes
         fi
         ;;
+    hildon)
+        CFG_HILDON="yes"
+        ;;
     *)
         UNKNOWN_OPT=yes
         ;;
@@ -3073,8 +3076,8 @@ Usage:  $relconf [-h] [-prefix <dir>] [-prefix-install] [-bindir <dir>] [-libdir
         [-no-separate-debug-info] [-no-mmx] [-no-3dnow] [-no-sse] [-no-sse2]
         [-qtnamespace <namespace>] [-qtlibinfix <infix>] [-separate-debug-info] [-armfpa]
         [-no-optimized-qmake] [-optimized-qmake] [-no-xmlpatterns] [-xmlpatterns]
-        [-no-phonon] [-phonon] [-no-phonon-backend] [-phonon-backend]
-        [-no-openssl] [-openssl] [-openssl-linked]
+        [-no-phonon] [-phonon] [-no-phonon-backend] [-phonon-backend] [-hildon]
+	[-no-openssl] [-openssl] [-openssl-linked]
         [-no-gtkstyle] [-gtkstyle] [-no-svg] [-svg] [-no-webkit] [-webkit]
         [-no-scripttools] [-scripttools]
 
@@ -5071,6 +5074,27 @@ if [ "$PLATFORM_X11" = "yes" ]; then
     elif [ "$CFG_GLIB" = "no" ]; then
         CFG_QGTKSTYLE=no
     fi
+
+    if [ "$CFG_HILDON" == "yes" -a "$CFG_QGTKSTYLE" = "yes" ]; then
+        if [ -n "$PKG_CONFIG" ]; then
+            QT_CFLAGS_HILDON=`$PKG_CONFIG --cflags hildon-1 2>/dev/null`
+            #QT_LIBS_HILDON=`$PKG_CONFIG --libs gtk+-x11-2.0 hildon-1 2>/dev/null`
+            QMakeVar set QT_CFLAGS_HILDON "$QT_CFLAGS_HILDON"
+            #QMakeVar set QT_LIBS_HILDON "$QT_LIBS_HILDON"
+            #QMakeVar set styles "plastique gtk windows" #NO motif
+            # Add Hildon to config.h
+            QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_XIM Q_WS_HILDON Q_OS_FREMANTLE QT_NO_SIZEGRIP QT_NO_PRINTDIALOG QT_NO_PRINTER QT_NO_SYSTEMTRAYICON"
+        else
+            echo "Hildon support cannot be enabled due to functionality test!"
+            echo " Turn on verbose messaging (-v) to $0 to see the final report."
+            echo " If you believe this message is in error you may use the continue"
+            echo " switch (-continue) to $0 to continue."
+            exit 101
+        fi
+    else
+        CFG_HILDON="no"
+    fi
+
 fi # X11
 
 
@@ -6594,6 +6618,9 @@ else
     QT_CONFIG="$QT_CONFIG qt_framework"
     QTCONFIG_CONFIG="$QTCONFIG_CONFIG qt_framework"
 fi
+if [ "$CFG_HILDON" == "yes" -a "$CFG_QGTKSTYLE" = "yes" ]; then
+	    QT_CONFIG="$QT_CONFIG hildon"
+fi
 if [ "$PLATFORM_MAC" = "yes" ]; then
     QT_CONFIG="$QT_CONFIG $CFG_MAC_ARCHS"
 fi
@@ -6949,6 +6976,7 @@ if [ "$PLATFORM_X11" = "yes" ]; then
     echo "XKB Support ......... $CFG_XKB"
     echo "immodule support .... $CFG_IM"
     echo "GTK theme support ... $CFG_QGTKSTYLE"
+    echo "Hildon support  ..... $CFG_HILDON"
 fi
 [ "$CFG_SQL_mysql" != "no" ] && echo "MySQL support ....... $CFG_SQL_mysql"
 [ "$CFG_SQL_psql" != "no" ] && echo "PostgreSQL support .. $CFG_SQL_psql"
diff --git a/src/3rdparty/phonon/gstreamer/devicemanager.cpp b/src/3rdparty/phonon/gstreamer/devicemanager.cpp
index 2240396..35c0f54 100644
--- a/src/3rdparty/phonon/gstreamer/devicemanager.cpp
+++ b/src/3rdparty/phonon/gstreamer/devicemanager.cpp
@@ -163,6 +163,17 @@ GstElement *DeviceManager::createAudioSink(Category category)
     {
         if (m_audioSink == "auto") //this is the default value
         {
+#ifdef Q_OS_FREMANTLE
+            if (!sink) {
+                sink = gst_element_factory_make ("pulsesink", NULL);
+                if (canOpenDevice(sink))
+                    m_backend->logMessage("AudioOutput using pulse audio sink");
+                else if (sink) {
+                    gst_object_unref(sink);
+                    sink = 0;
+                }
+            }
+#endif
             //### TODO : get equivalent KDE settings here
 
             if (!qgetenv("GNOME_DESKTOP_SESSION_ID").isEmpty()) {
diff --git a/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp b/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp
index dae0be5..0f69d51 100644
--- a/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp
+++ b/src/3rdparty/webkit/WebCore/html/HTMLInputElement.cpp
@@ -243,7 +243,11 @@ void HTMLInputElement::aboutToUnload()
 
 bool HTMLInputElement::shouldUseInputMethod() const
 {
+#ifdef Q_WS_HILDON
+    return m_type == TEXT || m_type == SEARCH || m_type == ISINDEX || m_type == PASSWORD ;
+#else
     return m_type == TEXT || m_type == SEARCH || m_type == ISINDEX;
+#endif
 }
 
 void HTMLInputElement::dispatchFocusEvent()
diff --git a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
index 01b68eb..107e32e 100644
--- a/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
+++ b/src/3rdparty/webkit/WebKit/qt/Api/qwebpage.cpp
@@ -93,6 +93,10 @@
 #include "qwebnetworkinterface.h"
 #endif
 
+#ifdef Q_WS_HILDON
+#include <QInputContext>
+#endif
+
 using namespace WebCore;
 
 bool QWebPagePrivate::drtRun = false;
@@ -1009,6 +1013,18 @@ bool QWebPagePrivate::handleScrolling(QKeyEvent *ev)
 */
 QVariant QWebPage::inputMethodQuery(Qt::InputMethodQuery property) const
 {
+#ifdef Q_WS_HILDON
+    //Return input method query values only for input elements
+    Frame *frame = d->page->focusController()->focusedOrMainFrame();
+    if (!frame){
+         return QVariant();
+    }
+    Editor* editor = frame->editor();
+    if (!editor->canEdit()){
+        return QVariant();
+    }
+#endif	
+
     switch(property) {
     case Qt::ImMicroFocus: {
         Frame *frame = d->page->focusController()->focusedFrame();
@@ -1045,6 +1061,22 @@ QVariant QWebPage::inputMethodQuery(Qt::InputMethodQuery property) const
     }
     case Qt::ImCurrentSelection:
         return QVariant(selectedText());
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:{
+        int mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_DICTIONARY;
+        Frame *frame = d->page->focusController()->focusedFrame();
+        if (frame) {
+            Document *document = frame->document();
+            if (document) {
+                Element* element = static_cast<Element*>(document->focusedNode());
+                if (element && element->isPasswordField()) {
+                    mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_INVISIBLE;
+                }
+            }
+        }
+        return QVariant(mode);
+    }
+#endif
     default:
         return QVariant();
     }
diff --git a/src/corelib/global/qnamespace.h b/src/corelib/global/qnamespace.h
index 6a9df3a..c4907f5 100644
--- a/src/corelib/global/qnamespace.h
+++ b/src/corelib/global/qnamespace.h
@@ -264,8 +264,10 @@ public:
         SplashScreen = 0x0000000e | Window,
         Desktop = 0x00000010 | Window,
         SubWindow =  0x00000012,
-
-        WindowType_Mask = 0x000000ff,
+#ifdef Q_OS_FREMANTLE
+        HildonAppMenu = 0x0000014 | Window,
+#endif		
+	WindowType_Mask = 0x000000ff,
         MSWindowsFixedSizeDialogHint = 0x00000100,
         MSWindowsOwnDC = 0x00000200,
         X11BypassWindowManagerHint = 0x00000400,
@@ -1390,6 +1392,9 @@ public:
         ImFont,
         ImCursorPosition,
         ImSurroundingText,
+#ifdef Q_WS_HILDON
+	ImMode,
+#endif
         ImCurrentSelection
     };
 
diff --git a/src/gui/dialogs/qmessagebox.cpp b/src/gui/dialogs/qmessagebox.cpp
index b3522ce..ed25dc3 100644
--- a/src/gui/dialogs/qmessagebox.cpp
+++ b/src/gui/dialogs/qmessagebox.cpp
@@ -278,6 +278,8 @@ void QMessageBoxPrivate::updateSize()
 #elif defined(Q_OS_WINCE)
     // the width of the screen, less the window border.
     int hardLimit = screenSize.width() - (q->frameGeometry().width() - q->geometry().width());
+#elif defined(Q_WS_HILDON)
+    int hardLimit = screenSize.width() - (q->frameGeometry().width() - q->geometry().width());
 #else
     int hardLimit = qMin(screenSize.width() - 480, 1000); // can never get bigger than this
     // on small screens allows the messagebox be the same size as the screen
@@ -290,10 +292,12 @@ void QMessageBoxPrivate::updateSize()
     int softLimit = qMin(hardLimit, 500);
 #else
     // note: ideally on windows, hard and soft limits but it breaks compat
-#ifndef Q_OS_WINCE
-    int softLimit = qMin(screenSize.width()/2, 500);
-#else
+#ifdef Q_WS_HILDON
+    int softLimit = qMin(screenSize.width() * 2 / 3, 500);
+#elif Q_OS_WINCE
     int softLimit = qMin(screenSize.width() * 3 / 4, 500);
+#else
+    int softLimit = qMin(screenSize.width()/2, 500);
 #endif //Q_OS_WINCE
 #endif
 
diff --git a/src/gui/gui.pro b/src/gui/gui.pro
index f224e67..6089afc 100644
--- a/src/gui/gui.pro
+++ b/src/gui/gui.pro
@@ -31,6 +31,7 @@ include(itemviews/itemviews.pri)
 include(inputmethod/inputmethod.pri)
 include(graphicsview/graphicsview.pri)
 include(util/util.pri)
+include(maemo/maemo.pri)
 
 embedded: QT += network
 
diff --git a/src/gui/inputmethod/inputmethod.pri b/src/gui/inputmethod/inputmethod.pri
index d321cd4..0d2e09e 100644
--- a/src/gui/inputmethod/inputmethod.pri
+++ b/src/gui/inputmethod/inputmethod.pri
@@ -8,8 +8,11 @@ SOURCES +=inputmethod/qinputcontextfactory.cpp \
           inputmethod/qinputcontextplugin.cpp \
           inputmethod/qinputcontext.cpp
 x11 {
-    HEADERS += inputmethod/qximinputcontext_p.h
-    SOURCES += inputmethod/qximinputcontext_x11.cpp
+    HEADERS += inputmethod/qximinputcontext_p.h \
+               inputmethod/qhildoninputcontext_p.h \
+               inputmethod/qhildoninputmethodprotocol_p.h
+    SOURCES += inputmethod/qximinputcontext_x11.cpp \
+               inputmethod/qhildoninputcontext_x11.cpp
 }
 win32 {
     HEADERS += inputmethod/qwininputcontext_p.h
diff --git a/src/gui/inputmethod/qhildoninputcontext_p.h b/src/gui/inputmethod/qhildoninputcontext_p.h
new file mode 100644
index 0000000..d240c3e
--- /dev/null
+++ b/src/gui/inputmethod/qhildoninputcontext_p.h
@@ -0,0 +1,120 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+**
+** This file is part of the QtGui module of the Maemo Qt project.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QHILDONINPUTCONTEXT_P_H
+#define QHILDONINPUTCONTEXT_P_H
+
+#include "QtGui/qinputcontext.h"
+#include "qhildoninputmethodprotocol_p.h"
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_HEADER
+
+QT_MODULE(Gui)
+
+class QHildonInputContext : public QInputContext
+{
+    Q_OBJECT
+public:
+    explicit QHildonInputContext(QObject* parent = 0);
+    ~QHildonInputContext();
+
+    QString identifierName();
+    QString language();
+    void reset();
+    bool isComposing() const;
+    void setFocusWidget(QWidget *w);
+    bool eventFilter(QObject *obj, QEvent *event);
+    void update();
+
+protected:
+    void toggleHildonMainIMUi();
+    void timerEvent(QTimerEvent *);
+
+    //Filters
+    bool filterKeyPress(QWidget *w,QKeyEvent *ev);
+    bool x11FilterEvent(QWidget *keywidget, XEvent *event);
+
+private:
+    bool canUseIM(QWidget *w);
+    void insertUtf8(int flag, const QString& text);
+    void clearSelection();
+    void cancelPreedit();
+
+    void sendHildonCommand(HildonIMCommand cmd, QWidget *widget=0);
+    void sendX11Event(XEvent *event);
+    void showHIMMainUI();
+
+    //Context
+    void checkSentenceStart();
+    void commitPreeditData();
+    void checkCommitMode(); //### REMOVE?
+    void sendSurrounding(bool sendAllContents = false);
+    void sendSurroundingHeader(int offset);
+    void inputModeChanged();
+    void sendInputMode();
+    void setClientCursorLocation(int offsetIsRelative, int cursorOffset); //FIXME?? Move offsetIsRelative to Bool?
+    
+    //
+    void setMaskState(int *mask,
+                             HildonIMInternalModifierMask lock_mask,
+                             HildonIMInternalModifierMask sticky_mask,
+                             bool was_press_and_release);
+
+    //Vars
+    int timerId;
+    int mask;
+    int options;
+    HildonIMTrigger triggerMode;
+    HildonIMCommitMode commitMode, previousCommitMode;
+    int inputMode;
+    QString preEditBuffer;
+    QString surrounding;
+    int textCursorPosOnPress; //position of the cursor in the surrounding text at the last TabletPress event
+    bool autoUpper;
+    bool lastInternalChange;
+    bool spaceAfterCommit;
+};
+
+QT_END_HEADER
+
+#endif // Q_WS_HILDON
+
+#endif //QHILDONINPUTCONTEXT_P_H
diff --git a/src/gui/inputmethod/qhildoninputcontext_x11.cpp b/src/gui/inputmethod/qhildoninputcontext_x11.cpp
new file mode 100644
index 0000000..c560aa7
--- /dev/null
+++ b/src/gui/inputmethod/qhildoninputcontext_x11.cpp
@@ -0,0 +1,1783 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+**
+** This file is part of the QtGui module of the Maemo Qt project.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "qdebug.h"
+#include "qhildoninputcontext_p.h"
+#include "qpointer.h"
+#include "qapplication.h"
+#include "qclipboard.h"
+#include "qplaintextedit.h"
+#include "qlineedit.h"
+#include "qtextedit.h"
+#include "qtextbrowser.h"
+#include "kernel/qevent_p.h"       //QKeyEventEx
+#include "kernel/qapplication_p.h" //QApplicationPrivate::areXInputEventsUsed()
+#include "qinputcontext.h"
+
+#ifdef Q_WS_HILDON 
+
+#define GDK_ISO_ENTER  0xfe34
+#define COMPOSE_KEY    Qt::Key_Multi_key   // "Ch" key
+#define LEVEL_KEY      Qt::Key_AltGr       //"Fn" key
+
+#define LEVEL_KEY_MOD_MASK   0x4
+#define STATE_LEVEL_KEY_MASK 0x80
+
+#define STATE_CONTROL_MASK  1 << 2
+#define STATE_SHIFT_MASK    1 << 0 
+
+//Keyboard layout levels
+#define NUMERIC_LEVEL 2
+#define LOCKABLE_LEVEL 4
+
+#define PRESSURE_THRESHOLD  0.40
+
+/* TODO
+   - Cleaning up
+
+   Fremantle:
+   - Read Gconf (?) Settings for Auto-Capitalization, Word completion and insert space after word
+     Currently these are switched on.
+   - TRIGGER STYLUS is sent all the time, this prevent the usage of fullscreen virtual keyboard (Bug tracked, waiting for a tix)
+   - sendSurrounding when sendAllContents == true
+   - hildon banner integration to show the modifiers status (Sticky/Lock).
+   - put Q_OS_FREMANTLE in configure
+
+   Diablo
+   - Fix dead key support 
+*/
+
+extern bool qt_sendSpontaneousEvent(QObject*, QEvent*); //qapplication_x11.cpp
+
+#define LOGMESSAGE1(x) \
+    LOGMESSAGE3(x, "", "")
+
+#define LOGMESSAGE2(x, y) \
+    LOGMESSAGE3(x, y, "")
+
+#define LOGMESSAGE3(x, y, z) \
+    { \
+        QString logMessageString; \
+        QTextStream(&logMessageString) << x << "(" << y << " " << z << ")"; \
+        logMessage(logMessageString); \
+    } \
+    
+static void logMessage(const QString &message)
+{
+    static int debug = -1;
+    if (debug == -1)
+        debug = qgetenv("QT_HIM_DEBUG").isEmpty() ? 0 : 1;
+    
+    if (debug)
+        qDebug() << "HIM: " << message;    
+}
+
+/*!
+ * keysym to QString functions
+ * These functions are part of qkeymapper_x11.cpp
+ */
+static const unsigned short katakanaKeysymsToUnicode[] = {
+    0x0000, 0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1,
+    0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3,
+    0x30FC, 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD,
+    0x30AF, 0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD,
+    0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC,
+    0x30CD, 0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE,
+    0x30DF, 0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9,
+    0x30EA, 0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
+};
+
+static const unsigned short cyrillicKeysymsToUnicode[] = {
+    0x0000, 0x0452, 0x0453, 0x0451, 0x0454, 0x0455, 0x0456, 0x0457,
+    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x0000, 0x045e, 0x045f,
+    0x2116, 0x0402, 0x0403, 0x0401, 0x0404, 0x0405, 0x0406, 0x0407,
+    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x0000, 0x040e, 0x040f,
+    0x044e, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433,
+    0x0445, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e,
+    0x043f, 0x044f, 0x0440, 0x0441, 0x0442, 0x0443, 0x0436, 0x0432,
+    0x044c, 0x044b, 0x0437, 0x0448, 0x044d, 0x0449, 0x0447, 0x044a,
+    0x042e, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413,
+    0x0425, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e,
+    0x041f, 0x042f, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412,
+    0x042c, 0x042b, 0x0417, 0x0428, 0x042d, 0x0429, 0x0427, 0x042a
+};
+
+static const unsigned short greekKeysymsToUnicode[] = {
+    0x0000, 0x0386, 0x0388, 0x0389, 0x038a, 0x03aa, 0x0000, 0x038c,
+    0x038e, 0x03ab, 0x0000, 0x038f, 0x0000, 0x0000, 0x0385, 0x2015,
+    0x0000, 0x03ac, 0x03ad, 0x03ae, 0x03af, 0x03ca, 0x0390, 0x03cc,
+    0x03cd, 0x03cb, 0x03b0, 0x03ce, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
+    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,
+    0x03a0, 0x03a1, 0x03a3, 0x0000, 0x03a4, 0x03a5, 0x03a6, 0x03a7,
+    0x03a8, 0x03a9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
+    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
+    0x03c0, 0x03c1, 0x03c3, 0x03c2, 0x03c4, 0x03c5, 0x03c6, 0x03c7,
+    0x03c8, 0x03c9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short technicalKeysymsToUnicode[] = {
+    0x0000, 0x23B7, 0x250C, 0x2500, 0x2320, 0x2321, 0x2502, 0x23A1,
+    0x23A3, 0x23A4, 0x23A6, 0x239B, 0x239D, 0x239E, 0x23A0, 0x23A8,
+    0x23AC, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x2264, 0x2260, 0x2265, 0x222B,
+    0x2234, 0x221D, 0x221E, 0x0000, 0x0000, 0x2207, 0x0000, 0x0000,
+    0x223C, 0x2243, 0x0000, 0x0000, 0x0000, 0x21D4, 0x21D2, 0x2261,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x221A, 0x0000,
+    0x0000, 0x0000, 0x2282, 0x2283, 0x2229, 0x222A, 0x2227, 0x2228,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2202,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0192, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x2190, 0x2191, 0x2192, 0x2193, 0x0000
+};
+
+static const unsigned short specialKeysymsToUnicode[] = {
+    0x25C6, 0x2592, 0x2409, 0x240C, 0x240D, 0x240A, 0x0000, 0x0000,
+    0x2424, 0x240B, 0x2518, 0x2510, 0x250C, 0x2514, 0x253C, 0x23BA,
+    0x23BB, 0x2500, 0x23BC, 0x23BD, 0x251C, 0x2524, 0x2534, 0x252C,
+    0x2502, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short publishingKeysymsToUnicode[] = {
+    0x0000, 0x2003, 0x2002, 0x2004, 0x2005, 0x2007, 0x2008, 0x2009,
+    0x200a, 0x2014, 0x2013, 0x0000, 0x0000, 0x0000, 0x2026, 0x2025,
+    0x2153, 0x2154, 0x2155, 0x2156, 0x2157, 0x2158, 0x2159, 0x215a,
+    0x2105, 0x0000, 0x0000, 0x2012, 0x2329, 0x0000, 0x232a, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x215b, 0x215c, 0x215d, 0x215e, 0x0000,
+    0x0000, 0x2122, 0x2613, 0x0000, 0x25c1, 0x25b7, 0x25cb, 0x25af,
+    0x2018, 0x2019, 0x201c, 0x201d, 0x211e, 0x0000, 0x2032, 0x2033,
+    0x0000, 0x271d, 0x0000, 0x25ac, 0x25c0, 0x25b6, 0x25cf, 0x25ae,
+    0x25e6, 0x25ab, 0x25ad, 0x25b3, 0x25bd, 0x2606, 0x2022, 0x25aa,
+    0x25b2, 0x25bc, 0x261c, 0x261e, 0x2663, 0x2666, 0x2665, 0x0000,
+    0x2720, 0x2020, 0x2021, 0x2713, 0x2717, 0x266f, 0x266d, 0x2642,
+    0x2640, 0x260e, 0x2315, 0x2117, 0x2038, 0x201a, 0x201e, 0x0000
+};
+
+static const unsigned short aplKeysymsToUnicode[] = {
+    0x0000, 0x0000, 0x0000, 0x003c, 0x0000, 0x0000, 0x003e, 0x0000,
+    0x2228, 0x2227, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x00af, 0x0000, 0x22a5, 0x2229, 0x230a, 0x0000, 0x005f, 0x0000,
+    0x0000, 0x0000, 0x2218, 0x0000, 0x2395, 0x0000, 0x22a4, 0x25cb,
+    0x0000, 0x0000, 0x0000, 0x2308, 0x0000, 0x0000, 0x222a, 0x0000,
+    0x2283, 0x0000, 0x2282, 0x0000, 0x22a2, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x22a3, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short koreanKeysymsToUnicode[] = {
+    0x0000, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137,
+    0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f,
+    0x3140, 0x3141, 0x3142, 0x3143, 0x3144, 0x3145, 0x3146, 0x3147,
+    0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f,
+    0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157,
+    0x3158, 0x3159, 0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f,
+    0x3160, 0x3161, 0x3162, 0x3163, 0x11a8, 0x11a9, 0x11aa, 0x11ab,
+    0x11ac, 0x11ad, 0x11ae, 0x11af, 0x11b0, 0x11b1, 0x11b2, 0x11b3,
+    0x11b4, 0x11b5, 0x11b6, 0x11b7, 0x11b8, 0x11b9, 0x11ba, 0x11bb,
+    0x11bc, 0x11bd, 0x11be, 0x11bf, 0x11c0, 0x11c1, 0x11c2, 0x316d,
+    0x3171, 0x3178, 0x317f, 0x3181, 0x3184, 0x3186, 0x318d, 0x318e,
+    0x11eb, 0x11f0, 0x11f9, 0x0000, 0x0000, 0x0000, 0x0000, 0x20a9
+};
+
+static QChar keysymToUnicode(unsigned char byte3, unsigned char byte4)
+{
+    switch (byte3) {
+    case 0x04:
+        // katakana
+        if (byte4 > 0xa0 && byte4 < 0xe0)
+            return QChar(katakanaKeysymsToUnicode[byte4 - 0xa0]);
+        else if (byte4 == 0x7e)
+            return QChar(0x203e); // Overline
+        break;
+    case 0x06:
+        // russian, use lookup table
+        if (byte4 > 0xa0)
+            return QChar(cyrillicKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x07:
+        // greek
+        if (byte4 > 0xa0)
+            return QChar(greekKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x08:
+        // technical
+        if (byte4 > 0xa0)
+            return QChar(technicalKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x09:
+        // special
+        if (byte4 >= 0xe0)
+            return QChar(specialKeysymsToUnicode[byte4 - 0xe0]);
+        break;
+    case 0x0a:
+        // publishing
+        if (byte4 > 0xa0)
+            return QChar(publishingKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x0b:
+        // APL
+        if (byte4 > 0xa0)
+            return QChar(aplKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    case 0x0e:
+        // Korean
+        if (byte4 > 0xa0)
+            return QChar(koreanKeysymsToUnicode[byte4 - 0xa0]);
+        break;
+    default:
+        break;
+    }
+    return QChar(0x0);
+}
+
+static QString translateKeySym(KeySym keysym)
+{
+    if (!keysym) 
+        return QString();
+
+    // all keysyms smaller than 0xff00 are actally keys that can be mapped to unicode chars
+    extern QTextCodec *qt_input_mapper; // from qapplication_x11.cpp
+    QTextCodec *mapper = qt_input_mapper;
+    QChar converted;
+
+    QByteArray chars;
+    int count=0;
+
+    if (keysym < 0xff00) {
+        unsigned char byte3 = (unsigned char)(keysym >> 8);
+        int mib = -1;
+        switch(byte3) {
+        case 0: // Latin 1
+        case 1: // Latin 2
+        case 2: //latin 3
+        case 3: // latin4
+            mib = byte3 + 4; break;
+        case 5: // arabic
+            mib = 82; break;
+        case 12: // Hebrew
+            mib = 85; break;
+        case 13: // Thai
+            mib = 2259; break;
+        case 4: // kana
+        case 6: // cyrillic
+        case 7: // greek
+        case 8: // technical, no mapping here at the moment
+        case 9: // Special
+        case 10: // Publishing
+        case 11: // APL
+        case 14: // Korean, no mapping
+            mib = -1; // manual conversion
+            mapper = 0;
+            converted = keysymToUnicode(byte3, keysym & 0xff);
+        case 0x20:
+            // currency symbols
+            if (keysym >= 0x20a0 && keysym <= 0x20ac) {
+                mib = -1; // manual conversion
+                mapper = 0;
+                converted = (uint)keysym;
+            }
+            break;
+        default:
+            break;
+        }
+        if (mib != -1) {
+            mapper = QTextCodec::codecForMib(mib);
+            if (chars.isEmpty())
+                chars.resize(1);
+            chars[0] = (unsigned char) (keysym & 0xff); // get only the fourth bit for conversion later
+            count++;
+        }
+    } else if (keysym >= 0x1000000 && keysym <= 0x100ffff) {
+        converted = (ushort) (keysym - 0x1000000);
+        mapper = 0;
+    }
+    if (count < (int)chars.size()-1)
+        chars[count] = '\0';
+
+    QString text;
+    if (!mapper && converted.unicode() != 0x0) {
+        text = converted;
+    } else if (!chars.isEmpty()) {
+        // convert chars (8bit) to text (unicode).
+        if (mapper)
+            text = mapper->toUnicode(chars.data(), count, 0);
+        if (text.isEmpty()) {
+            // no mapper, or codec couldn't convert to unicode (this
+            // can happen when running in the C locale or with no LANG
+            // set). try converting from latin-1
+            text = QString::fromLatin1(chars);
+        }
+    }
+    return text;
+}
+
+/*! XkbLookupKeySym ( X11->display, event->nativeScanCode(), HILDON_IM_SHIFT_STICKY_MASK, &mods_rtrn, sym_rtrn)
+ */
+static QString translateKeycodeAndState(KeyCode key, uint state, quint32 &keysym){
+    uint mods;
+    KeySym *ks = reinterpret_cast<KeySym*>(&keysym);
+    if ( XkbLookupKeySym ( X11->display, key, state, &mods, ks) )
+        return translateKeySym(*ks);
+    else
+        return QString();
+}
+
+static Window findHildonIm()
+{
+    union
+    {
+        Window *win;
+        unsigned char *val;
+    } value;
+
+    Window result = 0;
+    ulong n = 0;
+    ulong extra = 0;
+    int format = 0;
+    Atom realType;
+
+    int status = XGetWindowProperty(X11->display, QX11Info::appRootWindow(),
+                    ATOM(_HILDON_IM_WINDOW), 0L, 4L, 0,
+                    XA_WINDOW, &realType, &format,
+                    &n, &extra, (unsigned char **) &value.val);
+
+    if (status == Success && realType == XA_WINDOW
+          && format == HILDON_IM_WINDOW_ID_FORMAT && n == 1 && value.win != 0) {
+        result = value.win[0];
+        XFree(value.val);
+    } else {
+        qWarning("QHildonInputContext: Unable to get the Hildon IM window id");
+    }
+
+    return result;
+}
+
+
+
+/*! Send a key event to the IM, which makes it available to the plugins
+ */
+static void sendKeyEvent(QWidget *widget, QEvent::Type type, uint state, uint keyval, quint16 keycode)
+{
+    int gdkEventType;
+    Window w = findHildonIm();
+
+    if (!w)
+        return;
+    
+    //Translate QEvent::Type in GDK_Event
+    switch (type){
+        case QEvent::KeyPress:
+            gdkEventType = 8;
+        break;
+        case QEvent::KeyRelease:
+            gdkEventType = 9;
+        break;
+        default:
+            qWarning("QHildonInputContext: Event type not allowed");
+            return;
+    }
+
+    XEvent ev;
+    memset(&ev, 0, sizeof(XEvent));
+
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = w;
+    ev.xclient.message_type = ATOM(_HILDON_IM_KEY_EVENT);
+    ev.xclient.format = HILDON_IM_KEY_EVENT_FORMAT; 
+ 
+    HildonIMKeyEventMessage *msg = reinterpret_cast<HildonIMKeyEventMessage *>(&ev.xclient.data);
+    msg->input_window = widget->winId();
+
+    msg->type = gdkEventType;
+    msg->state = state;
+    msg->keyval = keyval;
+    msg->hardware_keycode = keycode;
+
+    XSendEvent(X11->display, w, false, 0, &ev);
+    XSync( X11->display, false );
+}
+
+static quint32 dead_key_to_unicode_combining_character(int qtkeycode)
+{
+  quint32 combining; //Unicode Hex value
+
+#if 0
+  //TODO Diablo - Not required in Fremantle
+  switch (qtkeycode)
+  {
+    case Qt::Key_Dead_Grave:            combining = 0x0300; break;
+    case Qt::Key_Dead_Acute:            combining = 0x0301; break;
+    case Qt::Key_Dead_Circumflex:       combining = 0x0302; break;
+    case Qt::Key_Dead_Tilde:            combining = 0x0303; break;
+    case Qt::Key_Dead_Macron:           combining = 0x0304; break;
+    case Qt::Key_Dead_Breve:            combining = 0x032e; break;
+    case Qt::Key_Dead_Abovedot:         combining = 0x0307; break;
+    case Qt::Key_Dead_Diaeresis:        combining = 0x0308; break;
+    case Qt::Key_Dead_Abovering:        combining = 0x030a; break;
+    case Qt::Key_Dead_Doubleacute:      combining = 0x030b; break;
+    case Qt::Key_Dead_Caron:            combining = 0x030c; break;
+    case Qt::Key_Dead_Cedilla:          combining = 0x0327; break;
+    case Qt::Key_Dead_Ogonek:           combining = 0x0328; break;
+    case Qt::Key_Dead_Iota:             combining = 0; break; /* Cannot be combined */
+    case Qt::Key_Dead_Voiced_Sound:     combining = 0; break; /* Cannot be combined */
+    case Qt::Key_Dead_Semivoiced_Sound: combining = 0; break; /* Cannot be combined */
+    case Qt::Key_Dead_Belowdot:         combining = 0x0323; break;
+    case Qt::Key_Dead_Hook:             combining = 0x0309; break;
+    case Qt::Key_Dead_Horn:             combining = 0x031b; break;
+    default: combining = 0; break; /* Unknown dead key */
+  }
+#endif
+
+  return combining;
+}
+
+/*! Sends the key as a spontaneous event.
+ */
+static void sendKey(QWidget *keywidget, int qtCode)
+{
+    QPointer<QWidget> guard = keywidget;
+
+    KeySym keysym = NoSymbol;
+    int keycode;
+
+    switch (qtCode){
+        case Qt::Key_Enter:
+            keycode = 36;
+        break;
+        case Qt::Key_Tab:
+            keycode = 66;
+        break;
+        case Qt::Key_Backspace:
+            keycode = 22;
+        break;
+        default: 
+        qWarning("keycode not allowed");
+        return;
+    }
+
+    keysym = XKeycodeToKeysym(X11->display, keycode, 0);
+
+    QKeyEventEx click(QEvent::KeyPress, qtCode, Qt::NoModifier , QString(), false, 1, keycode, keysym, 0);
+    qt_sendSpontaneousEvent(keywidget, &click);
+
+    // in case the widget was destroyed when the key went down
+    if (guard.isNull()){
+        return;
+    }
+
+    QKeyEventEx release(QEvent::KeyRelease, qtCode, Qt::NoModifier , QString(), false, 1, keycode, keysym, 0);
+    qt_sendSpontaneousEvent(keywidget, &release);
+}
+
+/*!
+ */
+static void answerClipboardSelectionQuery(QWidget *widget)
+{
+    bool hasSelection = !widget->inputMethodQuery(Qt::ImCurrentSelection).toString().isEmpty();
+
+    XEvent xev;
+    Window w = findHildonIm();
+
+    memset(&xev, 0, sizeof(xev));
+    xev.xclient.type = ClientMessage;
+    xev.xclient.window = w;
+    xev.xclient.message_type = ATOM(_HILDON_IM_CLIPBOARD_SELECTION_REPLY);
+    xev.xclient.format = HILDON_IM_CLIPBOARD_SELECTION_REPLY_FORMAT;
+    xev.xclient.data.l[0] = hasSelection;
+
+    XSendEvent(X11->display, w, false, 0, &xev);
+}
+
+const char *getNextPacketStart(const char *str)
+{
+    const char *candidate, *good;
+
+    candidate = good = str;
+
+    while (*candidate != 0) {
+        ++candidate;
+        if (candidate - str >= HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE)
+            return good;
+        good = candidate;
+    }
+
+    /* The whole string is small enough */
+    return candidate;
+}
+
+KeySym getKeySymForLevel(int keycode, int level ){
+    XkbDescPtr xkbDesc = XkbGetMap(X11->display, XkbAllClientInfoMask, XkbUseCoreKbd);
+    KeySym keySym = XkbKeySymEntry(xkbDesc, keycode, level, 0);
+
+    //Check for a not repated keysym
+    KeySym keySymTest = XkbKeySymEntry(xkbDesc, keycode, 0, 1);
+    if (keySym == keySymTest)
+        return NoSymbol;
+
+    return keySym;    
+}
+
+QHildonInputContext::QHildonInputContext(QObject* parent)
+    : QInputContext(parent),
+      timerId(-1),
+      mask(0), 
+      triggerMode(HILDON_IM_TRIGGER_NONE),
+      commitMode(HILDON_IM_COMMIT_REDIRECT),
+      inputMode(HILDON_GTK_INPUT_MODE_FULL),
+      lastInternalChange(false),
+      spaceAfterCommit(false)
+{
+}
+
+QHildonInputContext::~QHildonInputContext()
+{
+    sendHildonCommand(HILDON_IM_HIDE);
+}
+
+QString QHildonInputContext::identifierName()
+{
+    return QLatin1String("hildon");
+}
+
+QString QHildonInputContext::language()
+{
+    //TODO GConf /apps/osso/inputmethod/hildon-im-languages
+    return QString();
+}
+
+/*!reset the UI state 
+ */
+void QHildonInputContext::reset()
+{
+    LOGMESSAGE3 ("reset", focusWidget(), QApplication::focusWidget());
+
+    QPointer<QWidget> oldFocus= focusWidget();
+    
+    if (oldFocus && QApplication::focusWidget() != oldFocus){
+        oldFocus->removeEventFilter(oldFocus->inputContext());
+        sendHildonCommand(HILDON_IM_CLEAR, oldFocus);
+    }
+
+    cancelPreedit();
+
+    //Reset internals
+    mask = 0;
+    lastInternalChange = false;
+}
+
+bool QHildonInputContext::isComposing() const
+{
+    return false;
+}
+
+void QHildonInputContext::setFocusWidget(QWidget *w)
+{
+    if (!w)
+        return;
+
+    w->installEventFilter(this);
+    QInputContext::setFocusWidget(w);
+    sendHildonCommand(HILDON_IM_SETCLIENT, w);    
+}
+
+bool QHildonInputContext::eventFilter(QObject *obj, QEvent *event)
+{
+    QWidget *w = static_cast<QWidget*>(obj);
+    if (w) 
+        QObject::eventFilter(obj, event);
+
+    switch (event->type()){
+    case QEvent::MouseButtonRelease:{
+        //On the device, these events are sent at the same time of the TabletRelease ones
+        if (QApplicationPrivate::areXInputEventsUsed()) break;
+
+        //Emulate Finger poke in scratchbox
+        QMouseEvent *me = static_cast<QMouseEvent*>(event);
+#ifndef Q_OS_FREMANTLE	
+        if (me->button() == Qt::MidButton)
+            triggerMode = HILDON_IM_TRIGGER_FINGER;
+        else
+            triggerMode = HILDON_IM_TRIGGER_STYLUS;
+#else
+        triggerMode = HILDON_IM_TRIGGER_FINGER;
+#endif
+        inputMode = w->inputMethodQuery(Qt::ImMode).toInt();
+        toggleHildonMainIMUi(); //showHIMMainUI();
+        break;
+    }
+
+#ifndef Q_OS_FREMANTLE
+    case QEvent::TabletPress:{
+        textCursorPosOnPress = -1;
+        break;
+    }
+    case QEvent::TabletMove:{
+        //Moving the finger generate more than 1 TabletMove event
+        if ( textCursorPosOnPress == -1){
+            textCursorPosOnPress = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+        }
+        break;
+    }
+    case QEvent::TabletRelease:{
+        QTabletEvent *te = static_cast<QTabletEvent*>(event);
+
+        //No HIM if there are popup widgets.
+        if (QApplication::activePopupWidget()){ 
+            break;
+        }
+
+
+        if (te->pressure() >= PRESSURE_THRESHOLD){
+            triggerMode = HILDON_IM_TRIGGER_FINGER;
+        }else{
+            triggerMode = HILDON_IM_TRIGGER_STYLUS;    
+        }
+
+        triggerMode = HILDON_IM_TRIGGER_FINGER;
+
+        inputMode = w->inputMethodQuery(Qt::ImMode).toInt();
+        toggleHildonMainIMUi();
+        showHIMMainUI();
+        break;
+    }
+#endif
+
+    case QEvent::KeyPress:
+    case QEvent::KeyRelease:{
+        triggerMode = HILDON_IM_TRIGGER_KEYBOARD;
+        return filterKeyPress(static_cast<QWidget*>(obj), 
+                              static_cast<QKeyEvent*>(event));
+    }
+    default:
+        //Remove compile warning
+        break;
+    }
+    return QObject::eventFilter(obj, event);
+}
+
+//TODO
+void QHildonInputContext::update()
+{
+    LOGMESSAGE1("update");
+
+    if (lastInternalChange) {
+        //Autocase update
+        checkSentenceStart();
+        lastInternalChange = false;
+    }
+}
+
+/*!  Shows/hides the Hildon Main Input Method Ui Window
+ */
+void QHildonInputContext::toggleHildonMainIMUi()
+{
+    LOGMESSAGE1("toggleHildonMainIMUi");
+
+    QPointer<QWidget> w = focusWidget();
+    if (!w)
+        return;
+     
+    if (!canUseIM(w) || !w->inputMethodQuery(Qt::ImCurrentSelection).toString().isEmpty() ){
+        sendHildonCommand(HILDON_IM_HIDE);
+        return;
+    }
+
+     sendHildonCommand(HILDON_IM_SETCLIENT,w);
+     if (timerId != -1){
+         killTimer(timerId);
+     }
+     timerId = startTimer(HILDON_IM_DEFAULT_LAUNCH_DELAY);
+}
+
+/*! Shows the IM after a timeout.
+ *  GTK implementation use this to improve the possibility
+ *  to distinguish a finger poke.
+ */
+void QHildonInputContext::timerEvent(QTimerEvent *ev)
+{
+    if (ev->timerId() != timerId){
+        return;
+    }
+    killTimer(timerId);
+
+    if (QWidget *w = QApplication::focusWidget()){
+        sendHildonCommand(HILDON_IM_SETNSHOW,w);
+    }
+}
+
+/*! Filters spontaneous keyevents then elaborates them and updates the Hildon Main UI
+ *  via XMessages. In some cases it creates and posts a new keyevent
+ *  as no spontaneous event.
+ */
+bool QHildonInputContext::filterKeyPress(QWidget *keywidget,QKeyEvent *event){
+    
+    if (!canUseIM(keywidget))
+        return false;
+
+    //Avoid to filter events generated by this function.
+    if (!event->spontaneous())
+        return false;
+
+    const quint32 state = event->nativeModifiers();
+    const quint32 keycode = event->nativeScanCode();
+    quint32 keysym= event->nativeVirtualKey();
+    const int qtkeycode = event->key();
+
+    QString debug;
+    debug = QString(" Mask:0x%1 state:0x%2 keycode:%3 keysym:0x%4 QtKey:0x%5 ").arg(mask,0,16)
+                                                                               .arg(state,0,16)
+                                                                               .arg(keycode)
+                                                                               .arg(keysym,0,16)
+                                                                               .arg(qtkeycode,0,16);
+    LOGMESSAGE2("filterKeyPress", debug);
+
+    //Drop auto repeated keys for COMPOSE_KEY
+    if (qtkeycode == COMPOSE_KEY && event->isAutoRepeat()){
+        return true;
+    }
+
+    //TODO MOVE
+    static QWidget* lastKeywidget = 0;
+    static int lastQtkeycode = 0;
+    static qint32 combiningChar = 0; //Unicode rappresentation of the dead key.
+
+    QString commitString; //String to commit to the Key Widget
+ 
+    lastKeywidget = keywidget;
+    //Reset static vars when the widget change.
+    if (keywidget != lastKeywidget){
+        mask = 0;
+        lastKeywidget = 0;
+        lastQtkeycode = 0;
+        combiningChar = 0;
+    }
+
+    if (!qtkeycode)
+        return true;
+
+    //1. A dead key will not be immediately commited, but combined with the next key
+    if (qtkeycode >= Qt::Key_Dead_Grave && qtkeycode <= Qt::Key_Dead_Horn)
+        mask |= HILDON_IM_DEAD_KEY_MASK;
+    else
+        mask &= ~HILDON_IM_DEAD_KEY_MASK;
+
+    if (mask & HILDON_IM_DEAD_KEY_MASK && combiningChar == 0)
+    {        
+        combiningChar = dead_key_to_unicode_combining_character(qtkeycode);//### WORKS? IMPROVE?
+        return true;
+    }
+
+    /*2. Pressing any key while the compose key is pressed will keep that
+     *   character from being directly submitted to the application. This
+     *   allows the IM process to override the interpretation of the key 
+     */
+    if (qtkeycode == COMPOSE_KEY)
+    {
+        if (event->type() == QEvent::KeyPress)
+            mask |= HILDON_IM_COMPOSE_MASK;
+        else
+            mask &= ~HILDON_IM_COMPOSE_MASK;
+    }
+
+    // 3 Sticky and locking keys initialization
+    if (event->type() == QEvent::KeyRelease)
+    {
+        if (qtkeycode == Qt::Key_Shift )
+        {
+            setMaskState(&mask,
+                         HILDON_IM_SHIFT_LOCK_MASK,
+                         HILDON_IM_SHIFT_STICKY_MASK,
+                         lastQtkeycode == Qt::Key_Shift);
+        }else if (event->key() == LEVEL_KEY){
+            setMaskState(&mask,
+                         HILDON_IM_LEVEL_LOCK_MASK,
+                         HILDON_IM_LEVEL_STICKY_MASK,
+                         lastQtkeycode == LEVEL_KEY);
+        }
+    }
+
+    //Update lastQtkeycode.
+    lastQtkeycode=qtkeycode;
+
+    if (qtkeycode == Qt::Key_Return || qtkeycode == Qt::Key_Enter || keysym == GDK_ISO_ENTER) {
+        //Remove autocompletation text
+        if (event->type() == QEvent::KeyPress &&
+            previousCommitMode == HILDON_IM_COMMIT_PREEDIT &&
+            !preEditBuffer.isNull()) {
+                preEditBuffer.clear();
+                QInputMethodEvent e;
+                sendEvent(e);
+        }
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+        lastInternalChange = true;
+        return false;
+    }else if (qtkeycode == Qt::Key_Tab){
+        commitString = QString("\t");
+    }
+
+    /* 5. When the level key is in sticky or locked state, translate the
+     *    keyboard state as if that level key was being held down.
+     */
+    if ((mask & (HILDON_IM_LEVEL_STICKY_MASK | HILDON_IM_LEVEL_LOCK_MASK)) || 
+           state == LEVEL_KEY_MOD_MASK)
+    {
+        commitString = translateKeycodeAndState(keycode, STATE_LEVEL_KEY_MASK, keysym);
+    }
+   
+    /* If the input mode is strictly numeric and the digits are level
+     *  shifted on the layout, it's not necessary for the level key to
+     *  be pressed at all. 
+     */
+    else if (options & HILDON_IM_AUTOLEVEL_NUMERIC &&
+                (inputMode & HILDON_GTK_INPUT_MODE_FULL) == HILDON_GTK_INPUT_MODE_NUMERIC)
+    {
+        KeySym ks = getKeySymForLevel(keycode, NUMERIC_LEVEL); 
+        QString string = translateKeySym(ks);
+
+        if (!string.isEmpty()){
+            keysym = ks;
+            commitString = string;
+        }
+    }
+    /* The input is forced to a predetermined level 
+     */
+    else if (options & HILDON_IM_LOCK_LEVEL)
+    {
+        KeySym ks = getKeySymForLevel(keycode, LOCKABLE_LEVEL); 
+        QString string = translateKeySym(ks);
+
+        if (!string.isEmpty()){
+            keysym = ks;
+            commitString = string;
+        }
+    } 
+    /* Hardware keyboard autocapitalization  */
+    if (autoUpper && inputMode & HILDON_GTK_INPUT_MODE_AUTOCAP)
+    {
+        QChar currentChar;
+        KeySym lower = NoSymbol;
+        KeySym upper = NoSymbol;
+
+        if (commitString.isEmpty()){
+            QString ks = translateKeySym(keysym);
+            if (!ks.isEmpty())
+                currentChar = ks.at(0);
+        }else{
+            currentChar = commitString.at(0);
+        }
+
+        XConvertCase(keysym, &lower, &upper);
+
+        if (currentChar.isPrint()){
+            if (state & STATE_SHIFT_MASK){
+                currentChar = currentChar.toLower();
+                keysym = lower;
+            } else {
+                currentChar = currentChar.toUpper();
+                keysym = upper;
+            }
+            commitString = QString(currentChar); //sent to the widget
+        }
+    }
+
+    //6. Shift lock or holding the shift down forces uppercase, ignoring autocap
+    if (mask & HILDON_IM_SHIFT_LOCK_MASK || state & STATE_SHIFT_MASK)
+    {
+        KeySym lower = NoSymbol;
+        KeySym upper = NoSymbol;
+        XConvertCase(keysym, &lower, &upper);
+        QString tempStr = translateKeySym(upper);
+        if (!tempStr.isEmpty())
+            commitString = tempStr.at(0);
+    }else if (mask & HILDON_IM_SHIFT_STICKY_MASK){
+        KeySym lower = NoSymbol;
+        KeySym upper = NoSymbol;
+        QString tempStr = translateKeySym(keysym);
+        QChar currentChar;
+        if (!tempStr.isEmpty()){
+          currentChar = tempStr.at(0);
+        
+            /* Simulate shift key being held down in sticky state for non-printables  */
+            if ( currentChar.isPrint() ){
+                /*  For printable characters sticky shift negates the case,
+                 *  including any autocapitalization changes 
+                 */
+                if ( currentChar.isUpper() ){
+                    currentChar = currentChar.toLower();
+                    lower = lower;
+                }else{
+                    currentChar = currentChar.toUpper();
+                    upper = upper;
+                }
+                commitString = QString(currentChar); //sent to the widget  
+            }
+        }
+    }
+    
+    //F. word completion manipulation (for fremantle)
+    if (event->type() == QEvent::KeyPress &&
+        previousCommitMode == HILDON_IM_COMMIT_PREEDIT &&
+        !preEditBuffer.isNull())
+    {
+        switch (qtkeycode){
+            case Qt::Key_Right:{
+                //TODO Move this code in commitPreeditData();
+                QInputMethodEvent e;
+
+                if (spaceAfterCommit)
+                    e.setCommitString(preEditBuffer + ' ');
+                else
+                    e.setCommitString(preEditBuffer);
+
+                sendEvent(e);
+                preEditBuffer.clear();
+                return true;
+            }
+            case Qt::Key_Backspace:
+            case Qt::Key_Up:
+            case Qt::Key_Down:
+            case Qt::Key_Left:{
+                //TODO Move this code
+                preEditBuffer.clear();
+                QInputMethodEvent e;
+                sendEvent(e);
+                return true;
+           }
+        } 
+    }
+
+    //7. Sticky and lock state reset
+    if (event->type() == QEvent::KeyPress)
+    {
+        if (qtkeycode != Qt::Key_Shift )
+        {
+            /* If not locked, pressing any character resets shift state */
+            if ((mask & HILDON_IM_SHIFT_LOCK_MASK) == 0)
+            {
+                mask &= ~HILDON_IM_SHIFT_STICKY_MASK;
+            }
+        }
+        if (qtkeycode != LEVEL_KEY)
+        {
+            /* If not locked, pressing any character resets level state */
+            if ((mask & HILDON_IM_LEVEL_LOCK_MASK) == 0)
+            {
+                mask &= ~HILDON_IM_LEVEL_STICKY_MASK;
+            }
+        }
+    }
+
+    if (event->type() == QEvent::KeyRelease || state & STATE_CONTROL_MASK)
+    {
+        QString debug;
+        debug = QString("Sending state=0x%1 keysym=0x%2 keycode=%3").arg(state,0,16).arg(keysym,0,16).arg(keycode);
+        LOGMESSAGE2(" - ", debug);
+
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+        return false;
+    }
+ 
+     
+    /* 8. Pressing a dead key twice, or if followed by a space, inputs
+     *    the dead key's character representation 
+     */
+    if ((mask & HILDON_IM_DEAD_KEY_MASK || qtkeycode == Qt::Key_Space) && combiningChar)
+    {
+        qint32 last;
+        last = dead_key_to_unicode_combining_character (qtkeycode);
+        if ((last == combiningChar) || qtkeycode == Qt::Key_Space)
+        {
+            commitString = QString(combiningChar);
+        }else{
+            commitString = QString::fromUtf8(XKeysymToString(keysym));
+        }
+        combiningChar = 0;
+    }else{
+        /* Regular keypress */
+        if (mask & HILDON_IM_COMPOSE_MASK)
+        {
+            sendKeyEvent(keywidget, event->type(),state, keysym, keycode);
+            return true;
+        }else{
+            if ( commitString.isEmpty() && qtkeycode != Qt::Key_Backspace){
+                LOGMESSAGE3(" - ", "text sent to IM", event->text())
+                commitString = QString(event->text());
+            }
+        }
+   }
+    
+    if ( !commitString.isEmpty() ){
+        //entering a new character cleans the preedit buffer
+        preEditBuffer.clear();
+        QInputMethodEvent e;
+        sendEvent(e);
+
+        /* Pressing a dead key followed by a regular key combines to form
+         * an accented character
+         */
+        if (combiningChar){ //FIXME
+            commitString.append(combiningChar);//This will be sent to the widget
+            const char *charStr = qPrintable(commitString);
+            keysym = XStringToKeysym(charStr); //This will be sent to the IM
+        }
+
+        //Create the new event with the elaborate information,
+        //then it adds the event to the events queue
+        {
+            QEvent::Type type = event->type();
+            Qt::KeyboardModifiers modifiers= event->modifiers();
+            //WARNING the qt keycode has not been updated!!
+            QKeyEventEx *ke= new QKeyEventEx(type, keycode, modifiers, commitString, false, commitString.size(), keycode, keysym, state);
+            QCoreApplication::postEvent(keywidget,ke);
+        }
+
+        //Send the new keysym 
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+#if 0
+        /* Non-printable characters invalidate any previous dead keys */
+        if (qtkeycode != Qt::Key_Shift)
+            combiningChar=0;
+#endif
+        lastInternalChange = true;
+        return true;
+    }else{
+        //Send the new keysym 
+        sendKeyEvent(keywidget, event->type(), state, keysym, keycode);
+        if (qtkeycode == Qt::Key_Backspace){
+            lastInternalChange = true; 
+        }
+
+        return false; 
+    }
+}
+
+/*! Filters the XClientMessages sent by QApplication_x11
+ */
+bool QHildonInputContext::x11FilterEvent(QWidget *keywidget, XEvent *event)
+{
+    LOGMESSAGE3("x11FilterEvent", keywidget, event);
+
+    if (event->xclient.message_type == ATOM(_HILDON_IM_INSERT_UTF8)
+            && event->xclient.format == HILDON_IM_INSERT_UTF8_FORMAT) {
+        HildonIMInsertUtf8Message *msg = (HildonIMInsertUtf8Message *)&event->xclient.data;
+        insertUtf8(msg->msg_flag, QString::fromUtf8(msg->utf8_str));
+        return true;
+
+    }else if (event->xclient.message_type == ATOM(_HILDON_IM_COM)) {
+        HildonIMComMessage *msg = (HildonIMComMessage *)&event->xclient.data;
+        options = msg->options;
+   
+        LOGMESSAGE3 (" - ", "Options=", options)
+
+        switch (msg->type) {
+        //Handle Keys msgs
+        case HILDON_IM_CONTEXT_HANDLE_ENTER: {
+            sendKey(keywidget, Qt::Key_Enter);
+            return true; }
+        case HILDON_IM_CONTEXT_HANDLE_TAB: {
+            sendKey(keywidget, Qt::Key_Tab);
+            return true; }
+        case HILDON_IM_CONTEXT_HANDLE_BACKSPACE: {
+            sendKey(keywidget, Qt::Key_Backspace);
+            return true; }
+        case HILDON_IM_CONTEXT_HANDLE_SPACE: {
+            insertUtf8(HILDON_IM_MSG_CONTINUE, QChar(Qt::Key_Space));
+            commitPreeditData();
+            return true; }
+
+        //Handle Clipboard msgs
+        case HILDON_IM_CONTEXT_CLIPBOARD_SELECTION_QUERY: {
+            answerClipboardSelectionQuery(keywidget);
+            return true; }
+        case HILDON_IM_CONTEXT_CLIPBOARD_PASTE:
+            if (QClipboard *clipboard = QApplication::clipboard()){
+                QInputMethodEvent e;
+                e.setCommitString(clipboard->text());
+                sendEvent(e);
+            }
+            return true;
+        case HILDON_IM_CONTEXT_CLIPBOARD_COPY: {
+            if (QClipboard *clipboard = QApplication::clipboard())
+                clipboard->setText(keywidget->inputMethodQuery(Qt::ImCurrentSelection).toString());
+            return true; }
+        case HILDON_IM_CONTEXT_CLIPBOARD_CUT: {
+            if (QClipboard *clipboard = QApplication::clipboard())
+                clipboard->setText(keywidget->inputMethodQuery(Qt::ImCurrentSelection).toString());
+            QInputMethodEvent ev;
+            sendEvent(ev);
+            return true; }
+
+        //Handle commit mode msgs
+        case HILDON_IM_CONTEXT_DIRECT_MODE: { //default mode
+            LOGMESSAGE3 (" - ", "Commit Mode=", "Direct")
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_DIRECT;
+            return true; }
+        case HILDON_IM_CONTEXT_BUFFERED_MODE: {
+            LOGMESSAGE3 (" - ", "Commit Mode=", "Buffered")
+            if (commitMode != HILDON_IM_COMMIT_BUFFERED){
+                preEditBuffer = QString("");
+                commitMode = HILDON_IM_COMMIT_BUFFERED;
+            }
+            return true; }
+        case HILDON_IM_CONTEXT_REDIRECT_MODE: {
+            LOGMESSAGE3 (" - ", "Commit Mode=", "Redirect")
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_REDIRECT;
+            checkCommitMode();
+            clearSelection();
+            return true; }
+        case HILDON_IM_CONTEXT_SURROUNDING_MODE: {
+            LOGMESSAGE3 (" - ", "Commit Mode=", "Surrounding")
+            preEditBuffer.clear();
+            commitMode = HILDON_IM_COMMIT_SURROUNDING;
+            return true; }
+
+        //Handle context
+        case HILDON_IM_CONTEXT_CONFIRM_SENTENCE_START: {
+            LOGMESSAGE2(" - ", "XMessage: Sentence start")
+            checkSentenceStart();
+            return true; }
+        case HILDON_IM_CONTEXT_FLUSH_PREEDIT: {
+            LOGMESSAGE2(" - ", "XMessage: Flush preedit")
+            commitPreeditData();
+            return true; }
+        case HILDON_IM_CONTEXT_REQUEST_SURROUNDING: {
+            LOGMESSAGE2(" - ", "XMessage: Request surrounding")
+            checkCommitMode();
+            sendSurrounding();
+            //if (self->is_url_entry)
+            //  hildon_im_context_send_command(self, HILDON_IM_SELECT_ALL);
+            return true; }
+        case HILDON_IM_CONTEXT_OPTION_CHANGED: {
+            //Nothing to do
+            return true; }
+        case HILDON_IM_CONTEXT_CLEAR_STICKY: {
+            mask &= ~(HILDON_IM_SHIFT_STICKY_MASK |
+                      HILDON_IM_SHIFT_LOCK_MASK |
+                      HILDON_IM_LEVEL_STICKY_MASK |
+                      HILDON_IM_LEVEL_LOCK_MASK);
+            return true; }
+
+        //Unused 
+        case HILDON_IM_CONTEXT_NUM_COM: {
+            return true; }
+        case HILDON_IM_CONTEXT_ENTER_ON_FOCUS: {
+            return true; }
+        case HILDON_IM_CONTEXT_WIDGET_CHANGED: {
+            //Do we really need to set the mask=0? See reset();
+            return true; }
+        
+#ifdef Q_OS_FREMANTLE
+        case HILDON_IM_CONTEXT_CANCEL_PREEDIT: {
+            LOGMESSAGE3(" - ", "XMessage: Cancel preedit=", preEditBuffer)
+            cancelPreedit();
+            return true; }
+        case HILDON_IM_CONTEXT_PREEDIT_MODE: {
+            LOGMESSAGE3 (" - ", "Commit Mode=", "Preedit")
+            preEditBuffer.clear();
+            previousCommitMode = commitMode;
+            commitMode = HILDON_IM_COMMIT_PREEDIT;
+            return true; } 
+        case HILDON_IM_CONTEXT_REQUEST_SURROUNDING_FULL: {
+            LOGMESSAGE2(" - ", "XMessage: request surrounding full")
+            checkCommitMode();
+            sendSurrounding(true);
+            //if (self->is_url_entry)
+            //  hildon_im_context_send_command(self, HILDON_IM_SELECT_ALL);
+            return true; }
+        case HILDON_IM_CONTEXT_SPACE_AFTER_COMMIT: {
+            LOGMESSAGE2(" - ", "XMessage: put a space after commit")
+            spaceAfterCommit = true;
+            return true; }
+        case HILDON_IM_CONTEXT_NO_SPACE_AFTER_COMMIT: {
+            LOGMESSAGE2(" - ", "XMessage: no space after commit")
+            spaceAfterCommit = false;
+            return true; }
+#endif  
+        default:
+            qWarning() << "HIM: (warning) Message not handled:" << msg->type;
+        }
+    }else if (event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING_CONTENT) &&
+              event->xclient.format == HILDON_IM_SURROUNDING_CONTENT_FORMAT) {
+        HildonIMSurroundingContentMessage *msg = reinterpret_cast<HildonIMSurroundingContentMessage*>(&event->xclient.data);
+        LOGMESSAGE3(" - ", "SurroundingContentMessage=", "msg->surrounding")
+
+        if (!surrounding.isNull()) {
+            if (msg->msg_flag == HILDON_IM_MSG_START) {
+                surrounding.clear();
+            }else if (msg->msg_flag == HILDON_IM_MSG_END) {
+                //TODO? commitSurrounding();
+                qWarning("commitSurrounding() NOT IMPLEMENTED YET");
+                return true;
+            }            
+        }
+        
+        surrounding += QString::fromUtf8(msg->surrounding);
+        return true;
+    }else if (event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING) &&
+                  event->xclient.format == HILDON_IM_SURROUNDING_FORMAT) {
+        LOGMESSAGE2(" - ", "XMessage: IM Surrounding")
+        HildonIMSurroundingMessage *msg = reinterpret_cast<HildonIMSurroundingMessage*>(&event->xclient.data);
+        setClientCursorLocation(msg->offset_is_relative, msg->cursor_offset );
+        return true;
+    }
+    return false;
+}
+
+/*! Some widgets have the IM always enabled.
+ *  In some particular cases it don't need the IM
+ *  Eg:  If the widget is read only or if we have 
+ *        complex widgets like QWebView or 
+ *        QGraphicsView. 
+ */
+bool QHildonInputContext::canUseIM(QWidget *w)
+{
+    bool enabled = false;
+    
+    if ( w && w->testAttribute(Qt::WA_InputMethodEnabled) ){
+
+        //is it in readOnlyMode?
+        QLineEdit *le = qobject_cast<QLineEdit*>(w);
+        QTextEdit *te = qobject_cast<QTextEdit*>(w);
+        QPlainTextEdit *pte = qobject_cast<QPlainTextEdit*>(w);
+
+        if (le){
+            enabled=!le->isReadOnly();
+        }else if (te){
+            enabled=!te->isReadOnly();
+        }else if (pte){
+            enabled=!pte->isReadOnly();
+        }else{
+            //These queries return a valid values only for input elements
+            //If the user click in an input element, the cursor return a valid
+            //value and the selection will be an empty string.
+            //Vice versa if the user select a text.
+            enabled=  (w->inputMethodQuery(Qt::ImCursorPosition).isNull() !=
+                       w->inputMethodQuery(Qt::ImCurrentSelection).toString().isEmpty());
+        }
+    }
+    return enabled;
+}
+
+/*! Ask the client widget to insert the specified text at the cursor
+ *  position, by triggering the commit signal on the context
+ */
+void QHildonInputContext::insertUtf8(int flag, const QString& text)
+{
+    LOGMESSAGE3("insertUtf8", flag, text)
+
+    QString cleanText = text;
+    if (mask & HILDON_IM_SHIFT_LOCK_MASK)
+            cleanText = cleanText.toUpper();
+
+    lastInternalChange = true;
+
+    //TODO HILDON_IM_AUTOCORRECT is used by the hadwriting plugin
+    //Writing CiAo in the plugin add Ciao in the widget.
+    if (options & HILDON_IM_AUTOCORRECT){
+        qWarning() << "HILDON_IM_AUTOCORRECT Not Implemented Yet";
+    }
+
+    
+    //Delete suroundings when we are using the preeditbuffer.
+    // Eg: For the HandWriting plugin 
+    if (!preEditBuffer.isNull()) {  
+#ifndef Q_OS_FREMANTLE
+        //Delete suroundings when we are using the preeditbuffer.
+        // Eg: For the HandWriting plugin 
+        QInputMethodEvent e;
+        int charCount = preEditBuffer.length(); 
+        e.setCommitString(QString(), -charCount, charCount);
+        sendEvent(e);
+#endif
+
+        //Updates preEditBuffer
+        if (flag != HILDON_IM_MSG_START) {
+            preEditBuffer.append(cleanText);
+            cleanText = preEditBuffer;
+        }
+     }
+    
+    //Adds the actual text
+    switch (commitMode) {
+        case HILDON_IM_COMMIT_PREEDIT: { //Fremantle
+            if ( preEditBuffer.isNull() )
+                preEditBuffer = cleanText;
+
+            //Creating attribute list
+            QList<QInputMethodEvent::Attribute> list;
+            QInputMethodEvent::Attribute cursor(QInputMethodEvent::Cursor, 0, cleanText.length(), QColor(0, 0, 255, 127));
+            list.append(cursor);
+
+            QTextCharFormat textCharFormat;
+            textCharFormat.setFontUnderline(true);
+            textCharFormat.setBackground(focusWidget()->palette().highlight());
+            textCharFormat.setForeground(focusWidget()->palette().highlightedText());
+            QInputMethodEvent::Attribute textFormat(QInputMethodEvent::TextFormat, 0, cleanText.length(), textCharFormat);
+            list.append(textFormat);
+
+            QInputMethodEvent e(cleanText, list);            
+            sendEvent(e);
+
+            //Reset commit mode
+            if (flag == HILDON_IM_MSG_END){
+                commitMode = previousCommitMode;
+                previousCommitMode = HILDON_IM_COMMIT_PREEDIT;
+            }
+
+        }break;
+        case HILDON_IM_COMMIT_BUFFERED: //Diablo Handwriting
+        case HILDON_IM_COMMIT_DIRECT:
+        case HILDON_IM_COMMIT_REDIRECT:{
+            QInputMethodEvent e;
+            e.setCommitString(cleanText);
+            sendEvent(e);
+        }break;
+        default:
+            qWarning() << "Commit mode " << commitMode << " not handled by InsertText method";
+    }
+}
+
+void QHildonInputContext::clearSelection()
+{
+    LOGMESSAGE1("clearSelection");
+
+    QWidget *w = focusWidget();
+    int textCursorPos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+    QString selection = w->inputMethodQuery(Qt::ImCurrentSelection).toString();
+
+    if (selection.isEmpty())
+        return;
+    
+    //Remove the selection
+    QInputMethodEvent e;
+    e.setCommitString(selection);
+    sendEvent(e);
+
+    //Move the cursor backward if the text has been selected from right to left
+    if (textCursorPos < textCursorPosOnPress){
+        QInputMethodEvent e;
+        e.setCommitString(QString(), -selection.length(),0);
+        sendEvent(e);
+    }
+}
+
+void QHildonInputContext::cancelPreedit(){
+    LOGMESSAGE1("cancelPreedit");
+
+    if (preEditBuffer.isEmpty())
+        return;
+
+    preEditBuffer.clear();
+
+    QInputMethodEvent e;   
+    sendEvent(e);
+}
+
+void QHildonInputContext::sendHildonCommand(HildonIMCommand cmd, QWidget *widget)
+{
+    LOGMESSAGE3("sendHildonCommand", cmd, widget);
+
+    Window w = findHildonIm();
+
+    if (!w){
+        return;
+    }
+
+    XEvent ev;
+    memset(&ev, 0, sizeof(XEvent));
+
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = w;
+    ev.xclient.message_type = ATOM(_HILDON_IM_ACTIVATE);
+    ev.xclient.format = HILDON_IM_ACTIVATE_FORMAT;
+
+    HildonIMActivateMessage *msg = reinterpret_cast<HildonIMActivateMessage *>(&ev.xclient.data);
+
+    if (widget){
+        msg->input_window = widget->winId();
+        msg->app_window = widget->window()->winId();
+    }else if ( cmd != HILDON_IM_HIDE ){
+        qWarning() << "Invalid Hildon Command:" << cmd;
+        return;
+    }
+
+    if ( cmd == HILDON_IM_HIDE && timerId != -1){
+        killTimer(timerId);
+    }
+
+    if (cmd == HILDON_IM_SETCLIENT || cmd == HILDON_IM_SETNSHOW){
+        sendInputMode();
+    }
+
+    msg->cmd = cmd;
+    //msg->input_mode = inputMode;
+    msg->trigger = triggerMode;
+
+    XSendEvent(X11->display, w, false, 0, &ev);
+    XSync(X11->display, False);
+}
+
+
+/*!
+ */
+void QHildonInputContext::sendX11Event(XEvent *event)
+{
+    LOGMESSAGE2("sendX11Event", event);
+
+    Window w = findHildonIm();
+
+    if (!w){
+        return;
+    }
+
+    event->xclient.type = ClientMessage;
+    event->xclient.window = w;
+
+    XSendEvent(X11->display, w, false, 0, event);
+    XSync(X11->display, False);
+}
+
+/*! Shows the Hildon Input Method Main UI
+ */
+void QHildonInputContext::showHIMMainUI() //### REMOVE
+{
+    //Force QInputContext to use the fucused widget.
+    LOGMESSAGE1("QHildonInputContext::showHIMMainUI")
+
+    //QInputContext::setFocusWidget(QApplication::focusWidget());
+    toggleHildonMainIMUi();
+}
+
+//CONTEXT
+/*! Updates the IM with the autocap state at the active cursor position
+ */
+void QHildonInputContext::checkSentenceStart()
+{
+    LOGMESSAGE1("checkSentenceStart");
+
+    QWidget *w = focusWidget();
+    if (!w){
+        return;
+    }
+
+    if ((inputMode & (HILDON_GTK_INPUT_MODE_ALPHA | HILDON_GTK_INPUT_MODE_AUTOCAP)) !=
+            (HILDON_GTK_INPUT_MODE_ALPHA | HILDON_GTK_INPUT_MODE_AUTOCAP)) {
+        /* If autocap is off, but the mode contains alpha, send autocap message.
+         * The important part is that when entering a numerical entry the autocap
+         * is not defined, and the plugin sets the mode appropriate for the language */
+        if (inputMode & HILDON_GTK_INPUT_MODE_ALPHA){
+            autoUpper = false;
+            sendHildonCommand(HILDON_IM_LOW,w);
+        }
+        return;
+    }
+    
+    QString surrounding = w->inputMethodQuery(Qt::ImSurroundingText).toString();
+    int cpos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+
+    if (surrounding.isEmpty()) { 
+        autoUpper = true;
+        sendHildonCommand(HILDON_IM_UPP, w);
+        return;
+    }
+
+    QRegExp r(".*[!?.][\\s]+");
+    QRegExp c("[¿¡]");
+    //Improve performance: Don't make sense analyzing more than N chars before the cursor
+    QString left = surrounding.left(cpos).right(10);
+    QString right = left.right(1);
+    QString notRemoved = left.remove(r);
+
+    if(!notRemoved.count() || right.contains(c)){
+        autoUpper = options & HILDON_IM_AUTOCASE;
+        sendHildonCommand(HILDON_IM_UPP, w);
+    }else{
+        autoUpper = false;
+        sendHildonCommand(HILDON_IM_LOW, w);
+    }
+}
+
+void QHildonInputContext::commitPreeditData()
+{
+    LOGMESSAGE1("commitPreeditData")
+
+    if (!preEditBuffer.isNull())
+        preEditBuffer = QString("");
+}
+
+void QHildonInputContext::checkCommitMode() //### REMOVE?
+{
+    LOGMESSAGE1("checkCommitMode")
+
+    //if (m_commitMode == HILDON_IM_COMMIT_REDIRECT)
+    //    m_commitMode = HILDON_IM_COMMIT_SURROUNDING;
+}
+
+/*! Send the text of the client widget surrounding the active cursor position,
+ *  as well as the cursor position in the surrounding, to the IM
+ */
+void QHildonInputContext::sendSurrounding(bool sendAllContents)
+{
+    LOGMESSAGE2("sendSurrounding", sendAllContents )
+
+    QWidget *w = focusWidget();
+
+    if (!w)
+        return;
+    
+    QString surrounding;
+    int cpos;
+    if (sendAllContents){
+
+         //Try to detect the kind of widget
+        QTextEdit *te = qobject_cast<QTextEdit*>(w);
+        QPlainTextEdit *pte = qobject_cast<QPlainTextEdit*>(w);
+
+        if (te){
+            surrounding = te->toPlainText();
+            cpos = te->textCursor().position();      
+        }else if (pte){
+            surrounding = pte->toPlainText();
+            cpos = pte->textCursor().position(); 
+        }else{
+            surrounding = w->inputMethodQuery(Qt::ImSurroundingText).toString();
+            cpos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+        }
+    }else{
+        surrounding = w->inputMethodQuery(Qt::ImSurroundingText).toString();
+        cpos = w->inputMethodQuery(Qt::ImCursorPosition).toInt();
+    }
+
+    XEvent xev;
+    HildonIMSurroundingContentMessage *surroundingContentMsg = 0;
+    int flag = HILDON_IM_MSG_START;
+
+    //Sending a null to clean the plugin.
+    if (surrounding.isEmpty()) {
+        memset(&xev, 0, sizeof(XEvent));
+        xev.xclient.message_type = ATOM(_HILDON_IM_SURROUNDING_CONTENT);
+        xev.xclient.format = HILDON_IM_SURROUNDING_CONTENT_FORMAT;
+
+        surroundingContentMsg = reinterpret_cast<HildonIMSurroundingContentMessage*>(&xev.xclient.data);
+        surroundingContentMsg->msg_flag = flag;
+        surroundingContentMsg->surrounding[0] = '\0';
+
+        sendX11Event(&xev);
+        
+        sendSurroundingHeader(0);
+        return;
+    }
+    
+    // Split surrounding context into pieces that are small enough
+    // to send in a x message
+    QByteArray ba = surrounding.toUtf8(); 
+    const char *utf8 = ba.data();
+    while (*utf8){
+        const char *nextStart = getNextPacketStart(utf8);
+        unsigned int len = nextStart - utf8;
+
+        //this call will take care of adding the null terminator
+        memset(&xev, 0, sizeof(XEvent));
+        xev.xclient.message_type = ATOM(_HILDON_IM_SURROUNDING_CONTENT);
+        xev.xclient.format = HILDON_IM_SURROUNDING_CONTENT_FORMAT;
+
+        surroundingContentMsg = reinterpret_cast<HildonIMSurroundingContentMessage*>(&xev.xclient.data);
+        surroundingContentMsg->msg_flag = flag;
+        memcpy(surroundingContentMsg->surrounding, utf8, len);
+
+        sendX11Event(&xev);
+
+        utf8 = nextStart;
+        flag = HILDON_IM_MSG_CONTINUE;
+    } 
+    sendSurroundingHeader(cpos);
+}
+
+void QHildonInputContext::sendSurroundingHeader(int offset)
+{
+    LOGMESSAGE2("sendSurroundingHeader",offset);
+
+    XEvent xev;
+    /* Send the cursor offset in the surrounding */
+    memset(&xev, 0, sizeof(XEvent));
+    xev.xclient.message_type = ATOM(_HILDON_IM_SURROUNDING);
+    xev.xclient.format = HILDON_IM_SURROUNDING_FORMAT;
+
+    HildonIMSurroundingMessage *surroundingMsg = reinterpret_cast<HildonIMSurroundingMessage *>(&xev.xclient.data);
+    surroundingMsg->commit_mode = commitMode;
+    surroundingMsg->cursor_offset = offset;
+
+    sendX11Event(&xev);
+}
+
+/*! Notify IM of any input mode changes 
+ */
+void QHildonInputContext::inputModeChanged(){
+    LOGMESSAGE1("inputModeChanged");
+
+#if 0
+  //TODO
+  if ((input_mode & HILDON_GTK_INPUT_MODE_ALPHA) == 0  &&
+      (input_mode & HILDON_GTK_INPUT_MODE_HEXA)  == 0  &&
+      ( (input_mode & HILDON_GTK_INPUT_MODE_NUMERIC) != 0 ||
+        (input_mode & HILDON_GTK_INPUT_MODE_TELE)    != 0))
+  {
+    self->mask = HILDON_IM_LEVEL_LOCK_MASK | HILDON_IM_LEVEL_STICKY_MASK;
+  }
+  else
+  {
+    self->mask &= ~HILDON_IM_LEVEL_LOCK_MASK;
+    self->mask &= ~HILDON_IM_LEVEL_STICKY_MASK;
+  }
+#endif  
+  /* Notify IM of any input mode changes in cases where the UI is
+     already visible. */
+  sendInputMode();
+}
+
+void QHildonInputContext::sendInputMode(){
+    LOGMESSAGE1("sendInputMode")
+
+    Window w = findHildonIm();
+
+    if (!w){
+        return;
+    }
+
+    XEvent ev;
+    memset(&ev, 0, sizeof(XEvent));
+
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = w;
+    ev.xclient.message_type = ATOM(_HILDON_IM_INPUT_MODE);
+    ev.xclient.format = HILDON_IM_INPUT_MODE_FORMAT;
+
+    HildonIMInputModeMessage *msg = reinterpret_cast<HildonIMInputModeMessage *>(&ev.xclient.data);
+    HildonGtkInputMode input_mode = HILDON_GTK_INPUT_MODE_DICTIONARY;//inputMode;
+    HildonGtkInputMode default_input_mode =  HILDON_GTK_INPUT_MODE_FULL;
+
+    msg->input_mode = input_mode;
+    msg->default_input_mode = default_input_mode;
+
+    XSendEvent(X11->display, w, false, 0, &ev);
+    XSync(X11->display, False);
+}
+
+/*! In redirect mode we use a proxy widget (fullscreen vkb). When the cursor position
+ *  changes there, the HIM update the cursor position in the client (Qt application)
+ */
+void QHildonInputContext::setClientCursorLocation(int offsetIsRelative, int cursorOffset)
+{   
+    LOGMESSAGE3("setClientCursorLocation", offsetIsRelative, cursorOffset)
+
+    if (!offsetIsRelative){
+        qWarning("setClientCursorLocation can't manage absolute cursor Offsets");
+        return;
+    }
+
+    //Move the cursor
+    //NOTE: To move the cursor changes in customWidget::inputMethodEvent(QInputMethodEvent *e) are needed.
+    QInputMethodEvent e;
+    e.setCommitString(QString(), cursorOffset,0);
+    sendEvent(e);
+}
+
+void QHildonInputContext::setMaskState(int *mask,
+                                              HildonIMInternalModifierMask lock_mask,
+                                              HildonIMInternalModifierMask sticky_mask,
+                                              bool was_press_and_release)
+{
+    LOGMESSAGE3("setMaskState", lock_mask, sticky_mask)
+    LOGMESSAGE3(" - ", "mask=", *mask)
+    //### TODO remove me    
+    int input_mode = 0;
+
+   /* Locking Fn is disabled in TELE and NUMERIC */
+    if (!(input_mode & HILDON_GTK_INPUT_MODE_ALPHA) &&
+        !(input_mode & HILDON_GTK_INPUT_MODE_HEXA)  &&
+        ((input_mode & HILDON_GTK_INPUT_MODE_TELE) || 
+         (input_mode & HILDON_GTK_INPUT_MODE_NUMERIC))
+       ) {
+        if (*mask & lock_mask){
+            /* already locked, remove lock and set it to sticky */
+            *mask &= ~(lock_mask | sticky_mask);
+            *mask |= sticky_mask;
+        }else if (*mask & sticky_mask){
+            /* the key is already sticky, it's fine */
+        }else if (was_press_and_release){
+            /* Pressing the key for the first time stickies the key for one character,
+             * but only if no characters were entered while holding the key down */
+            *mask |= sticky_mask;
+        }
+        return;
+    }
+
+    if (*mask & lock_mask)
+    {
+        /* Pressing the key while already locked clears the state */
+        if (lock_mask & HILDON_IM_SHIFT_LOCK_MASK)
+            sendHildonCommand(HILDON_IM_SHIFT_UNLOCKED, QApplication::focusWidget());
+        else if (lock_mask & HILDON_IM_LEVEL_LOCK_MASK)
+            sendHildonCommand(HILDON_IM_MOD_UNLOCKED, QApplication::focusWidget());    
+    
+        *mask &= ~(lock_mask | sticky_mask);
+    } else if (*mask & sticky_mask) {
+        /* When the key is already sticky, a second press locks the key */
+        *mask |= lock_mask;
+
+        if (lock_mask & HILDON_IM_SHIFT_LOCK_MASK)
+            sendHildonCommand(HILDON_IM_SHIFT_LOCKED, QApplication::focusWidget());
+        else if (lock_mask & HILDON_IM_LEVEL_LOCK_MASK)
+            sendHildonCommand(HILDON_IM_MOD_LOCKED, QApplication::focusWidget());
+    }else if (was_press_and_release){
+        /* Pressing the key for the first time stickies the key for one character,
+         * but only if no characters were entered while holding the key down */
+        *mask |= sticky_mask;
+    }
+
+}
+
+#endif
diff --git a/src/gui/inputmethod/qhildoninputmethodprotocol_p.h b/src/gui/inputmethod/qhildoninputmethodprotocol_p.h
new file mode 100644
index 0000000..15e4136
--- /dev/null
+++ b/src/gui/inputmethod/qhildoninputmethodprotocol_p.h
@@ -0,0 +1,241 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+**
+** This file is part of the QtGui module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifdef Q_WS_HILDON
+
+#include "qx11info_x11.h"
+#include "private/qt_x11_p.h"
+
+/******* from hildon-im-protocol **********/
+
+#define HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE (20 - sizeof(int))
+
+/* Commit modes
+   Determines how text is inserted into the client widget
+
+   Buffered mode:  Each new commit replaces any previous commit to the
+   client widget until FLUSH_PREEDIT is called.
+
+   Direct mode (default): Each commit is immediately appended to the
+   client widget at the cursor position.
+
+   Redirect mode: Proxies input and cursor movement from one text widget
+   into another (potentially off-screen) widget. Used when implementing
+   fullscreen IM plugins for widgets that contain text formatting.
+
+   Surrounding mode: Each commit replaces the current text surrounding
+   the cursor position (see gtk_im_context_get_surrounding).
+*/
+typedef enum
+{
+  HILDON_IM_COMMIT_DIRECT,
+  HILDON_IM_COMMIT_REDIRECT,
+  HILDON_IM_COMMIT_SURROUNDING,
+  HILDON_IM_COMMIT_BUFFERED,
+  HILDON_IM_COMMIT_PREEDIT
+} HildonIMCommitMode;
+
+/* Type markers for IM messages that span several ClientMessages */
+enum
+{
+  HILDON_IM_MSG_START,
+  HILDON_IM_MSG_CONTINUE,
+  HILDON_IM_MSG_END
+};
+
+/* Message carrying surrounding interpretation info, sent by both IM and context */
+typedef struct
+{
+  HildonIMCommitMode commit_mode;
+  int offset_is_relative;
+  int cursor_offset;
+} HildonIMSurroundingMessage;
+
+/* The surrounding text, sent by both IM and context */
+typedef struct
+{
+  int msg_flag;
+  char surrounding[HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE];
+} HildonIMSurroundingContentMessage;
+
+enum
+{
+    HILDON_IM_ACTIVATE_FORMAT = 8,
+//  HILDON_IM_COM_FORMAT =8,
+    HILDON_IM_INSERT_UTF8_FORMAT = 8,
+    HILDON_IM_KEY_EVENT_FORMAT = 8,
+    HILDON_IM_SURROUNDING_CONTENT_FORMAT = 8,
+    HILDON_IM_SURROUNDING_FORMAT = 8,
+    HILDON_IM_INPUT_MODE_FORMAT = 8,
+    HILDON_IM_PREEDIT_COMMITTED_FORMAT = 8,
+    HILDON_IM_PREEDIT_COMMITTED_CONTENT_FORMAT = 8,
+    HILDON_IM_CLIPBOARD_SELECTION_REPLY_FORMAT = 32,
+//  HILDON_IM_CLIPBOARD_FORMAT = 32
+    HILDON_IM_WINDOW_ID_FORMAT = 32,
+    HILDON_IM_DEFAULT_LAUNCH_DELAY = 70
+}; /* IM ClientMessage formats */
+
+/* IM commands, from context to IM process */
+enum HildonIMCommand
+{
+    HILDON_IM_MODE,       // Update the hildon-input-mode property
+    HILDON_IM_SHOW,       // Show the IM UI
+    HILDON_IM_HIDE,       // Hide the IM UI
+    HILDON_IM_UPP,        // Uppercase autocap state at cursor
+    HILDON_IM_LOW,        // Lowercase autocap state at cursor
+    HILDON_IM_DESTROY,    // DEPRECATED
+    HILDON_IM_CLEAR,      // Clear the IM UI state
+    HILDON_IM_SETCLIENT,  // Set the client window
+    HILDON_IM_SETNSHOW,   // Set the client and show the IM window 
+    HILDON_IM_SELECT_ALL, // Select the text in the plugin
+
+    HILDON_IM_SHIFT_LOCKED,
+    HILDON_IM_SHIFT_UNLOCKED,
+    HILDON_IM_MOD_LOCKED,
+    HILDON_IM_MOD_UNLOCKED,
+
+    /* always last */
+    HILDON_IM_NUM_COMMANDS
+};
+
+enum HildonIMTrigger
+{
+    HILDON_IM_TRIGGER_NONE = -1,
+    HILDON_IM_TRIGGER_STYLUS,
+    HILDON_IM_TRIGGER_FINGER,
+    HILDON_IM_TRIGGER_KEYBOARD,
+    HILDON_IM_TRIGGER_UNKNOWN
+};
+
+// Command activation message, from context to IM (see HildonIMCommand)
+struct HildonIMActivateMessage
+{
+    Window input_window;
+    Window app_window;
+    HildonIMCommand cmd;
+    HildonIMTrigger trigger;
+};
+
+// Text insertion message, from IM to context
+struct HildonIMInsertUtf8Message
+{
+    int msg_flag;
+    char utf8_str[HILDON_IM_CLIENT_MESSAGE_BUFFER_SIZE];
+};
+
+// IM communications, from IM process to context
+typedef enum
+{
+  HILDON_IM_CONTEXT_HANDLE_ENTER,           /* Virtual enter activated */
+  HILDON_IM_CONTEXT_HANDLE_TAB,             /* Virtual tab activated */
+  HILDON_IM_CONTEXT_HANDLE_BACKSPACE,       /* Virtual backspace activated */
+  HILDON_IM_CONTEXT_HANDLE_SPACE,           /* Virtual space activated */
+  HILDON_IM_CONTEXT_CONFIRM_SENTENCE_START, /* Query the autocap state at cursor */
+  HILDON_IM_CONTEXT_FLUSH_PREEDIT,          /* Finalize the preedit to the client widget */
+  HILDON_IM_CONTEXT_CANCEL_PREEDIT,          /* Clean the preedit buffer */
+
+  /* See HildonIMCommitMode for a description of the commit modes */
+  HILDON_IM_CONTEXT_BUFFERED_MODE,
+  HILDON_IM_CONTEXT_DIRECT_MODE,
+  HILDON_IM_CONTEXT_REDIRECT_MODE,
+  HILDON_IM_CONTEXT_SURROUNDING_MODE,
+  HILDON_IM_CONTEXT_PREEDIT_MODE,
+
+  HILDON_IM_CONTEXT_CLIPBOARD_COPY,            /* Copy client selection to clipboard */
+  HILDON_IM_CONTEXT_CLIPBOARD_CUT,             /* Cut client selection to clipboard */
+  HILDON_IM_CONTEXT_CLIPBOARD_PASTE,           /* Paste clipboard selection to client */
+  HILDON_IM_CONTEXT_CLIPBOARD_SELECTION_QUERY, /* Query if the client has an active selection */
+  HILDON_IM_CONTEXT_REQUEST_SURROUNDING,       /* Request the content surrounding the cursor */
+  HILDON_IM_CONTEXT_REQUEST_SURROUNDING_FULL,          /* Request the contents of the text widget */
+  HILDON_IM_CONTEXT_WIDGET_CHANGED,            /* IM detected that the client widget changed */
+  HILDON_IM_CONTEXT_OPTION_CHANGED,            /* The OptionMask for the active context is updated */
+  HILDON_IM_CONTEXT_CLEAR_STICKY,              /* Clear the sticky key state */
+  HILDON_IM_CONTEXT_ENTER_ON_FOCUS,            /* Generate a virtual enter key event on focus in */
+
+  HILDON_IM_CONTEXT_SPACE_AFTER_COMMIT,
+  HILDON_IM_CONTEXT_NO_SPACE_AFTER_COMMIT,
+
+  /* always last */
+  HILDON_IM_CONTEXT_NUM_COM
+} HildonIMCommunication;
+
+// IM context toggle options.
+enum HildonIMOptionMask
+{
+  HILDON_IM_AUTOCASE          = 1 << 0, // Suggest case based on the cursor's position in sentence
+  HILDON_IM_AUTOCORRECT       = 1 << 1, // Limited automatic error correction of commits
+  HILDON_IM_AUTOLEVEL_NUMERIC = 1 << 2, // Default to appropriate key-level in numeric-only clients
+  HILDON_IM_LOCK_LEVEL        = 1 << 3  // Lock the effective key-level at pre-determined value
+};
+
+// Communication message from IM to context
+struct HildonIMComMessage
+{
+    Window input_window;
+    HildonIMCommunication type;
+    HildonIMOptionMask options;
+};
+
+// Key event message, from context to IM
+typedef struct
+{
+  Window input_window;
+  int type;
+  unsigned int state;
+  unsigned int keyval;
+  unsigned int hardware_keycode;
+} HildonIMKeyEventMessage;
+
+
+typedef enum {
+  HILDON_IM_SHIFT_STICKY_MASK     = 1 << 0,
+  HILDON_IM_SHIFT_LOCK_MASK       = 1 << 1,
+  HILDON_IM_LEVEL_STICKY_MASK     = 1 << 2,
+  HILDON_IM_LEVEL_LOCK_MASK       = 1 << 3,
+  HILDON_IM_COMPOSE_MASK          = 1 << 4,
+  HILDON_IM_DEAD_KEY_MASK         = 1 << 5,
+} HildonIMInternalModifierMask;
+
+typedef struct
+{
+  HildonGtkInputMode input_mode;
+  HildonGtkInputMode default_input_mode;
+} HildonIMInputModeMessage;
+
+#endif
diff --git a/src/gui/inputmethod/qinputcontext.h b/src/gui/inputmethod/qinputcontext.h
index 1270d26..a158df4 100644
--- a/src/gui/inputmethod/qinputcontext.h
+++ b/src/gui/inputmethod/qinputcontext.h
@@ -76,6 +76,24 @@ class QFont;
 class QPopupMenu;
 class QInputContextPrivate;
 
+#if defined(Q_WS_HILDON)
+// this one is from GtkIMContext
+enum HildonGtkInputMode
+{
+    HILDON_GTK_INPUT_MODE_ALPHA        = 1 << 0,
+    HILDON_GTK_INPUT_MODE_NUMERIC      = 1 << 1,
+    HILDON_GTK_INPUT_MODE_SPECIAL      = 1 << 2,
+    HILDON_GTK_INPUT_MODE_HEXA         = 1 << 3,
+    HILDON_GTK_INPUT_MODE_TELE         = 1 << 4,
+
+    HILDON_GTK_INPUT_MODE_FULL         = (HILDON_GTK_INPUT_MODE_ALPHA | HILDON_GTK_INPUT_MODE_NUMERIC | HILDON_GTK_INPUT_MODE_SPECIAL),
+
+    HILDON_GTK_INPUT_MODE_MULTILINE    = 1 << 28,
+    HILDON_GTK_INPUT_MODE_INVISIBLE    = 1 << 29,
+    HILDON_GTK_INPUT_MODE_AUTOCAP      = 1 << 30,
+    HILDON_GTK_INPUT_MODE_DICTIONARY   = 1 << 31
+};
+#endif
 
 class Q_GUI_EXPORT QInputContext : public QObject
 {
diff --git a/src/gui/inputmethod/qinputcontextfactory.cpp b/src/gui/inputmethod/qinputcontextfactory.cpp
index f11c1b8..7af1d71 100644
--- a/src/gui/inputmethod/qinputcontextfactory.cpp
+++ b/src/gui/inputmethod/qinputcontextfactory.cpp
@@ -71,6 +71,9 @@
 #ifdef Q_WS_MAC
 #include "qmacinputcontext_p.h"
 #endif
+#ifdef Q_WS_HILDON
+#include "qhildoninputcontext_p.h"
+#endif
 
 #include "private/qfactoryloader_p.h"
 #include "qmutex.h"
@@ -145,6 +148,11 @@ QInputContext *QInputContextFactory::create( const QString& key, QObject *parent
         result = new QMacInputContext;
     }
 #endif
+#if defined(Q_WS_HILDON)
+    if (key == QLatin1String("hildon")) {
+        result = new QHildonInputContext;
+    }
+#endif
 #if defined(QT_NO_LIBRARY) || defined(QT_NO_SETTINGS)
     Q_UNUSED(key);
 #else
@@ -182,6 +190,9 @@ QStringList QInputContextFactory::keys()
 #if defined(Q_WS_MAC)
     result << QLatin1String("mac");
 #endif
+#if defined (Q_WS_HILDON)
+    result << QLatin1String("hildon");
+#endif
 #if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
     result += loader()->keys();
 #endif // QT_NO_LIBRARY
@@ -217,6 +228,10 @@ QStringList QInputContextFactory::languages( const QString &key )
     if (key == QLatin1String("mac"))
         return QStringList(QString());
 #endif
+#if defined (Q_WS_HILDON)
+    if (key == QLatin1String("hildon"))
+        return QStringList(QString());
+#endif
 #if defined(QT_NO_LIBRARY) || defined(QT_NO_SETTINGS)
     Q_UNUSED(key);
 #else
@@ -272,6 +287,10 @@ QString QInputContextFactory::description( const QString &key )
     if (key == QLatin1String("mac"))
         return QInputContext::tr( "Mac OS X input method" );
 #endif
+#if defined(Q_WS_HILDON)
+    if (key == QLatin1String("hildon"))
+        return QInputContext::tr("Hildon input method");
+#endif
 #if defined(QT_NO_LIBRARY) || defined(QT_NO_SETTINGS)
     Q_UNUSED(key);
 #else
diff --git a/src/gui/kernel/qapplication.cpp b/src/gui/kernel/qapplication.cpp
index 40795d1..51a938f 100644
--- a/src/gui/kernel/qapplication.cpp
+++ b/src/gui/kernel/qapplication.cpp
@@ -4952,6 +4952,10 @@ uint QApplicationPrivate::currentPlatform(){
     if (X11->desktopEnvironment == DE_CDE)
         platform |= KB_CDE;
 #endif
+#ifdef Q_WS_HILDON
+    if (X11->desktopEnvironment == DE_HILDON)
+       platform |= KB_Hildon;
+#endif
     return platform;
 }
 
diff --git a/src/gui/kernel/qapplication.h b/src/gui/kernel/qapplication.h
index 3c0e598..c32e762 100644
--- a/src/gui/kernel/qapplication.h
+++ b/src/gui/kernel/qapplication.h
@@ -382,6 +382,9 @@ private:
 #if defined(Q_WS_MAC) || defined(Q_WS_X11)
     Q_PRIVATE_SLOT(d_func(), void _q_alertTimeOut())
 #endif
+#ifdef Q_WS_HILDON
+    Q_PRIVATE_SLOT(d_func(), void _q_longPushTimeOut())
+#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/gui/kernel/qapplication_p.h b/src/gui/kernel/qapplication_p.h
index ddd5624..d4fc3ad 100644
--- a/src/gui/kernel/qapplication_p.h
+++ b/src/gui/kernel/qapplication_p.h
@@ -234,6 +234,10 @@ public:
     void createEventDispatcher();
     QString appName() const;
 
+#ifdef Q_WS_HILDON
+    static bool areXInputEventsUsed();
+#endif
+
     static void dispatchEnterLeave(QWidget *enter, QWidget *leave);
 
     //modality
@@ -270,6 +274,9 @@ public:
         KB_KDE = 8,
         KB_Gnome = 16,
         KB_CDE = 32,
+#ifdef Q_WS_HILDON
+        KB_Hildon = 64,
+#endif
         KB_All = 0xffff
     };
 
@@ -411,6 +418,9 @@ public:
 #if defined(QT_MAC_USE_COCOA)
     void _q_runModalWindow();
 #endif
+#ifdef Q_WS_HILDON
+    void _q_longPushTimeOut();
+#endif
 #ifndef QT_NO_STYLE_STYLESHEET
     static QString styleSheet;
 #endif
diff --git a/src/gui/kernel/qapplication_x11.cpp b/src/gui/kernel/qapplication_x11.cpp
old mode 100644
new mode 100755
index 163ceb6..31c1427
--- a/src/gui/kernel/qapplication_x11.cpp
+++ b/src/gui/kernel/qapplication_x11.cpp
@@ -126,6 +126,10 @@ extern "C" {
 
 #include "qwidget_p.h"
 
+#ifdef Q_WS_HILDON
+#  include "qmainwindow.h"
+#endif
+
 #include <private/qbackingstore_p.h>
 
 QT_BEGIN_NAMESPACE
@@ -241,7 +245,9 @@ static const char * x11_atomnames = {
     "_NET_WM_WINDOW_TYPE_DND\0"
     "_NET_WM_WINDOW_TYPE_NORMAL\0"
     "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE\0"
-
+#ifdef Q_OS_FREMANTLE
+    "_HILDON_WM_WINDOW_TYPE_APP_MENU\0"
+#endif
     "_KDE_NET_WM_FRAME_STRUT\0"
 
     "_NET_STARTUP_INFO\0"
@@ -253,6 +259,11 @@ static const char * x11_atomnames = {
 
     "_NET_SYSTEM_TRAY_VISUAL\0"
 
+    // Hildon Menu
+#ifdef Q_WS_HILDON
+    "_MB_GRAB_TRANSFER\0"
+#endif
+
     // Property formats
     "COMPOUND_TEXT\0"
     "TEXT\0"
@@ -291,6 +302,38 @@ static const char * x11_atomnames = {
     // Xkb
     "_XKB_RULES_NAMES\0"
 
+    //Hildon Input Method Protocol
+/* IM atom names */
+#ifdef Q_WS_HILDON
+    // find the global im window
+    "_HILDON_IM_WINDOW\0"
+    // activate the input method
+    "_HILDON_IM_ACTIVATE\0"
+    //send sourrounding
+    "_HILDON_IM_SURROUNDING\0"
+    //send sourrounding header
+    "_HILDON_IM_SURROUNDING_CONTENT\0"
+    // send key event to im
+    "_HILDON_IM_KEY_EVENT\0"
+    // input method wants to insert data
+    "_HILDON_IM_INSERT_UTF8\0"
+    // input method wants to communicate with us
+    "_HILDON_IM_COM\0"
+    //### NOT USED YET
+    "_HILDON_IM_CLIPBOARD_COPIED\0"
+    //### NOT USED YET
+    "_HILDON_IM_CLIPBOARD_SELECTION_QUERY\0"
+    // tell im whether we have a selection or not
+    "_HILDON_IM_CLIPBOARD_SELECTION_REPLY\0"
+    /* Fremantle specific HIM Atoms */
+    //
+    "_HILDON_IM_INPUT_MODE\0"
+    //
+    "_HILDON_IM_PREEDIT_COMMITTED\0"
+    //
+    "_HILDON_IM_PREEDIT_COMMITTED_CONTENT\0"
+#endif
+
     // XEMBED
     "_XEMBED\0"
     "_XEMBED_INFO\0"
@@ -318,7 +361,10 @@ static bool        appDoGrab        = false;        // X11 grabbing override (gd
 static bool        app_save_rootinfo = false;        // save root info
 static bool        app_do_modal        = false;        // modal mode
 static Window        curWin = 0;                        // current window
-
+#ifdef Q_WS_HILDON
+//XInput events are managed by Qt for some input devices (eg. touchscreen)
+static bool are_xinput_events_used = false; 
+#endif
 
 // function to update the workarea of the screen - in qdesktopwidget_x11.cpp
 extern void qt_desktopwidget_update_workarea();
@@ -343,6 +389,11 @@ static Qt::MouseButtons mouseButtonState     = Qt::NoButton; // mouse button sta
 static Time        mouseButtonPressTime = 0;        // when was a button pressed
 static short        mouseXPos, mouseYPos;                // mouse pres position in act window
 static short        mouseGlobalXPos, mouseGlobalYPos; // global mouse press position
+#ifdef Q_WS_HILDON
+#define RIGHT_CLICK_TIME 2000
+static QPointer<QTimer> longPushTimer = 0; // hildon emulates right click with long press - needs a timer
+static QPointer<QWidget> qetWidget=0; 
+#endif
 
 extern QWidgetList *qt_modal_stack;                // stack of modal widgets
 
@@ -988,6 +1039,7 @@ bool QApplicationPrivate::x11_apply_settings()
             qt_xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
     }
 #endif
+#ifndef Q_WS_HILDON // hildon has its own input method
     QStringList inputMethods = QInputContextFactory::keys();
     if (inputMethods.size() > 2 && inputMethods.contains(QLatin1String("imsw-multi"))) {
         X11->default_im = QLatin1String("imsw-multi");
@@ -995,6 +1047,7 @@ bool QApplicationPrivate::x11_apply_settings()
         X11->default_im = settings.value(QLatin1String("DefaultInputMethod"),
                                          QLatin1String("xim")).toString();
     }
+#endif
 
     settings.endGroup(); // Qt
 
@@ -1688,8 +1741,11 @@ void qt_init(QApplicationPrivate *priv, int,
     X11->seen_badwindow = false;
 
     X11->motifdnd_active = false;
-
+#ifdef Q_WS_HILDON
+    X11->default_im = QLatin1String("hildon");
+#else
     X11->default_im = QLatin1String("imsw-multi");
+#endif
     priv->inputContext = 0;
 
     // colormap control
@@ -1954,10 +2010,18 @@ void qt_init(QApplicationPrivate *priv, int,
             // engine to work on a QImage with BGR layout.
             bool local = displayName.isEmpty() || displayName.lastIndexOf(QLatin1Char(':')) == 0;
             if (local && (qgetenv("QT_X11_NO_MITSHM").toInt() == 0)) {
+
+#ifdef Q_WS_HILDON
+				// The original code assumes 24bit color but NIT is 16 color,
+				// so X11->use_mitshm is set as false, and it causes a slowness issue
+				// for raster drawing.
+				X11->use_mitshm = mitshm_pixmaps;
+#else
                 Visual *defaultVisual = DefaultVisual(X11->display, DefaultScreen(X11->display));
                 X11->use_mitshm = mitshm_pixmaps && (defaultVisual->red_mask == 0xff0000
                                                      && defaultVisual->green_mask == 0xff00
                                                      && defaultVisual->blue_mask == 0xff);
+#endif // Q_WS_HILDON
             }
         }
 #endif // QT_NO_MITSHM
@@ -2271,6 +2335,10 @@ void qt_init(QApplicationPrivate *priv, int,
                         X11->desktopEnvironment = DE_KDE;
                     if (wmName == QLatin1String("Metacity"))
                         X11->desktopEnvironment = DE_GNOME;
+#ifdef Q_WS_HILDON
+                    if (wmName == QLatin1String("matchbox") || wmName == QLatin1String("hildon-desktop"))
+                        X11->desktopEnvironment = DE_HILDON;
+#endif
                 }
             }
         }
@@ -2340,7 +2408,9 @@ void qt_init(QApplicationPrivate *priv, int,
                 i,
                 j;
             bool gotStylus,
-                gotEraser;
+                 gotEraser,
+                 gotTouchscreen; //Maemo changes: Using XInput to get Touchscreen events
+
             XDeviceInfo *devices = 0, *devs;
             XInputClassInfo *ip;
             XAnyClassPtr any;
@@ -2354,6 +2424,9 @@ void qt_init(QApplicationPrivate *priv, int,
             const QString XFREENAMEPEN = QLatin1String("pen");
             const QString XFREENAMEERASER = QLatin1String("eraser");
 #endif
+#ifdef Q_WS_HILDON
+            const QString XFREENAMETOUCHSCREEN = QLatin1String("touchscreen");
+#endif
 
             if (X11->ptrXListInputDevices) {
                 devices = X11->ptrXListInputDevices(X11->display, &ndev);
@@ -2384,17 +2457,36 @@ void qt_init(QApplicationPrivate *priv, int,
                     deviceType = QTabletEvent::XFreeEraser;
                     gotEraser = true;
                 }
+#ifdef Q_WS_HILDON
+                else if (devName.endsWith(XFREENAMETOUCHSCREEN)) {
+                    deviceType = QTabletEvent::Stylus;
+                    gotTouchscreen = true;
+                }
 #endif
+#endif //Q_OS_IRIX
+
                 if (deviceType == QTabletEvent::NoDevice)
                     continue;
 
+#ifdef Q_WS_HILDON
+                if (gotStylus || gotEraser || gotTouchscreen) {
+#else
                 if (gotStylus || gotEraser) {
+#endif
                     if (X11->ptrXOpenDevice)
                         dev = X11->ptrXOpenDevice(X11->display, devs->id);
 
                     if (!dev)
                         continue;
 
+#ifdef Q_WS_HILDON
+#ifdef Q_OS_FREMANTLE
+                    are_xinput_events_used = false;
+#else
+                    are_xinput_events_used = true;
+#endif
+#endif
+
                     QTabletDeviceData device_data;
                     device_data.deviceType = deviceType;
                     device_data.eventCount = 0;
@@ -2599,6 +2691,11 @@ void QApplicationPrivate::x11_initialize_style()
         case DE_CDE:
             QApplicationPrivate::app_style = QStyleFactory::create(QLatin1String("cde"));
             break;
+#ifdef Q_WS_HILDON
+        case DE_HILDON:
+            QApplicationPrivate::app_style = QStyleFactory::create(QLatin1String("hildon"));
+        break;
+#endif
         default:
             // Don't do anything
             break;
@@ -2757,6 +2854,12 @@ QString QApplicationPrivate::appName() const
     return QString::fromLocal8Bit(QT_PREPEND_NAMESPACE(appName));
 }
 
+#ifdef Q_WS_HILDON
+bool QApplicationPrivate::areXInputEventsUsed(){
+    return are_xinput_events_used;
+}
+#endif
+
 const char *QX11Info::appClass()                                // get application class
 {
     return QT_PREPEND_NAMESPACE(appClass);
@@ -3031,6 +3134,50 @@ void QApplicationPrivate::_q_alertTimeOut()
     }
 }
 
+#ifdef Q_WS_HILDON
+void QApplicationPrivate::_q_longPushTimeOut(){
+
+    const int radius= 15;
+    const QPoint globalMousePressPos(mouseGlobalXPos,mouseGlobalYPos);
+    const QPoint globalCurrentPos= QCursor::pos();
+
+    // Exits if the cursor is not in the surrounding area
+    // of the press event
+    const QPoint deltaPos= globalMousePressPos - globalCurrentPos;
+    if ( qAbs(deltaPos.x())  >= radius ||
+         qAbs(deltaPos.y())  >= radius){
+        return;
+    }
+
+    // Gets the Widget under the mouse and the relative cursor position
+    QWidget *w;
+    QPoint pos;
+
+    if (qetWidget.isNull()){
+        return;
+    }
+
+    pos = qetWidget->mapFromGlobal(globalMousePressPos);
+    w = qetWidget->childAt(pos);
+    if (!w) {
+        w= qetWidget;
+        pos= w->mapFromGlobal(globalMousePressPos);
+    }
+
+    //Emulates the following events in the correct order
+    QMouseEvent mpe( QEvent::MouseButtonPress, pos, Qt::RightButton, 
+                     mouse_buttons, modifier_buttons );
+    QApplication::sendSpontaneousEvent(w, &mpe);
+
+    QContextMenuEvent e(QContextMenuEvent::Mouse, pos, modifier_buttons);
+    QApplication::sendSpontaneousEvent(w, &e);
+
+    QMouseEvent mre( QEvent::MouseButtonPress, pos, Qt::RightButton, 
+                     mouse_buttons, modifier_buttons );
+    QApplication::sendSpontaneousEvent(w, &mre);
+}
+#endif
+
 /*****************************************************************************
   Special lookup functions for windows that have been reparented recently
  *****************************************************************************/
@@ -3124,10 +3271,30 @@ int QApplication::x11ClientMessage(QWidget* w, XEvent* event, bool passive_only)
             X11->xdndHandleDrop(widget, event, passive_only);
         } else if (event->xclient.message_type == ATOM(XdndFinished)) {
             X11->xdndHandleFinished(widget, event, passive_only);
+#ifdef Q_WS_HILDON
+        } else if (event->xclient.message_type == ATOM(_MB_GRAB_TRANSFER)) {
+
+            if (passive_only || !QApplicationPrivate::active_window)
+                return 0;
+
+            QMainWindow *mw=qobject_cast<QMainWindow*>(widget);
+            if (mw)
+              mw->showApplicationContextMenu();
+#endif
         } else {
             if (passive_only) return 0;
             // All other are interactions
+
         }
+#ifdef Q_WS_HILDON
+    } else if (event->xclient.message_type == ATOM(_HILDON_IM_INSERT_UTF8)
+            || event->xclient.message_type == ATOM(_HILDON_IM_COM)
+            || event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING)
+            || event->xclient.message_type == ATOM(_HILDON_IM_SURROUNDING_CONTENT)) {
+        QInputContext *qic = w->inputContext();
+        if (qic && qic->x11FilterEvent(w, event))
+            return 0;
+#endif
     } else {
         X11->motifdndHandle(widget, event, passive_only);
     }
@@ -4254,13 +4421,26 @@ bool QETWidget::translateMouseEvent(const XEvent *event)
                 mouseButtonPressed == button &&
                 (long)event->xbutton.time -(long)mouseButtonPressTime
                 < QApplication::doubleClickInterval() &&
+#ifndef Q_WS_HILDON
                 qAbs(event->xbutton.x - mouseXPos) < 5 &&
                 qAbs(event->xbutton.y - mouseYPos) < 5) {
+#else
+                //Increasing the double click radius for fingers taps
+                qAbs(event->xbutton.x - mouseXPos) < 20 &&
+                qAbs(event->xbutton.y - mouseYPos) < 20) {
+#endif
                 type = QEvent::MouseButtonDblClick;
                 mouseButtonPressTime -= 2000;        // no double-click next time
             } else {
                 type = QEvent::MouseButtonPress;
                 mouseButtonPressTime = event->xbutton.time;
+#ifdef Q_WS_HILDON
+                qetWidget=this;
+                longPushTimer= new QTimer(qApp);// RMB emulation
+                longPushTimer->setSingleShot(true);
+                connect(longPushTimer, SIGNAL(timeout()),qApp, SLOT(_q_longPushTimeOut()));
+                longPushTimer->start(RIGHT_CLICK_TIME);
+#endif
             }
             mouseButtonPressed = button;        // save event params for
             mouseXPos = event->xbutton.x;                // future double click tests
@@ -4286,6 +4466,11 @@ bool QETWidget::translateMouseEvent(const XEvent *event)
             }
 #endif
             type = QEvent::MouseButtonRelease;
+#ifdef Q_WS_HILDON
+            //Prevent crashes when the application doesn't receive a mouse press button
+            if (longPushTimer)
+                longPushTimer->stop();
+#endif
         }
     }
     mouseActWindow = effectiveWinId();                        // save some event params
diff --git a/src/gui/kernel/qkeysequence.cpp b/src/gui/kernel/qkeysequence.cpp
index 22dd30b..67e7ee9 100644
--- a/src/gui/kernel/qkeysequence.cpp
+++ b/src/gui/kernel/qkeysequence.cpp
@@ -519,8 +519,14 @@ const QKeyBinding QKeySequencePrivate::keyBindings[] = {
     {QKeySequence::WhatsThis,               1,          Qt::SHIFT | Qt::Key_F1,                 QApplicationPrivate::KB_All},
     {QKeySequence::FindPrevious,            0,          Qt::SHIFT | Qt::Key_F3,                 QApplicationPrivate::KB_X11},
     {QKeySequence::FindPrevious,            1,          Qt::SHIFT | Qt::Key_F3,                 QApplicationPrivate::KB_Win},
+#ifdef Q_WS_HILDON
+    {QKeySequence::ZoomIn,                  1,          Qt::Key_F7,                             QApplicationPrivate::KB_Hildon},
+#endif
     {QKeySequence::ZoomIn,                  1,          Qt::CTRL | Qt::Key_Plus,                QApplicationPrivate::KB_All},
     {QKeySequence::NextChild,               0,          Qt::CTRL | Qt::Key_Comma,               QApplicationPrivate::KB_KDE},
+#ifdef Q_WS_HILDON
+    {QKeySequence::ZoomOut,                 1,          Qt::Key_F8,                             QApplicationPrivate::KB_Hildon},
+#endif
     {QKeySequence::ZoomOut,                 1,          Qt::CTRL | Qt::Key_Minus,               QApplicationPrivate::KB_All},
     {QKeySequence::PreviousChild,           0,          Qt::CTRL | Qt::Key_Period,              QApplicationPrivate::KB_KDE},
     {QKeySequence::HelpContents,            1,          Qt::CTRL | Qt::Key_Question,            QApplicationPrivate::KB_Mac},
diff --git a/src/gui/kernel/qt_x11_p.h b/src/gui/kernel/qt_x11_p.h
index b36b3f4..adcaea5 100644
--- a/src/gui/kernel/qt_x11_p.h
+++ b/src/gui/kernel/qt_x11_p.h
@@ -324,6 +324,9 @@ enum DesktopEnvironment {
     DE_KDE,
     DE_GNOME,
     DE_CDE,
+#ifdef Q_WS_HILDON
+    DE_HILDON,
+#endif
     DE_4DWM
 };
 
@@ -598,6 +601,9 @@ struct QX11Data
         _NET_WM_WINDOW_TYPE_DND,
         _NET_WM_WINDOW_TYPE_NORMAL,
         _KDE_NET_WM_WINDOW_TYPE_OVERRIDE,
+#ifdef Q_OS_FREMANTLE
+        _HILDON_WM_WINDOW_TYPE_APP_MENU,
+#endif
 
         _KDE_NET_WM_FRAME_STRUT,
 
@@ -610,6 +616,11 @@ struct QX11Data
 
         _NET_SYSTEM_TRAY_VISUAL,
 
+        // Hildon Menu
+#ifdef Q_WS_HILDON
+        _MB_GRAB_TRANSFER,
+#endif
+
         // Property formats
         COMPOUND_TEXT,
         TEXT,
@@ -648,6 +659,22 @@ struct QX11Data
         // Xkb
         _XKB_RULES_NAMES,
 
+#ifdef Q_WS_HILDON
+        _HILDON_IM_WINDOW,
+        _HILDON_IM_ACTIVATE,
+        _HILDON_IM_SURROUNDING,
+        _HILDON_IM_SURROUNDING_CONTENT,
+        _HILDON_IM_KEY_EVENT,
+        _HILDON_IM_INSERT_UTF8,
+        _HILDON_IM_COM,
+        _HILDON_IM_CLIPBOARD_COPIED,          //### NOT USED
+        _HILDON_IM_CLIPBOARD_SELECTION_QUERY, //### NOT USED
+        _HILDON_IM_CLIPBOARD_SELECTION_REPLY,
+        _HILDON_IM_INPUT_MODE,
+        _HILDON_IM_PREEDIT_COMMITTED,
+        _HILDON_IM_PREEDIT_COMMITTED_CONTENT,
+#endif
+
         // XEMBED
         _XEMBED,
         _XEMBED_INFO,
diff --git a/src/gui/kernel/qwidget.cpp b/src/gui/kernel/qwidget.cpp
index e6a5ae0..1c0b019 100644
--- a/src/gui/kernel/qwidget.cpp
+++ b/src/gui/kernel/qwidget.cpp
@@ -8480,6 +8480,10 @@ QVariant QWidget::inputMethodQuery(Qt::InputMethodQuery query) const
         return QRect(width()/2, 0, 1, height());
     case Qt::ImFont:
         return font();
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:
+        return QVariant(HILDON_GTK_INPUT_MODE_FULL);
+#endif
     default:
         return QVariant();
     }
@@ -10376,6 +10380,21 @@ Qt::HANDLE QWidget::handle() const
 }
 #endif
 
+#if defined (Q_WS_HILDON)
+/*!
+    Returnsint QWidget::hildonStackableWindow() const the number of the item in the Hildon Windows Stack
+ */
+int QWidget::hildonStackableWindow() const
+{
+    Q_D(const QWidget);
+
+    QWidget *mWindow = window();
+    QTLWExtra *x = mWindow->d_func()->topData();
+    Q_ASSERT(x);
+
+    return x->hildonStackableWindow;
+}
+#endif
 
 /*!
     Raises this widget to the top of the parent widget's stack.
diff --git a/src/gui/kernel/qwidget.h b/src/gui/kernel/qwidget.h
index 40ff671..8f4c347 100644
--- a/src/gui/kernel/qwidget.h
+++ b/src/gui/kernel/qwidget.h
@@ -586,6 +586,10 @@ public:
     Qt::HANDLE handle() const;
 #endif
 
+#if defined(Q_WS_HILDON)
+    int hildonStackableWindow() const;
+#endif
+
     void setAttribute(Qt::WidgetAttribute, bool on = true);
     inline bool testAttribute(Qt::WidgetAttribute) const;
 
diff --git a/src/gui/kernel/qwidget_p.h b/src/gui/kernel/qwidget_p.h
index d6cc4f7..d83d3e4 100644
--- a/src/gui/kernel/qwidget_p.h
+++ b/src/gui/kernel/qwidget_p.h
@@ -149,6 +149,10 @@ struct QTLWExtra {
     HICON winIconBig; // internal big Windows icon
     HICON winIconSmall; // internal small Windows icon
 #endif
+#ifdef Q_WS_HILDON
+    bool customContextSet;
+    int hildonStackableWindow;
+#endif
     QRect normalGeometry; // used by showMin/maximized/FullScreen
     QWindowSurface *windowSurface;
     QPainter *sharedPainter;
@@ -223,6 +227,11 @@ public:
     void setMaxWindowState_helper();
     void setFullScreenSize_helper();
 #endif
+#ifdef Q_WS_HILDON
+    bool setCustomContext();
+    bool setHildonStackableWindows(int item);
+    int  hildonStackableWindow();
+#endif
     void init(QWidget *desktopWidget, Qt::WindowFlags f);
     void create_sys(WId window, bool initializeWindow, bool destroyOldWindow);
     void createRecursively();
diff --git a/src/gui/kernel/qwidget_x11.cpp b/src/gui/kernel/qwidget_x11.cpp
index c7b32f2..33005b2 100644
--- a/src/gui/kernel/qwidget_x11.cpp
+++ b/src/gui/kernel/qwidget_x11.cpp
@@ -68,6 +68,10 @@
 
 #include <stdlib.h>
 
+#ifdef Q_WS_HILDON
+#  include "qvarlengtharray.h"
+#endif
+
 //#define ALIEN_DEBUG
 
 // defined in qapplication_x11.cpp
@@ -177,6 +181,9 @@ static void SetMWMHints(Display *display, Window window, const QtMWMHints &mwmhi
 static inline bool isTransient(const QWidget *w)
 {
     return ((w->windowType() == Qt::Dialog
+#ifdef Q_OS_FREMANTLE
+             || w->windowType() == Qt::HildonAppMenu
+#endif
              || w->windowType() == Qt::Sheet
              || w->windowType() == Qt::Tool
              || w->windowType() == Qt::SplashScreen
@@ -452,6 +459,9 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
     bool topLevel = (flags & Qt::Window);
     bool popup = (type == Qt::Popup);
     bool dialog = (type == Qt::Dialog
+#ifdef Q_OS_FREMANTLE
+                   || type == Qt::HildonAppMenu
+#endif
                    || type == Qt::Sheet);
     bool desktop = (type == Qt::Desktop);
     bool tool = (type == Qt::Tool || type == Qt::SplashScreen
@@ -757,7 +767,10 @@ void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyO
         Atom protocols[4];
         int n = 0;
         protocols[n++] = ATOM(WM_DELETE_WINDOW);        // support del window protocol
+#ifndef Q_OS_FREMANTLE
+	//This is just a workaround
         protocols[n++] = ATOM(WM_TAKE_FOCUS);                // support take focus window protocol
+#endif
         protocols[n++] = ATOM(_NET_WM_PING);                // support _NET_WM_PING protocol
         if (flags & Qt::WindowContextHelpButtonHint)
             protocols[n++] = ATOM(_NET_WM_CONTEXT_HELP);
@@ -1993,7 +2006,12 @@ void QWidgetPrivate::setNetWmWindowTypes()
         // splash netwm type
         windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_SPLASH));
         break;
-
+#ifdef Q_OS_FREMANTLE
+    case Qt::HildonAppMenu:
+        //Hildon application menu
+        windowTypes.append(ATOM(_HILDON_WM_WINDOW_TYPE_APP_MENU));
+        break;
+#endif
     default:
         break;
     }
@@ -2003,9 +2021,11 @@ void QWidgetPrivate::setNetWmWindowTypes()
         windowTypes.append(ATOM(_KDE_NET_WM_WINDOW_TYPE_OVERRIDE));
     }
 
-    // normal netwm type - default
-    windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_NORMAL));
+    if (windowTypes.isEmpty()) {
+        windowTypes.append(ATOM(_NET_WM_WINDOW_TYPE_NORMAL));
+    }
 
+    //FIXME Upstream Qt bug: XDeleteProperty won't never executed.
     if (!windowTypes.isEmpty()) {
         XChangeProperty(X11->display, q->winId(), ATOM(_NET_WM_WINDOW_TYPE), XA_ATOM, 32,
                         PropModeReplace, (unsigned char *) windowTypes.constData(),
@@ -2624,6 +2644,10 @@ void QWidgetPrivate::createTLSysExtra()
     extra->topextra->validWMState = 0;
     extra->topextra->waitingForMapNotify = 0;
     extra->topextra->userTimeWindow = 0;
+#ifdef Q_WS_HILDON
+    extra->topextra->customContextSet = 0;
+    extra->topextra->hildonStackableWindow = -1;
+#endif
 }
 
 void QWidgetPrivate::deleteTLSysExtra()
@@ -2853,6 +2877,71 @@ void QWidgetPrivate::setModal_sys()
 {
 }
 
+#ifdef Q_WS_HILDON
+/*
+    Sets the _NET_WM_CONTEXT_CUSTOM atom on the root window
+    then Hildon knows that the app is capable to display a global menu
+ */
+bool QWidgetPrivate::setCustomContext()
+{
+    Q_Q(QWidget);
+
+    QWidget *window = q->window();
+    QTLWExtra *x = window->d_func()->topData();
+    Q_ASSERT(x);
+
+    if (x->customContextSet)
+        return true;
+
+    WId windowHandle = window->winId();
+    Atom *oldAtoms = 0;
+    int count = 0;
+
+    if (!XGetWMProtocols(QX11Info::display(), windowHandle, &oldAtoms, &count)) {
+        qWarning("Hildon Integration: Unable to get WM Protocols");
+        return false;
+    }
+    Atom customContext = XInternAtom (QX11Info::display(), "_NET_WM_CONTEXT_CUSTOM", false);
+
+    // create a new list of atoms
+    QVarLengthArray<Atom, 8> newAtoms; //FIXME is the prealloc value okay?
+    newAtoms.append(oldAtoms, count);
+    newAtoms.append(customContext);
+    XFree(oldAtoms);
+
+    if (!XSetWMProtocols(QX11Info::display(), windowHandle, newAtoms.data(), newAtoms.count())) {
+        qWarning("Hildon Integration: Unable to set WM Protocols");
+        return false;
+    }
+
+    x->customContextSet = 1;
+    return true;
+}
+
+bool QWidgetPrivate::setHildonStackableWindows(int item)
+{
+    Q_Q(QWidget);
+
+    QWidget *window = q->window();
+    QTLWExtra *x = window->d_func()->topData();
+    Q_ASSERT(x);
+
+    if (x->hildonStackableWindow >= 0)
+        return false;
+
+    x->hildonStackableWindow = item;
+
+    WId windowHandle = window->winId();
+    
+    //TODO Move in the Qt Atom list
+    Atom hildonStackableWindows = XInternAtom (QX11Info::display(), "_HILDON_STACKABLE_WINDOW", false);
+    XChangeProperty(X11->display, q->winId(), hildonStackableWindows, XA_INTEGER, 32, PropModeAppend, (uchar *)&item, 1);
+
+    return true;
+}
+
+#endif
+
 void qt_x11_getX11InfoForWindow(QX11Info * xinfo, const QX11WindowAttributes &att)
 {
     QX11InfoData* xd = xinfo->getX11Data(true);
diff --git a/src/gui/maemo/maemo.pri b/src/gui/maemo/maemo.pri
new file mode 100644
index 0000000..000883c
--- /dev/null
+++ b/src/gui/maemo/maemo.pri
@@ -0,0 +1,8 @@
+# Qt Maemo module
+
+HEADERS += \
+           maemo/qhildonappmenu.h \
+           maemo/qhildonappmenu_p.h
+SOURCES += \
+           maemo/qhildonappmenu.cpp
+
diff --git a/src/gui/maemo/qhildonappmenu.cpp b/src/gui/maemo/qhildonappmenu.cpp
new file mode 100644
index 0000000..62b48f9
--- /dev/null
+++ b/src/gui/maemo/qhildonappmenu.cpp
@@ -0,0 +1,155 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: antonio.aloisio@nokia.com
+**
+**
+** GNU General Public License Usage
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+****************************************************************************/
+#include "qhildonappmenu.h"
+#include "private/qhildonappmenu_p.h"//TODO Add private and copy it in include directory
+
+#include <qlayout.h>
+#include <qpushbutton.h>
+#include <qaction.h>
+#include <qlayout.h>
+#include <qdesktopwidget.h>
+#include <qapplication.h>
+
+QT_BEGIN_NAMESPACE
+
+void QHildonAppMenuPrivate::init(){
+    Q_Q(QHildonAppMenu);
+    q->setAttribute(Qt::WA_DeleteOnClose);
+    action = 0;
+
+    desktop = QApplication::desktop();
+    QObject::connect(desktop, SIGNAL(resized(int)), q, SLOT(_q_screenResized(int)));
+    updateSize();
+
+    gridLayout = new QGridLayout(q);
+    gridLayout->setSpacing(0);
+}
+
+void QHildonAppMenuPrivate::createButtons(QList<QAction*> actions){
+    QAction *action;
+    foreach(action, actions){
+        if (action->isVisible() && 
+            action->isEnabled() &&
+            !action->isSeparator() &&
+            !action->menu())
+        addButton(action);
+    }
+}
+
+void QHildonAppMenuPrivate::addButton(QAction* action){
+    Q_Q(QHildonAppMenu);
+
+    int row, culumn;
+    QPushButton *pushButton = new QPushButton(q);
+    pushButton->setMinimumSize(QSize(0, 65));
+    pushButton->setText(action->text());
+    buttonList.insert(pushButton, action);
+    
+    switch(menuMode){
+    case Landscape:
+        culumn = ((buttonList.count() % 2) == 0) ? 1 : 0;
+        row = (buttonList.count() - culumn)/ 2;
+        break;
+    case Portrait:
+        culumn = 0;
+        row = gridLayout->rowCount();
+    }
+
+    gridLayout->addWidget(pushButton, row, culumn);
+
+    QObject::connect(pushButton, SIGNAL(clicked()), q, SLOT(_q_activateAction()));
+}
+
+void QHildonAppMenuPrivate::updateSize(){
+    Q_Q(QHildonAppMenu);
+    int menuWidth = desktop->screenGeometry(q).width() -100;
+    q->resize(menuWidth, 100);
+    menuMode = (menuWidth > 480) ? Landscape : Portrait; 
+}
+#if 0
+void QHildonAppMenuPrivate::_q_activateAction()
+{
+    Q_Q(QHildonAppMenu);
+
+    QAction *action = buttonList[sender()];
+    //qDebug() << "activate QAction sender=" << sender();
+    if (action)
+        action->activate(QAction::Trigger);
+    else
+        qWarning("Impossible to activate the action");
+
+}
+#endif 
+
+/*!
+    \class QHildonAppMenu
+    \brief The QHildonAppMenu class is the default Maemo5 Application Menu widget.
+
+    \ingroup menu
+
+    \mainclass
+    QHildoinAppMenu shows QActions in a widget like the HildonAppMenu.
+    This class should not be used by developer. It should be just for internal use.
+    
+    QHildonAppMenu shows actions that are enabled and visible. 
+    Separator or menu QActions won't be shown.
+
+    The widget is destroyed as soon as a button is clicked or if the user click outside the 
+    menu.
+*/
+
+QHildonAppMenu::QHildonAppMenu(QList<QAction*> actions, QWidget *parent)
+    : QDialog(*new QHildonAppMenuPrivate, parent, QFlag(Qt::HildonAppMenu))
+{
+    Q_D(QHildonAppMenu);
+    d->init();
+    d->createButtons(actions);
+}
+
+QHildonAppMenu::~QHildonAppMenu()
+{
+}
+
+void QHildonAppMenu::hideEvent(QHideEvent * event)
+{
+    Q_D(QHildonAppMenu);
+    Q_UNUSED(event);
+    QAction *action = d->action;
+    if (action)
+        action->activate(QAction::Trigger);
+    done(0);
+}
+
+void QHildonAppMenu::_q_activateAction()
+{
+    Q_D(QHildonAppMenu);
+
+    QAction *action = d->buttonList[sender()];
+    if (action){
+        d->action = action;
+        hide();
+    }else{
+        qWarning("Impossible to activate the action");
+    }
+}
+
+void QHildonAppMenu::_q_screenResized(int screen)
+{
+    Q_UNUSED(screen);
+    //Close the menu so that we don't care about
+    //sorting the buttons again.
+    done(1);    
+}
\ No newline at end of file
diff --git a/src/gui/maemo/qhildonappmenu.h b/src/gui/maemo/qhildonappmenu.h
new file mode 100644
index 0000000..a38e5c6
--- /dev/null
+++ b/src/gui/maemo/qhildonappmenu.h
@@ -0,0 +1,53 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: antonio.aloisio@nokia.com
+**
+**
+** GNU General Public License Usage
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+****************************************************************************/
+#ifndef QHILDONAPPMENU_H
+#define QHILDONAPPMENU_H
+
+#include <QtGui/qdialog.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+class QHildonAppMenuPrivate;
+
+class Q_GUI_EXPORT QHildonAppMenu : public QDialog
+{
+    Q_OBJECT
+
+public:
+    explicit QHildonAppMenu(QList<QAction*> actions, QWidget *parent = 0);
+    virtual ~QHildonAppMenu();
+    void hideEvent(QHideEvent * event);
+
+private:
+    Q_DECLARE_PRIVATE(QHildonAppMenu)
+    Q_DISABLE_COPY(QHildonAppMenu)
+
+    //FIXME Doesn't compile :( 
+    //Q_PRIVATE_SLOT(d_func(), void _q_activateAction())
+private Q_SLOTS:
+    void _q_activateAction();
+    void _q_screenResized(int screen);
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QDIALOG_H
diff --git a/src/gui/maemo/qhildonappmenu_p.h b/src/gui/maemo/qhildonappmenu_p.h
new file mode 100644
index 0000000..bbd48a7
--- /dev/null
+++ b/src/gui/maemo/qhildonappmenu_p.h
@@ -0,0 +1,49 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: antonio.aloisio@nokia.com
+**
+**
+** GNU General Public License Usage
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+****************************************************************************/
+#ifndef QHILDONAPPMENU_P_H
+#define QHILDONAPPMENU_P_H
+
+#include "private/qdialog_p.h"
+#include "QtGui/qhildonappmenu.h" 
+
+QT_BEGIN_NAMESPACE
+
+class QGridLayout;
+class QAction;
+class QDesktopWidget;
+
+class QHildonAppMenuPrivate : public QDialogPrivate
+{
+    Q_DECLARE_PUBLIC(QHildonAppMenu)
+public:
+    enum orientation { Landscape, Portrait };
+    inline QHildonAppMenuPrivate(){};
+    void init();
+    void createButtons(QList<QAction*> actions);
+    void addButton(QAction* action);
+    void updateSize();
+
+    QAction *action;
+    QGridLayout *gridLayout;
+    QHash<QObject*, QAction*> buttonList;
+    QDesktopWidget * desktop; 
+    orientation menuMode; 
+    //void _q_activateAction();
+};
+
+QT_END_NAMESPACE    
+
+#endif
diff --git a/src/gui/styles/gtksymbols.cpp b/src/gui/styles/gtksymbols.cpp
index be9b10a..68cb275 100644
--- a/src/gui/styles/gtksymbols.cpp
+++ b/src/gui/styles/gtksymbols.cpp
@@ -103,6 +103,9 @@ Ptr_gtk_frame_new QGtk::gtk_frame_new = 0;
 Ptr_gtk_expander_new QGtk::gtk_expander_new = 0;
 Ptr_gtk_statusbar_new QGtk::gtk_statusbar_new = 0;
 Ptr_gtk_entry_new QGtk::gtk_entry_new = 0;
+#ifdef Q_OS_FREMANTLE
+Ptr_gtk_text_view_new QGtk::gtk_text_view_new = 0;
+#endif
 Ptr_gtk_hscale_new QGtk::gtk_hscale_new = 0;
 Ptr_gtk_vscale_new QGtk::gtk_vscale_new = 0;
 Ptr_gtk_hscrollbar_new QGtk::gtk_hscrollbar_new = 0;
@@ -173,6 +176,11 @@ Ptr_gtk_file_chooser_get_filenames QGtk::gtk_file_chooser_get_filenames = 0;
 Ptr_gtk_file_chooser_set_current_name QGtk::gtk_file_chooser_set_current_name = 0;
 Ptr_gtk_dialog_run QGtk::gtk_dialog_run = 0;
 Ptr_gtk_file_chooser_set_filename QGtk::gtk_file_chooser_set_filename = 0;
+#ifdef Q_WS_HILDON
+Ptr_hildon_file_chooser_dialog_new QGtk::hildon_file_chooser_dialog_new = 0;
+Ptr_hildon_file_chooser_dialog_set_extension QGtk::hildon_file_chooser_dialog_set_extension = 0;
+Ptr_hildon_file_chooser_dialog_add_extensions_combo QGtk::hildon_file_chooser_dialog_add_extensions_combo = 0;
+#endif
 
 Ptr_gdk_pixbuf_get_pixels QGtk::gdk_pixbuf_get_pixels = 0;
 Ptr_gdk_pixbuf_get_width QGtk::gdk_pixbuf_get_width = 0;
@@ -192,6 +200,11 @@ Ptr_gdk_x11_drawable_get_xdisplay QGtk::gdk_x11_drawable_get_xdisplay = 0;
 Ptr_gconf_client_get_default QGtk::gconf_client_get_default = 0;
 Ptr_gconf_client_get_string QGtk::gconf_client_get_string = 0;
 
+#ifdef Q_WS_HILDON
+Ptr_hildon_number_editor_new QGtk::hildon_number_editor_new = 0;
+Ptr_gtk_widget_set_name QGtk::gtk_widget_set_name = 0;
+#endif
+
 static QString classPath(GtkWidget *widget)
 {
     char* class_path;
@@ -208,6 +221,11 @@ static QString classPath(GtkWidget *widget)
 static void resolveGtk()
 {
     const QString GTK_PATH(QLS("gtk-x11-2.0"));
+#ifdef Q_WS_HILDON
+    const QString HILDON_PATH(QLS("hildon-1"));
+    const QString HILDONFM_PATH("hildonfm");
+#endif
+
     QGtk::gtk_init = (Ptr_gtk_init)QLibrary::resolve(GTK_PATH, 0, "gtk_init");
     QGtk::gtk_window_new = (Ptr_gtk_window_new)QLibrary::resolve(GTK_PATH, 0, "gtk_window_new");
     QGtk::gtk_style_attach = (Ptr_gtk_style_attach)QLibrary::resolve(GTK_PATH, 0, "gtk_style_attach");
@@ -227,6 +245,11 @@ static void resolveGtk()
     QGtk::gtk_file_chooser_set_current_name = (Ptr_gtk_file_chooser_set_current_name)QLibrary::resolve(GTK_PATH, 0, "gtk_file_chooser_set_current_name");
     QGtk::gtk_dialog_run = (Ptr_gtk_dialog_run)QLibrary::resolve(GTK_PATH, 0, "gtk_dialog_run");
     QGtk::gtk_file_chooser_set_filename = (Ptr_gtk_file_chooser_set_filename)QLibrary::resolve(GTK_PATH, 0, "gtk_file_chooser_set_filename");
+#ifdef Q_WS_HILDON
+    QGtk::hildon_file_chooser_dialog_new = (Ptr_hildon_file_chooser_dialog_new)QLibrary::resolve(HILDONFM_PATH, 2, "hildon_file_chooser_dialog_new");
+    QGtk::hildon_file_chooser_dialog_set_extension = (Ptr_hildon_file_chooser_dialog_set_extension)QLibrary::resolve(HILDONFM_PATH, 2, "hildon_file_chooser_dialog_set_extension");
+    QGtk::hildon_file_chooser_dialog_add_extensions_combo = (Ptr_hildon_file_chooser_dialog_add_extensions_combo)QLibrary::resolve(HILDONFM_PATH, 2, "hildon_file_chooser_dialog_add_extensions_combo");
+#endif
 
     QGtk::gdk_pixbuf_get_pixels = (Ptr_gdk_pixbuf_get_pixels)QLibrary::resolve(GTK_PATH, 0, "gdk_pixbuf_get_pixels");
     QGtk::gdk_pixbuf_get_width = (Ptr_gdk_pixbuf_get_width)QLibrary::resolve(GTK_PATH, 0, "gdk_pixbuf_get_width");
@@ -268,6 +291,9 @@ static void resolveGtk()
     QGtk::gtk_scrolled_window_new = (Ptr_gtk_scrolled_window_new)QLibrary::resolve(GTK_PATH, 0, "gtk_scrolled_window_new");
     QGtk::gtk_menu_shell_append = (Ptr_gtk_menu_shell_append)QLibrary::resolve(GTK_PATH, 0, "gtk_menu_shell_append");
     QGtk::gtk_entry_new = (Ptr_gtk_entry_new)QLibrary::resolve(GTK_PATH, 0, "gtk_entry_new");
+#ifdef Q_OS_FREMANTLE
+    QGtk::gtk_text_view_new  = (Ptr_gtk_text_view_new)QLibrary::resolve(GTK_PATH, 0, "gtk_text_view_new");
+#endif
     QGtk::gtk_tree_view_new = (Ptr_gtk_tree_view_new)QLibrary::resolve(GTK_PATH, 0, "gtk_tree_view_new");
     QGtk::gtk_combo_box_new = (Ptr_gtk_combo_box_new)QLibrary::resolve(GTK_PATH, 0, "gtk_combo_box_new");
     QGtk::gtk_progress_set_adjustment = (Ptr_gtk_progress_set_adjustment)QLibrary::resolve(GTK_PATH, 0, "gtk_progress_set_adjustment");
@@ -319,6 +345,10 @@ static void resolveGtk()
     QGtk::pango_font_description_get_weight = (Ptr_pango_font_description_get_weight)QLibrary::resolve(GTK_PATH, 0, "pango_font_description_get_weight");
     QGtk::pango_font_description_get_family = (Ptr_pango_font_description_get_family)QLibrary::resolve(GTK_PATH, 0, "pango_font_description_get_family");
     QGtk::pango_font_description_get_style = (Ptr_pango_font_description_get_style)QLibrary::resolve(GTK_PATH, 0, "pango_font_description_get_style");
+#ifdef Q_WS_HILDON
+    QGtk::hildon_number_editor_new = (Ptr_hildon_number_editor_new)QLibrary::resolve(HILDON_PATH, 0, "hildon_number_editor_new");
+    QGtk::gtk_widget_set_name = (Ptr_gtk_widget_set_name)QLibrary::resolve(GTK_PATH, 0, "gtk_widget_set_name");
+#endif
 }
 
 void QGtk::cleanup_gtk_widgets()
@@ -369,10 +399,17 @@ static QString getThemeName()
         foreach (const QString &rcPath, paths) {
             if (!rcPath.isEmpty()) {
                 QFile rcFile(rcPath);
+#ifdef Q_WS_HILDON //Fremantle
+                if (rcPath.contains(QLS("/etc/hildon/theme/gtk-2.0/gtkrc"))){
+                    QString slt = QFile::symLinkTarget("/etc/hildon/theme");
+                    themeName = slt.split(QLS("/")).last();
+                }else
+#endif
                 if (rcFile.exists() && rcFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
                     QTextStream in(&rcFile);
                     while(!in.atEnd()) {
                         QString line = in.readLine();
+#ifndef Q_WS_HILDON //Diablo
                         if (line.contains(QLS("gtk-theme-name"))) {
                             line = line.right(line.length() - line.indexOf(QLS("=")) - 1);
                             line.remove(QLS("\""));
@@ -380,6 +417,13 @@ static QString getThemeName()
                             themeName = line;
                             break;
                         }
+#else
+                        QRegExp rx("include \"/usr/share/themes/([\\d\\w]*)/gtk-2.0/gtkrc\"");
+                        if (rx.indexIn(line, 0) != -1) {
+                            themeName = rx.cap(1);
+                        }
+#endif
+
                     }
                 }
             }
@@ -470,6 +514,13 @@ static void init_gtk_menu()
     GtkWidget *gtkMenu = QGtk::gtk_menu_new();
     QGtk::gtk_menu_item_set_submenu((GtkMenuItem*)(gtkMenuBarItem), gtkMenu);
     QGtk::gtk_widget_realize(gtkMenu);
+#ifdef Q_WS_HILDON
+    //Application context menu.
+    GtkWidget *gtkContainerMenu = QGtk::gtk_menu_new();
+    QGtk::gtk_widget_set_name(gtkContainerMenu, "menu_force_with_corners");
+    QGtk::gtk_widget_realize(gtkContainerMenu);
+    add_widget_to_map(gtkContainerMenu);
+#endif
 
     GtkWidget *gtkMenuItem = QGtk::gtk_menu_item_new();
     QGtk::gtk_menu_shell_append((GtkMenuShell*)gtkMenu, gtkMenuItem);
@@ -667,6 +718,9 @@ void QGtk::initGtkWidgets()
             add_widget(QGtk::gtk_combo_box_new());
             add_widget(QGtk::gtk_combo_box_entry_new());
             add_widget(QGtk::gtk_entry_new());
+#ifdef Q_OS_FREMANTLE
+            add_widget(QGtk::gtk_text_view_new());
+#endif
             add_widget(QGtk::gtk_frame_new(NULL));
             add_widget(QGtk::gtk_expander_new(""));
             add_widget(QGtk::gtk_statusbar_new());
@@ -684,6 +738,10 @@ void QGtk::initGtkWidgets()
             init_gtk_treeview();
             add_widget(QGtk::gtk_vscale_new((GtkAdjustment*)(QGtk::gtk_adjustment_new(1, 0, 1, 0, 0, 0))));
             add_widget(QGtk::gtk_vscrollbar_new(NULL));
+#ifdef Q_WS_HILDON
+            //ComboBoxes buttons
+            add_widget(QGtk::hildon_number_editor_new(0,1));
+#endif
         }
         else // Rebuild map
         {
@@ -726,6 +784,48 @@ static void setupGtkFileChooser(GtkWidget* gtkFileChooser, QWidget *parent,
     g_object_set(gtkFileChooser, "local_only", gboolean(true), NULL);
     if (!filter.isEmpty()) {
         QStringList filters = qt_make_filter_list(filter);
+        
+#ifdef Q_WS_HILDON
+        if (isSaveDialog) {
+            const int Nfilters = filters.count();
+            char *ext_names[Nfilters];
+            char *extensions[Nfilters];
+
+            for (int i = 0; i < Nfilters; i++) {
+                const QString &rawfilter = filters[i];
+                QString name = rawfilter.left(rawfilter.indexOf(QLatin1Char('(')));
+                QString extension = extract_filter(rawfilter)[0].remove("*.");
+                //Doesn't make sense adding '*' extension in a save dialog;
+                if (extension.compare("*") == 0)
+                    qWarning("'*' is not a valid extension for a save dialog");
+                ext_names[i]= (char*) malloc(name.count()+1);
+                memcpy(ext_names[i], qPrintable(name), name.count());
+                extensions[i]= (char*) malloc(extension.count()+1);
+                memcpy(extensions[i], qPrintable(extension), extension.count());
+            }
+            ext_names[Nfilters] = NULL;
+            extensions[Nfilters] = NULL;
+
+            GtkWidget* gtkExtensionCombo;
+            gtkExtensionCombo = QGtk::hildon_file_chooser_dialog_add_extensions_combo((HildonFileChooserDialog*)(gtkFileChooser),
+                                                                                 extensions,ext_names);
+            //gtk_signal_connect (GTK_OBJECT(gtkExtensionCombo), "changed",
+            //                    GTK_SIGNAL_FUNC (qt_update_file_filter), NULL);
+        }else{
+            //Set "*.ext" filters in the open file dialogs. There we don't have a combobox to select a filter. :( 
+            //TODO the combobox in the HildonFileChooserDialog doesn't change the filter automatically. We have to se it
+            //in Qt..
+            GtkFileFilter *gtkFilter = QGtk::gtk_file_filter_new ();
+            foreach (const QString &rawfilter, filters) {
+                QStringList extensions = extract_filter(rawfilter);
+                foreach (const QString &fileExtension, extensions) {
+                    QGtk::gtk_file_filter_add_pattern (gtkFilter, qPrintable(fileExtension));
+                }
+            }
+            g_object_set(gtkFileChooser, "filter", gtkFilter, NULL);
+        }
+   
+#else
         foreach (const QString &rawfilter, filters) {
             GtkFileFilter *gtkFilter = QGtk::gtk_file_filter_new ();
             QString name = rawfilter.left(rawfilter.indexOf(QLatin1Char('(')));
@@ -739,6 +839,7 @@ static void setupGtkFileChooser(GtkWidget* gtkFileChooser, QWidget *parent,
             if (selectedFilter && (rawfilter == *selectedFilter))
                 QGtk::gtk_file_chooser_set_filter((GtkFileChooser*)gtkFileChooser, gtkFilter);
         }
+#endif
     }
 
     // Using the currently active window is not entirely correct, however
@@ -756,7 +857,11 @@ static void setupGtkFileChooser(GtkWidget* gtkFileChooser, QWidget *parent,
 
     QFileInfo fileinfo(dir);
     if (dir.isEmpty())
+#ifndef Q_WS_HILDON
+        return;
+#else
         fileinfo.setFile(QDir::currentPath());
+#endif
     fileinfo.makeAbsolute();
     if (fileinfo.isDir()) {
         QGtk::gtk_file_chooser_set_current_folder((GtkFileChooser*)gtkFileChooser, qPrintable(dir));
@@ -771,14 +876,16 @@ static void setupGtkFileChooser(GtkWidget* gtkFileChooser, QWidget *parent,
 QString QGtk::openFilename(QWidget *parent, const QString &caption, const QString &dir, const QString &filter,
                             QString *selectedFilter, QFileDialog::Options options)
 {
-
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_OPEN);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_OPEN,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                              NULL);
-
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, filter, selectedFilter, options);
 
     QWidget modal_widget;
@@ -787,27 +894,33 @@ QString QGtk::openFilename(QWidget *parent, const QString &caption, const QStrin
     QApplicationPrivate::enterModal(&modal_widget);
 
     QString filename;
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         char *gtk_filename = QGtk::gtk_file_chooser_get_filename ((GtkFileChooser*)gtkFileChooser);
         filename = QString::fromUtf8(gtk_filename);
         g_free (gtk_filename);
     }
-
     QApplicationPrivate::leaveModal(&modal_widget);
     gtk_widget_destroy (gtkFileChooser);
     return filename;
-}
 
+}
 
 QString QGtk::openDirectory(QWidget *parent, const QString &caption, const QString &dir, QFileDialog::Options options)
 {
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                              NULL);
-
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, QString(), 0, options);
     QWidget modal_widget;
     modal_widget.setAttribute(Qt::WA_NoChildEventsForParent, true);
@@ -815,7 +928,11 @@ QString QGtk::openDirectory(QWidget *parent, const QString &caption, const QStri
     QApplicationPrivate::enterModal(&modal_widget);
 
     QString filename;
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         char *gtk_filename = QGtk::gtk_file_chooser_get_filename ((GtkFileChooser*)gtkFileChooser);
         filename = QString::fromUtf8(gtk_filename);
         g_free (gtk_filename);
@@ -830,13 +947,16 @@ QStringList QGtk::openFilenames(QWidget *parent, const QString &caption, const Q
                                  QString *selectedFilter, QFileDialog::Options options)
 {
     QStringList filenames;
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_OPEN);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_OPEN,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
                                                              NULL);
-
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, filter, selectedFilter, options);
     g_object_set(gtkFileChooser, "select-multiple", gboolean(true), NULL);
 
@@ -845,7 +965,11 @@ QStringList QGtk::openFilenames(QWidget *parent, const QString &caption, const Q
     modal_widget.setParent(parent, Qt::Window);
     QApplicationPrivate::enterModal(&modal_widget);
 
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         GSList *gtk_file_names = QGtk::gtk_file_chooser_get_filenames((GtkFileChooser*)gtkFileChooser);
         for (GSList *iterator  = gtk_file_names ; iterator; iterator = iterator->next)
             filenames << QString::fromUtf8((const char*)iterator->data);
@@ -860,12 +984,16 @@ QStringList QGtk::openFilenames(QWidget *parent, const QString &caption, const Q
 QString QGtk::saveFilename(QWidget *parent, const QString &caption, const QString &dir, const QString &filter,
                            QString *selectedFilter, QFileDialog::Options options)
 {
+#ifdef Q_WS_HILDON
+    GtkWidget *gtkFileChooser = QGtk::hildon_file_chooser_dialog_new (NULL, GTK_FILE_CHOOSER_ACTION_SAVE);  
+#else
     GtkWidget *gtkFileChooser = QGtk::gtk_file_chooser_dialog_new (qPrintable(caption),
                                                              NULL,
                                                              GTK_FILE_CHOOSER_ACTION_SAVE,
                                                              GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                                                              GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
                                                              NULL);
+#endif
     setupGtkFileChooser(gtkFileChooser, parent, dir, filter, selectedFilter, options, true);
 
     QWidget modal_widget;
@@ -874,7 +1002,11 @@ QString QGtk::saveFilename(QWidget *parent, const QString &caption, const QStrin
     QApplicationPrivate::enterModal(&modal_widget);
 
     QString filename;
+#ifdef Q_WS_HILDON
+    if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_OK) {
+#else
     if (QGtk::gtk_dialog_run ((GtkDialog*)gtkFileChooser) == GTK_RESPONSE_ACCEPT) {
+#endif
         char *gtk_filename = QGtk::gtk_file_chooser_get_filename ((GtkFileChooser*)gtkFileChooser);
         filename = QString::fromUtf8(gtk_filename);
         g_free (gtk_filename);
diff --git a/src/gui/styles/gtksymbols_p.h b/src/gui/styles/gtksymbols_p.h
index b0195d2..369e337 100644
--- a/src/gui/styles/gtksymbols_p.h
+++ b/src/gui/styles/gtksymbols_p.h
@@ -58,6 +58,9 @@
 
 #undef signals // Collides with GTK stymbols
 #include <gtk/gtk.h>
+#ifdef Q_WS_HILDON
+#  include <hildon/hildon-file-chooser-dialog.h>
+#endif
 #include <QtCore/QLibrary>
 #include <QtGui/QFont>
 #include <QtGui/QFileDialog>
@@ -108,6 +111,9 @@ typedef GtkWidget* (*Ptr_gtk_scrolled_window_new)(GtkAdjustment*, GtkAdjustment*
 typedef gchar* (*Ptr_gtk_check_version)(guint, guint, guint);
 typedef GtkToolItem* (*Ptr_gtk_separator_tool_item_new) (void);
 typedef GtkWidget* (*Ptr_gtk_entry_new)(void);
+#ifdef Q_OS_FREMANTLE
+typedef GtkWidget* (*Ptr_gtk_text_view_new)(void);
+#endif
 typedef GtkWidget* (*Ptr_gtk_tree_view_new)(void);
 typedef GtkTreeViewColumn* (*Ptr_gtk_tree_view_get_column)(GtkTreeView *, gint);
 typedef GtkWidget* (*Ptr_gtk_combo_box_new)(void);
@@ -156,6 +162,7 @@ typedef gint (*Ptr_pango_font_description_get_size) (const PangoFontDescription
 typedef PangoWeight (*Ptr_pango_font_description_get_weight) (const PangoFontDescription *);
 typedef const char* (*Ptr_pango_font_description_get_family) (const PangoFontDescription *);
 typedef PangoStyle (*Ptr_pango_font_description_get_style) (const PangoFontDescription *desc);
+
 typedef gboolean (*Ptr_gtk_file_chooser_set_current_folder)(GtkFileChooser *, const gchar *);
 typedef GtkFileFilter* (*Ptr_gtk_file_filter_new)(void);
 typedef void (*Ptr_gtk_file_filter_set_name)(GtkFileFilter *, const gchar *);
@@ -173,6 +180,16 @@ typedef void (*Ptr_gtk_file_chooser_set_current_name) (GtkFileChooser *, const g
 typedef gboolean (*Ptr_gtk_file_chooser_set_filename) (GtkFileChooser *chooser, const gchar *name);
 typedef gint (*Ptr_gtk_dialog_run) (GtkDialog*);
 
+#ifdef Q_WS_HILDON
+typedef GtkWidget* (*Ptr_hildon_file_chooser_dialog_new)(GtkWindow *parent,
+                                                         GtkFileChooserAction action);
+typedef void (*Ptr_hildon_file_chooser_dialog_set_extension)(HildonFileChooserDialog *self,
+                                                             const gchar *extension);
+typedef GtkWidget* (*Ptr_hildon_file_chooser_dialog_add_extensions_combo)
+                                                        (HildonFileChooserDialog *self,
+                                                         char **extensions,
+                                                         char **ext_names);
+#endif
 typedef guchar* (*Ptr_gdk_pixbuf_get_pixels) (const GdkPixbuf *pixbuf);
 typedef int (*Ptr_gdk_pixbuf_get_width) (const GdkPixbuf *pixbuf);
 typedef void (*Ptr_gdk_color_free) (const GdkColor *);
@@ -193,6 +210,11 @@ typedef void (*Ptr_gdk_x11_window_set_user_time) (GdkWindow *window, guint32);
 typedef XID  (*Ptr_gdk_x11_drawable_get_xid) (GdkDrawable *);
 typedef Display* (*Ptr_gdk_x11_drawable_get_xdisplay) ( GdkDrawable *);
 
+#ifdef Q_WS_HILDON
+typedef GtkWidget* (*Ptr_hildon_number_editor_new) (int,int);
+typedef void (*Ptr_gtk_widget_set_name) (GtkWidget *, const gchar *);
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QGtk
@@ -241,6 +263,9 @@ public:
     static Ptr_gtk_frame_new gtk_frame_new;
     static Ptr_gtk_statusbar_new gtk_statusbar_new;
     static Ptr_gtk_entry_new gtk_entry_new;
+#ifdef Q_OS_FREMANTLE
+    static Ptr_gtk_text_view_new gtk_text_view_new;
+#endif
     static Ptr_gtk_hscale_new gtk_hscale_new;
     static Ptr_gtk_vscale_new gtk_vscale_new;
     static Ptr_gtk_hscrollbar_new gtk_hscrollbar_new;
@@ -309,6 +334,11 @@ public:
     static Ptr_gtk_file_chooser_set_current_name gtk_file_chooser_set_current_name;
     static Ptr_gtk_dialog_run gtk_dialog_run;
     static Ptr_gtk_file_chooser_set_filename gtk_file_chooser_set_filename;
+#ifdef Q_WS_HILDON
+    static Ptr_hildon_file_chooser_dialog_new hildon_file_chooser_dialog_new;
+    static Ptr_hildon_file_chooser_dialog_set_extension hildon_file_chooser_dialog_set_extension;
+    static Ptr_hildon_file_chooser_dialog_add_extensions_combo hildon_file_chooser_dialog_add_extensions_combo;
+#endif
 
     static Ptr_gdk_pixbuf_get_pixels gdk_pixbuf_get_pixels;
     static Ptr_gdk_pixbuf_get_width gdk_pixbuf_get_width;
@@ -327,6 +357,12 @@ public:
 
     static Ptr_gconf_client_get_default gconf_client_get_default;
     static Ptr_gconf_client_get_string gconf_client_get_string;
+
+#ifdef Q_WS_HILDON
+    static Ptr_hildon_number_editor_new hildon_number_editor_new;
+    static Ptr_gtk_widget_set_name gtk_widget_set_name;
+#endif
+
 };
 
 // Helper to ensure that we have polished all our gtk widgets
diff --git a/src/gui/styles/qgtkstyle.cpp b/src/gui/styles/qgtkstyle.cpp
index 218f651..6c05edb 100644
--- a/src/gui/styles/qgtkstyle.cpp
+++ b/src/gui/styles/qgtkstyle.cpp
@@ -263,8 +263,11 @@ QPalette QGtkStyle::standardPalette() const
     if (QGtk::isThemeAvailable()) {
         GtkStyle *style = QGtk::gtkStyle();
         GtkWidget *gtkButton = QGtk::gtkWidget(QLS("GtkButton"));
+#ifndef Q_OS_FREMANTLE
         GtkWidget *gtkEntry = QGtk::gtkWidget(QLS("GtkEntry"));
-
+#else
+        GtkWidget *gtkEntry = QGtk::gtkWidget(QLS("GtkTextView"));
+#endif
         GdkColor gdkBg, gdkBase, gdkText, gdkForeground, gdkSbg, gdkSfg;
         QColor bg, base, text, fg, highlight, highlightText;
         gdkBg = style->bg[GTK_STATE_NORMAL];
@@ -272,6 +275,8 @@ QPalette QGtkStyle::standardPalette() const
 
         // Our base and selected color is primarily used for text
         // so we assume a gtkEntry will have the most correct value
+        //NOTE: Reverse color in fremantle themes are set only for
+        //      GtkTextView widgets. GtkEntry returns a dark base color.
         gdkBase = gtkEntry->style->base[GTK_STATE_NORMAL];
         gdkText = gtkEntry->style->text[GTK_STATE_NORMAL];
         gdkSbg = gtkEntry->style->base[GTK_STATE_SELECTED];
@@ -1357,6 +1362,10 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                     // Required for inner blue highlight with clearlooks
                     if (focus)
                         GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+#ifndef Q_OS_FREMANTLE
+                    // Required for inner blue highlight with clearlooks
+                    if (focus)
+                        GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
 
                     if (widget && widget->testAttribute(Qt::WA_SetPalette) &&
                         resolve_mask & (1 << QPalette::Base)) // Palette overridden by user
@@ -1366,7 +1375,18 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                                                 option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE,
                                                 GTK_SHADOW_NONE, style, entryPath + QString::number(focus));
                     }
-
+#else
+                    //This code fill a rectangle in the middle of the combobox.
+                    //Using custom palette will draw a colored rectangle in the middle of the combobox.
+                    //The borders will be painted by paintShadow
+                    if (!comboBox->editable) {
+                        GdkColor gdkBg;
+                        QColor bg;
+                        gdkBg = gtkCombo->style->base[GTK_STATE_NORMAL];
+                        bg = QColor(gdkBg.red>>8, gdkBg.green>>8, gdkBg.blue>>8);
+                        p->fillRect(contentRect, bg);
+                    }
+#endif 
                     gtkCachedPainter.paintShadow(gtkEntry, comboBox->editable ? "entry" : "frame", frameRect, frameState,
                                            GTK_SHADOW_IN, gtkEntry->style, entryPath +
                                            QString::number(focus) + QString::number(comboBox->editable) +
@@ -1911,8 +1931,13 @@ void QGtkStyle::drawComplexControl(ComplexControl control, const QStyleOptionCom
                 QRect grooveRect = option->rect.adjusted(focusFrameMargin, outerSize + focusFrameMargin,
                                    -focusFrameMargin, -outerSize - focusFrameMargin);
 
+#ifdef Q_OS_FREMANTLE
+                gtkPainter.paintBox( scaleWidget, "trough-upper", grooveRect, state,
+                                     GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+#else
                 gtkPainter.paintBox( scaleWidget, "trough", grooveRect, state,
                                      GTK_SHADOW_IN, style, QString(QLS("p%0")).arg(slider->sliderPosition));
+#endif
 
                 gboolean trough_side_details = false; // Indicates if the upper or lower scale background differs
                 if (!QGtk::gtk_check_version(2, 10, 0))
@@ -2699,9 +2724,16 @@ void QGtkStyle::drawControl(ControlElement element,
                                    pixelMetric(PM_ButtonShiftVertical, option, widget));
 
                 QFontMetrics fm(menuitem->font);
+#ifdef Q_WS_HILDON
+                int arrow_size = fm.ascent() + fm.descent();
+                gfloat arrow_scaling;
+                QGtk::gtk_widget_style_get(gtkMenu, "maemo-arrow-scaling", &arrow_scaling, NULL);
+                if (arrow_scaling == 0.0)
+                    arrow_scaling = 1.0;
+#else
                 int arrow_size = fm.ascent() + fm.descent() - 2 * gtkMenuItem->style->ythickness;
                 gfloat arrow_scaling = 0.8;
-
+#endif
                 // "arrow-scaling" is actually hardcoded and fails on hardy (see gtk+-2.12/gtkmenuitem.c)
                 // though the current documentation states otherwise
                 int horizontal_padding;
diff --git a/src/gui/styles/qhildonstyle.cpp b/src/gui/styles/qhildonstyle.cpp
new file mode 100644
index 0000000..ce50316
--- /dev/null
+++ b/src/gui/styles/qhildonstyle.cpp
@@ -0,0 +1,424 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the unofficial Maemo Qt Toolkit.
+**
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the either Technology Preview License Agreement or the
+** Beta Release License Agreement.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the file LICENSE.GPL included in
+** the packaging of this file.  Please review the following information
+** to ensure GNU General Public Licensing requirements will be met:
+** http://www.fsf.org/licensing/licenses/info/GPLv2.html and
+** http://www.gnu.org/copyleft/gpl.html.  In addition, as a special
+** exception, Nokia gives you certain additional rights. These rights
+** are described in the Nokia Qt GPL Exception version 1.3, included in
+** the file GPL_EXCEPTION.txt in this package.
+**
+** Qt for Windows(R) Licensees
+** As a special exception, Nokia, as the sole copyright holder for Qt
+** Designer, grants users of the Qt/Eclipse Integration plug-in the
+** right for the Qt/Eclipse Integration to link to functionality
+** provided by Qt Designer and its related libraries.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+**
+****************************************************************************/
+
+#include "qhildonstyle.h"
+
+#include <QtGui/QStyleOption>
+#include <QDebug>
+
+#include "qgtkpainter_p.h"
+
+#if !defined(QT_NO_STYLE_HILDON) && defined(Q_WS_HILDON)
+
+QT_BEGIN_NAMESPACE
+
+//Belongs to QGTKStyle
+static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
+{
+    const int maxFactor = 100;
+    QColor tmp = colorA;
+    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
+    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
+    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
+    return tmp;
+}
+
+/*!
+    \class QHildonStyle
+    \brief The QHildonStyle class provides a widget style rendered by GTK+
+
+    The QHildonStyle style provides a look and feel that integrates well
+    into Hildon-based desktop environments.
+
+    It's based on QGTKStyle.
+
+    Note: The style requires GTK+ version 2.10 or later.
+          The Qt3-based "Qt" GTK+ theme engine will not work with QGtkStyle.
+*/
+
+/*!
+    Constructs a QGtkStyle object.
+*/
+QHildonStyle::QHildonStyle()
+{
+}
+
+/*!
+    Destroys the QHildonStyle object.
+*/
+QHildonStyle::~QHildonStyle()
+{
+}
+
+QPalette QHildonStyle::standardPalette() const
+{
+    return QGtkStyle::standardPalette();
+}
+
+void QHildonStyle::polish(QPalette &palette)
+{
+    QGtkStyle::polish(palette);
+}
+
+void QHildonStyle::polish(QApplication *app)
+{
+    QGtkStyle::polish(app);
+}
+
+void QHildonStyle::unpolish(QApplication *app)
+{
+    QGtkStyle::unpolish(app);
+}
+
+void QHildonStyle::polish(QWidget *widget)
+{
+    QGtkStyle::polish(widget);
+}
+
+void QHildonStyle::unpolish(QWidget *widget)
+{
+    QGtkStyle::unpolish(widget);
+}
+
+int QHildonStyle::pixelMetric(PixelMetric metric,
+                           const QStyleOption *option,
+                           const QWidget *widget) const
+{
+   if (!QGtk::isThemeAvailable())
+        return QCleanlooksStyle::pixelMetric(metric, option, widget);
+   
+   switch (metric) {
+    //coordinate of the Application Context Menu upper left corner.
+    case PM_MenuOffsetHorizontal:
+    {
+        GtkWidget *gtkMenu = QGtk::gtkWidget("menu_force_with_corners");
+        gint horizontal_offset;
+        QGtk::gtk_widget_style_get(gtkMenu, "horizontal-offset", &horizontal_offset, NULL);
+        return horizontal_offset;
+    }
+    case PM_MenuOffsetVertical:
+    {
+        GtkWidget *gtkMenu = QGtk::gtkWidget("menu_force_with_corners");
+        gint vertical_offset;
+        QGtk::gtk_widget_style_get(gtkMenu, "vertical-offset", &vertical_offset, NULL);
+        return vertical_offset;
+    }
+    default:
+        return  QGtkStyle::pixelMetric(metric, option, widget);
+    }
+}
+
+int QHildonStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
+                         QStyleHintReturn *returnData = 0) const
+{
+    if (!QGtk::isThemeAvailable())
+        return QCleanlooksStyle::styleHint(hint, option, widget, returnData);
+
+    switch (hint) {
+    case SH_Menu_Scrollable:
+        return int(true);
+    case SH_DialogButtonBox_ButtonsHaveIcons:
+    case SH_ScrollBar_ContextMenu:
+        return int(false);
+    default:
+        return QGtkStyle::styleHint(hint, option, widget, returnData);
+    }
+}
+
+void QHildonStyle::drawPrimitive(PrimitiveElement element,
+                              const QStyleOption *option,
+                              QPainter *painter,
+                              const QWidget *widget) const
+{
+    if (!QGtk::isThemeAvailable()) {
+        QCleanlooksStyle::drawPrimitive(element, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = QGtk::gtkStyle();
+    QGtkPainter gtkPainter(painter);
+
+    switch (element) {
+    case PE_FrameLineEdit: {
+        GtkWidget *gtkEntry = QGtk::gtkWidget(QLS("GtkEntry"));
+
+        if (option->state & State_HasFocus)
+            GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+        else
+            GTK_WIDGET_UNSET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+
+        gboolean interior_focus;
+        gint focus_line_width;
+        QRect rect = option->rect;
+        QGtk::gtk_widget_style_get(gtkEntry,
+                               "interior-focus", &interior_focus,
+                               "focus-line-width", &focus_line_width, NULL);
+        
+        //Paint the LineEdits borders.
+        gtkPainter.paintFlatBox(gtkEntry, "entry_bg", rect,
+                                  option->state & State_Enabled ? GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, GTK_SHADOW_NONE, gtkEntry->style);
+
+        if (!interior_focus && option->state & State_HasFocus)
+            rect.adjust(focus_line_width, focus_line_width, -focus_line_width, -focus_line_width);
+
+        gtkPainter.paintShadow(gtkEntry, "entry", rect, option->state & State_Enabled ? 
+                               GTK_STATE_NORMAL : GTK_STATE_INSENSITIVE, 
+                               GTK_SHADOW_IN, gtkEntry->style,
+                               option->state & State_HasFocus ? QLS("focus") : QString());
+
+        if (!interior_focus && option->state & State_HasFocus)
+            gtkPainter.paintShadow(gtkEntry, "entry", option->rect, option->state & State_Enabled ? 
+                                   GTK_STATE_ACTIVE : GTK_STATE_INSENSITIVE,
+                                   GTK_SHADOW_IN, gtkEntry->style, QLS("GtkEntryShadowIn"));
+
+    }
+    break;
+
+    case PE_PanelLineEdit: {
+        QCleanlooksStyle::drawPrimitive(element, option, painter, widget);
+    }
+    break;
+
+    default:
+        QGtkStyle::drawPrimitive(element, option, painter, widget);
+    }
+}
+
+void QHildonStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                                   QPainter *painter, const QWidget *widget) const
+{
+    if (!QGtk::isThemeAvailable()) {
+        QCleanlooksStyle::drawComplexControl(control, option, painter, widget);
+        return;
+    }
+
+    GtkStyle* style = QGtk::gtkStyle();
+    QGtkPainter gtkPainter(painter);
+    QColor button = option->palette.button().color();
+    QColor dark;
+    QColor grooveColor;
+    QColor darkOutline;
+    dark.setHsv(button.hue(),
+                qMin(255, (int)(button.saturation()*1.9)),
+                qMin(255, (int)(button.value()*0.7)));
+    grooveColor.setHsv(button.hue(),
+                       qMin(255, (int)(button.saturation()*2.6)),
+                       qMin(255, (int)(button.value()*0.9)));
+    darkOutline.setHsv(button.hue(),
+                       qMin(255, (int)(button.saturation()*3.0)),
+                       qMin(255, (int)(button.value()*0.6)));
+
+    QColor alphaCornerColor;
+
+    if (widget)
+        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), darkOutline);
+    else
+        alphaCornerColor = mergedColors(option->palette.background().color(), darkOutline);
+
+    QPalette palette = option->palette;
+
+    switch (control) {
+    #ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            GtkWidget *gtkSpinButton = QGtk::gtkWidget(QLS("GtkSpinButton"));
+            bool isEnabled = (spinBox->state & State_Enabled);
+            bool hover = isEnabled && (spinBox->state & State_MouseOver);
+            bool sunken = (spinBox->state & State_Sunken);
+            bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
+            bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
+            bool reverse = (spinBox->direction == Qt::RightToLeft);
+
+            GtkWidget *gtkEntry = QGtk::gtkWidget("HildonNumberEditor.GtkEntry");
+            GtkWidget *gtkMinusButton = QGtk::gtkWidget("HildonNumberEditor.ne-minus-button");
+            GtkWidget *gtkPlusButton = QGtk::gtkWidget("HildonNumberEditor.ne-plus-button");
+            int xt = gtkEntry->style->xthickness;
+            int yt = gtkEntry->style->ythickness;
+            QRect plusRect = subControlRect(CC_SpinBox, option, SC_SpinBoxUp, widget);
+            QRect minusRect = subControlRect(CC_SpinBox, option, SC_SpinBoxDown, widget);
+            QRect entryRect = subControlRect(CC_SpinBox, option, SC_SpinBoxEditField, widget).adjusted(-xt, -yt, xt, yt);
+
+            /* TODO: Do not replicate code from PE_FrameLineEdit */
+            gboolean interior_focus;
+            gint focus_line_width;
+            QRect rect = entryRect;
+            QGtk::gtk_widget_style_get(gtkEntry,
+                                "interior-focus", &interior_focus,
+                                "focus-line-width", &focus_line_width,
+                                NULL);
+
+            if (option->state & State_HasFocus)
+                GTK_WIDGET_SET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+            else
+                GTK_WIDGET_UNSET_FLAGS(gtkEntry, GTK_HAS_FOCUS);
+
+#if defined Q_WS_HILDON && !defined Q_OS_FREMANTLE
+            gtkPainter.paintFlatBox(gtkEntry, "entry_bg", entryRect, GTK_STATE_NORMAL, GTK_SHADOW_NONE, gtkEntry->style);
+
+            if (!interior_focus && option->state & State_HasFocus)
+                rect.adjust(focus_line_width, focus_line_width, -focus_line_width, -focus_line_width);
+
+            gtkPainter.paintShadow(gtkEntry, "entry", option->rect, GTK_STATE_NORMAL, GTK_SHADOW_IN, gtkEntry->style);
+
+            if (!interior_focus && option->state & State_HasFocus)
+                gtkPainter.paintShadow(gtkEntry, "entry", option->rect, GTK_STATE_ACTIVE, GTK_SHADOW_IN, gtkEntry->style);
+#endif
+            /* Plus button */
+            GtkStateType state = (upIsActive && sunken) ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;
+            if (!isEnabled)
+                state = GTK_STATE_INSENSITIVE;
+
+            gtkPainter.paintBox(gtkPlusButton, "button",  plusRect, state, GTK_SHADOW_OUT, gtkPlusButton->style);
+
+            /* Minus button */
+            state = (downIsActive && sunken) ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;
+            if (!isEnabled)
+                state = GTK_STATE_INSENSITIVE;
+            gtkPainter.paintBox(gtkMinusButton, "button",  minusRect, state, GTK_SHADOW_OUT, gtkMinusButton->style);
+        }
+        break;
+#endif // QT_NO_SPINBOX
+
+    default:
+        QGtkStyle::drawComplexControl(control, option, painter, widget);
+    }
+}
+
+void QHildonStyle::drawControl(ControlElement element,
+                            const QStyleOption *option,
+                            QPainter *painter,
+                            const QWidget *widget) const
+{
+    QGtkStyle::drawControl(element, option, painter, widget);
+}
+
+QRect QHildonStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                                SubControl subControl, const QWidget *widget) const
+{
+    QRect rect = QWindowsStyle::subControlRect(control, option, subControl, widget);
+    if (!QGtk::isThemeAvailable())
+        return QCleanlooksStyle::subControlRect(control, option, subControl, widget);
+
+    switch (control) {
+#ifndef QT_NO_SPINBOX
+    case CC_SpinBox:
+        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
+            GtkWidget *gtkEntry = QGtk::gtkWidget("HildonNumberEditor.GtkEntry");
+            int buttonSize = 30;
+            int padding = 2;
+            int h = qMax(spinbox->rect.height(), buttonSize);
+            int w = qMax(spinbox->rect.width(), (buttonSize + padding) * 2);
+            int x = spinbox->rect.x();
+            int y = spinbox->rect.y();
+            int buttonY = y + (h - buttonSize) / 2;
+            int xt = gtkEntry->style->xthickness;
+            int yt = gtkEntry->style->ythickness;
+
+            switch (subControl) {
+            case SC_SpinBoxUp:
+                rect = QRect(x + w - buttonSize, buttonY, buttonSize, buttonSize);
+                break;
+            case SC_SpinBoxDown:
+                rect = QRect(x, buttonY, buttonSize, buttonSize);
+                break;
+            case SC_SpinBoxEditField:
+                rect = QRect(x + buttonSize + padding + xt, y + yt, w - 2 * (buttonSize + padding + xt), h - 2 * yt);
+                break;
+            case SC_SpinBoxFrame:
+                rect = spinbox->rect;
+            default:
+                break;
+            }
+            rect = visualRect(spinbox->direction, spinbox->rect, rect);
+        }
+        break;
+#endif // Qt_NO_SPINBOX
+    default:
+        return  QGtkStyle::subControlRect(control, option, subControl, widget);
+    }
+    return rect;
+}
+
+QSize QHildonStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
+                                  const QSize &size, const QWidget *widget) const
+{
+   return  QGtkStyle::sizeFromContents(type, option, size, widget);
+}
+
+QPixmap QHildonStyle::standardPixmap(StandardPixmap sp, const QStyleOption *option,
+                                  const QWidget *widget) const
+{
+   return  QGtkStyle::standardPixmap(sp, option, widget);
+}
+
+QRect QHildonStyle::subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const
+{
+    return  QGtkStyle::subElementRect(element, option, widget);
+}
+
+QRect QHildonStyle::itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const
+{
+    return QGtkStyle::itemPixmapRect(r, flags, pixmap);
+}
+
+void QHildonStyle::drawItemPixmap(QPainter *painter, const QRect &rect,
+                            int alignment, const QPixmap &pixmap) const
+{
+    QGtkStyle::drawItemPixmap(painter, rect, alignment, pixmap);
+}
+
+QStyle::SubControl QHildonStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                              const QPoint &pt, const QWidget *w) const
+{
+    return QGtkStyle::hitTestComplexControl(cc, opt, pt, w);
+}
+
+QPixmap QHildonStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                        const QStyleOption *opt) const
+{
+    return QGtkStyle::generatedIconPixmap(iconMode, pixmap, opt);
+}
+
+void QHildonStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
+{
+    QGtkStyle::drawItemText(painter, rect, alignment, pal, enabled, text, textRole);
+}
+
+QT_END_NAMESPACE
+
+#endif
+
diff --git a/src/gui/styles/qhildonstyle.h b/src/gui/styles/qhildonstyle.h
new file mode 100644
index 0000000..cf88d1d
--- /dev/null
+++ b/src/gui/styles/qhildonstyle.h
@@ -0,0 +1,113 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** No Commercial Usage
+** This file contains pre-release code and may not be distributed.
+** You may use this file in accordance with the terms and conditions
+** contained in the either Technology Preview License Agreement or the
+** Beta Release License Agreement.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License versions 2.0 or 3.0 as published by the Free
+** Software Foundation and appearing in the file LICENSE.GPL included in
+** the packaging of this file.  Please review the following information
+** to ensure GNU General Public Licensing requirements will be met:
+** http://www.fsf.org/licensing/licenses/info/GPLv2.html and
+** http://www.gnu.org/copyleft/gpl.html.  In addition, as a special
+** exception, Nokia gives you certain additional rights. These rights
+** are described in the Nokia Qt GPL Exception version 1.3, included in
+** the file GPL_EXCEPTION.txt in this package.
+**
+** Qt for Windows(R) Licensees
+** As a special exception, Nokia, as the sole copyright holder for Qt
+** Designer, grants users of the Qt/Eclipse Integration plug-in the
+** right for the Qt/Eclipse Integration to link to functionality
+** provided by Qt Designer and its related libraries.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+**
+****************************************************************************/
+
+#ifndef QHILDONSTYLE_H
+#define QHILDONSTYLE_H
+
+#include <QtGui/QGtkStyle>
+#include <QtGui/QPalette>
+#include <QtGui/QFont>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Gui)
+
+#if !defined(QT_NO_STYLE_HILDON)
+
+class QPainterPath;
+class QHildonStylePrivate;
+
+class Q_GUI_EXPORT QHildonStyle : public QGtkStyle
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(QHildonStyle)
+
+public:
+    QHildonStyle();
+    ~QHildonStyle();
+
+    QPalette standardPalette() const;
+
+    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
+                       QPainter *painter, const QWidget *widget) const;
+    void drawControl(ControlElement control, const QStyleOption *option,
+                     QPainter *painter, const QWidget *widget) const;
+    void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
+                            QPainter *painter, const QWidget *widget) const;
+    void drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
+                        const QPixmap &pixmap) const;
+    void drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
+                      bool enabled, const QString& text, QPalette::ColorRole textRole) const;
+
+    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
+                    const QWidget *widget = 0) const;
+    int styleHint(StyleHint hint, const QStyleOption *option,
+                  const QWidget *widget, QStyleHintReturn *returnData) const;
+
+    QStyle::SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
+                              const QPoint &pt, const QWidget *w) const;
+
+    QRect subControlRect(ComplexControl control, const QStyleOptionComplex *option,
+                         SubControl subControl, const QWidget *widget) const;
+    QRect subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *w) const;
+    QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;
+
+
+    QSize sizeFromContents(ContentsType type, const QStyleOption *option,
+                           const QSize &size, const QWidget *widget) const;
+    QPixmap standardPixmap(StandardPixmap sp, const QStyleOption *option,
+                           const QWidget *widget) const;
+    QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
+                                const QStyleOption *opt) const;
+
+    void polish(QWidget *widget);
+    void polish(QApplication *app);
+    void polish(QPalette &palette);
+
+    void unpolish(QWidget *widget);
+    void unpolish(QApplication *app);
+};
+
+
+#endif //!defined(QT_NO_STYLE_QGTK)
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif //QGTKSTYLE_H
diff --git a/src/gui/styles/qstyle.h b/src/gui/styles/qstyle.h
index 133ad37..3e6255d 100644
--- a/src/gui/styles/qstyle.h
+++ b/src/gui/styles/qstyle.h
@@ -511,6 +511,10 @@ public:
         PM_MenuPanelWidth,
         PM_MenuTearoffHeight,
         PM_MenuDesktopFrameWidth,
+#ifdef Q_WS_HILDON
+        PM_MenuOffsetHorizontal,        // X offset beetween upper left corners of the hildon app menu and its app
+        PM_MenuOffsetVertical,          //
+#endif
 
         PM_MenuBarPanelWidth,
         PM_MenuBarItemSpacing,
diff --git a/src/gui/styles/qstylefactory.cpp b/src/gui/styles/qstylefactory.cpp
index 1db7f8e..111dca1 100644
--- a/src/gui/styles/qstylefactory.cpp
+++ b/src/gui/styles/qstylefactory.cpp
@@ -57,6 +57,9 @@
 #ifndef QT_NO_STYLE_GTK
 #include "qgtkstyle.h"
 #endif
+#ifndef QT_NO_STYLE_HILDON
+#include "qhildonstyle.h"
+#endif
 #ifndef QT_NO_STYLE_WINDOWSXP
 #include "qwindowsxpstyle.h"
 #endif
@@ -169,6 +172,11 @@ QStyle *QStyleFactory::create(const QString& key)
         ret = new QGtkStyle;
     else
 #endif
+#ifndef QT_NO_STYLE_GTK
+    if (style == QLatin1String("hildon"))
+        ret = new QHildonStyle;
+    else
+#endif
 #ifndef QT_NO_STYLE_MAC
     if (style.left(9) == QLatin1String("macintosh")) {
         ret = new QMacStyle;
@@ -241,6 +249,10 @@ QStringList QStyleFactory::keys()
     if (!list.contains(QLatin1String("GTK+")))
         list << QLatin1String("GTK+");
 #endif
+#ifndef QT_NO_STYLE_HILDON
+    if (!list.contains(QLatin1String("Hildon")))
+        list << QLatin1String("Hildon");
+#endif
 #ifndef QT_NO_STYLE_CLEANLOOKS
     if (!list.contains(QLatin1String("Cleanlooks")))
         list << QLatin1String("Cleanlooks");
diff --git a/src/gui/styles/styles.pri b/src/gui/styles/styles.pri
index 376f834..1e33094 100644
--- a/src/gui/styles/styles.pri
+++ b/src/gui/styles/styles.pri
@@ -32,7 +32,7 @@ x11|embedded|!macx-*:styles -= mac
 x11{
     QMAKE_CXXFLAGS += $$QT_CFLAGS_QGTKSTYLE
     LIBS += $$QT_LIBS_QGTKSTYLE
-    styles += gtk
+    styles += gtk hildon
 }
 
 contains( styles, mac ) {
@@ -115,6 +115,17 @@ contains( styles, gtk ) {
 	DEFINES += QT_NO_STYLE_GTK
 }
 
+contains( styles, hildon ) {
+        HEADERS += styles/qhildonstyle.h
+        SOURCES += styles/qhildonstyle.cpp
+        !contains( styles, gtk ) {
+                styles += gtk
+                DEFINES+= QT_STYLE_GTK
+        }
+} else {
+        DEFINES += QT_NO_STYLE_GTK
+}
+
 contains( styles, cleanlooks ) {
         HEADERS += styles/qcleanlooksstyle.h
         HEADERS += styles/qcleanlooksstyle_p.h
diff --git a/src/gui/text/qtextcontrol.cpp b/src/gui/text/qtextcontrol.cpp
index 9a3fc1f..0b5ae3b 100644
--- a/src/gui/text/qtextcontrol.cpp
+++ b/src/gui/text/qtextcontrol.cpp
@@ -915,6 +915,10 @@ void QTextControl::processEvent(QEvent *e, const QMatrix &matrix, QWidget *conte
         case QEvent::MouseButtonRelease: {
             QMouseEvent *ev = static_cast<QMouseEvent *>(e);
             d->mouseReleaseEvent(ev->button(), matrix.map(ev->pos()));
+#ifdef Q_OS_FREMANTLE
+            //MouseButtonRelease activate the Hildon Input Method
+            ev->ignore();
+#endif
             break; }
         case QEvent::MouseButtonDblClick: {
             QMouseEvent *ev = static_cast<QMouseEvent *>(e);
@@ -1817,6 +1821,12 @@ void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
         e->ignore();
         return;
     }
+#ifdef Q_WS_HILDON
+    //This code permits to set the cursor position via QInputMethodEvent
+    //In Hildon we need to do it when the user select the text from right to left
+    //with the fingers and so the fullscreen on-screen keyboard plugins is shown
+    int textCursorPosition= cursor.position();
+#endif
     cursor.beginEditBlock();
 
     cursor.removeSelectedText();
@@ -1827,7 +1837,14 @@ void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
         c.setPosition(c.position() + e->replacementStart());
         c.setPosition(c.position() + e->replacementLength(), QTextCursor::KeepAnchor);
         c.insertText(e->commitString());
+#ifndef Q_WS_HILDON
+    }
+#else
+         textCursorPosition= c.position();
+    }else if (e->replacementStart()){
+        textCursorPosition += e->replacementStart();
     }
+#endif   
 
     QTextBlock block = cursor.block();
     QTextLayout *layout = block.layout();
@@ -1853,6 +1870,9 @@ void QTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
     }
     layout->setAdditionalFormats(overrides);
     cursor.endEditBlock();
+#ifdef Q_WS_HILDON
+    cursor.setPosition(textCursorPosition);
+#endif
 }
 
 QVariant QTextControl::inputMethodQuery(Qt::InputMethodQuery property) const
@@ -1870,6 +1890,12 @@ QVariant QTextControl::inputMethodQuery(Qt::InputMethodQuery property) const
         return QVariant(block.text());
     case Qt::ImCurrentSelection:
         return QVariant(d->cursor.selectedText());
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:{
+        int mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_AUTOCAP | HILDON_GTK_INPUT_MODE_DICTIONARY | HILDON_GTK_INPUT_MODE_MULTILINE;
+        return QVariant(mode);
+    }
+#endif
     default:
         return QVariant();
     }
diff --git a/src/gui/util/qdesktopservices_x11.cpp b/src/gui/util/qdesktopservices_x11.cpp
index 1a97a41..a83c117 100644
--- a/src/gui/util/qdesktopservices_x11.cpp
+++ b/src/gui/util/qdesktopservices_x11.cpp
@@ -63,10 +63,7 @@ static bool openDocument(const QUrl &url)
 {
     if (!url.isValid())
         return false;
-
-    if (launch(url, QLatin1String("xdg-open")))
-        return true;
-
+    
     if (X11->desktopEnvironment == DE_GNOME && launch(url, QLatin1String("gnome-open"))) {
         return true;
     } else {
@@ -74,6 +71,10 @@ static bool openDocument(const QUrl &url)
             return true;
     }
 
+#ifndef Q_WS_HILDON
+    if (launch(url, QLatin1String("xdg-open")))
+        return true;
+
     if (launch(url, QLatin1String("firefox")))
         return true;
     if (launch(url, QLatin1String("mozilla")))
@@ -82,7 +83,10 @@ static bool openDocument(const QUrl &url)
         return true;
     if (launch(url, QLatin1String("opera")))
         return true;
-
+#else
+    if (launch(url, QLatin1String("browser --url")))
+        return true;
+#endif
     return false;
 }
 
@@ -93,13 +97,15 @@ static bool launchWebBrowser(const QUrl &url)
     if (url.scheme() == QLatin1String("mailto"))
         return openDocument(url);
 
-    if (launch(url, QLatin1String("xdg-open")))
-        return true;
     if (launch(url, QString::fromLocal8Bit(getenv("DEFAULT_BROWSER"))))
         return true;
     if (launch(url, QString::fromLocal8Bit(getenv("BROWSER"))))
         return true;
 
+#ifndef Q_WS_HILDON
+    if (launch(url, QLatin1String("xdg-open")))
+        return true;
+
     if (X11->desktopEnvironment == DE_GNOME && launch(url, QLatin1String("gnome-open"))) {
         return true;
     } else {
@@ -115,6 +121,10 @@ static bool launchWebBrowser(const QUrl &url)
         return true;
     if (launch(url, QLatin1String("opera")))
         return true;
+#else
+    if (launch(url, QLatin1String("browser --url")))
+        return true;
+#endif
     return false;
 }
 
@@ -194,13 +204,25 @@ QString QDesktopServices::storageLocation(StandardLocation type)
     QString path;
     switch (type) {
     case DesktopLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs");
+#else
         path = QDir::homePath() + QLatin1String("/Desktop");
+#endif
         break;
     case DocumentsLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.documents");
+#else
         path = QDir::homePath() + QLatin1String("/Documents");
+#endif
        break;
     case PicturesLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.images");
+#else
         path = QDir::homePath() + QLatin1String("/Pictures");
+#endif
         break;
 
     case FontsLocation:
@@ -208,11 +230,19 @@ QString QDesktopServices::storageLocation(StandardLocation type)
         break;
 
     case MusicLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.sounds");
+#else
         path = QDir::homePath() + QLatin1String("/Music");
+#endif
         break;
 
     case MoviesLocation:
+#ifdef Q_WS_HILDON
+        path = QDir::homePath() + QLatin1String("/MyDocs/.videos");
+#else
         path = QDir::homePath() + QLatin1String("/Videos");
+#endif
         break;
 
     case ApplicationsLocation:
diff --git a/src/gui/widgets/qabstractspinbox.cpp b/src/gui/widgets/qabstractspinbox.cpp
index e079271..2393904 100644
--- a/src/gui/widgets/qabstractspinbox.cpp
+++ b/src/gui/widgets/qabstractspinbox.cpp
@@ -62,6 +62,10 @@
 #include <limits.h>
 #endif
 
+#if defined (Q_WS_HILDON)
+#   include <qinputcontext.h>
+#endif
+
 //#define QABSTRACTSPINBOX_QSBDEBUG
 #ifdef QABSTRACTSPINBOX_QSBDEBUG
 #  define QASBDEBUG qDebug
@@ -619,9 +623,28 @@ void QAbstractSpinBox::stepBy(int steps)
 }
 
 /*!
+ */
+QVariant QAbstractSpinBox::inputMethodQuery(Qt::InputMethodQuery query) const
+{    
+    Q_D(const QAbstractSpinBox);
+
+    switch(query) {
+#ifdef Q_WS_HILDON
+        case Qt::ImMode:{
+            int mode = HILDON_GTK_INPUT_MODE_NUMERIC;
+            return QVariant(mode);
+        }
+#endif
+        default:
+            return d->edit->inputMethodQuery(query);
+    }
+}
+
+/*!
     This function returns a pointer to the line edit of the spin box.
 */
 
+
 QLineEdit *QAbstractSpinBox::lineEdit() const
 {
     Q_D(const QAbstractSpinBox);
@@ -659,7 +682,9 @@ void QAbstractSpinBox::setLineEdit(QLineEdit *lineEdit)
         d->edit->setParent(this);
 
     d->edit->setFrame(false);
+#ifndef Q_WS_HILDON
     d->edit->setAttribute(Qt::WA_InputMethodEnabled, false);
+#endif
     d->edit->setFocusProxy(this);
     d->edit->setAcceptDrops(false);
 
@@ -1182,7 +1207,7 @@ void QAbstractSpinBox::timerEvent(QTimerEvent *event)
 
 void QAbstractSpinBox::contextMenuEvent(QContextMenuEvent *event)
 {
-#ifdef QT_NO_CONTEXTMENU
+#if (defined(QT_NO_CONTEXTMENU) || defined(Q_WS_HILDON))
     Q_UNUSED(event);
 #else
     Q_D(QAbstractSpinBox);
diff --git a/src/gui/widgets/qabstractspinbox.h b/src/gui/widgets/qabstractspinbox.h
index d8b9757..6ca9a15 100644
--- a/src/gui/widgets/qabstractspinbox.h
+++ b/src/gui/widgets/qabstractspinbox.h
@@ -159,6 +159,11 @@ Q_SIGNALS:
 protected:
     QAbstractSpinBox(QAbstractSpinBoxPrivate &dd, QWidget *parent = 0);
 
+#ifdef Q_WS_HILDON
+public:
+    QVariant inputMethodQuery(Qt::InputMethodQuery) const;
+#endif
+
 private:
     Q_PRIVATE_SLOT(d_func(), void _q_editorTextChanged(const QString &))
     Q_PRIVATE_SLOT(d_func(), void _q_editorCursorPositionChanged(int, int))
diff --git a/src/gui/widgets/qcombobox.cpp b/src/gui/widgets/qcombobox.cpp
index f04a415..7f805f4 100644
--- a/src/gui/widgets/qcombobox.cpp
+++ b/src/gui/widgets/qcombobox.cpp
@@ -206,7 +206,11 @@ QRect QComboBoxPrivate::popupGeometry(int screen) const
 #ifdef Q_WS_WIN
     return QApplication::desktop()->screenGeometry(screen);
 #elif defined Q_WS_X11
-    if (X11->desktopEnvironment == DE_KDE)
+    if (X11->desktopEnvironment == DE_KDE
+#ifdef Q_WS_HILDON
+        || X11->desktopEnvironment == DE_HILDON
+#endif
+    )
         return QApplication::desktop()->screenGeometry(screen);
     else
         return QApplication::desktop()->availableGeometry(screen);
@@ -2920,7 +2924,7 @@ void QComboBox::wheelEvent(QWheelEvent *e)
 }
 #endif
 
-#ifndef QT_NO_CONTEXTMENU
+#if !defined(QT_NO_CONTEXTMENU) || !defined(Q_WS_HILDON)
 /*!
     \reimp
 */
diff --git a/src/gui/widgets/qlineedit.cpp b/src/gui/widgets/qlineedit.cpp
index 7e7c654..cad7b0a 100644
--- a/src/gui/widgets/qlineedit.cpp
+++ b/src/gui/widgets/qlineedit.cpp
@@ -544,6 +544,11 @@ void QLineEdit::setEchoMode(EchoMode mode)
     Q_D(QLineEdit);
     if (mode == (EchoMode)d->echoMode)
         return;
+#ifndef Q_WS_HILDON
+    setAttribute(Qt::WA_InputMethodEnabled, mode == Normal || mode == PasswordEchoOnEdit);
+#else
+    setAttribute(Qt::WA_InputMethodEnabled);
+#endif
     setAttribute(Qt::WA_InputMethodEnabled, shouldEnableInputMethod(this));
     d->echoMode = mode;
     d->passwordEchoEditing = false;
@@ -1749,6 +1754,15 @@ void QLineEdit::mouseReleaseEvent(QMouseEvent* e)
     Q_D(QLineEdit);
     if (d->sendMouseEventToInputContext(e))
 	return;
+#ifdef Q_WS_HILDON
+    //Propagate the event to the parent widget.
+    // QHildonInputMethod installs a filter in a widget  to get
+    // the mouseRelease event. 
+    // In complex widgets like QSpinBoxes or QComboBoxes, these events
+    // are consumed in the sub-widget so they don't reach the parent widget.
+    // Then the Hildon Input Main UI can not be shown if we can't receive them.
+    e->ignore();
+#endif
 #ifndef QT_NO_DRAGANDDROP
     if (e->button() == Qt::LeftButton) {
         if (d->dndTimer.isActive()) {
@@ -2312,6 +2326,10 @@ void QLineEdit::inputMethodEvent(QInputMethodEvent *e)
     if (!e->commitString().isEmpty())
         d->complete(Qt::Key_unknown);
 #endif
+#ifdef Q_WS_HILDON
+    // Sets the cursor position via QInputMethodEvent
+    d->cursor += e->replacementStart();
+#endif
 }
 
 /*!\reimp
@@ -2330,6 +2348,17 @@ QVariant QLineEdit::inputMethodQuery(Qt::InputMethodQuery property) const
         return QVariant(d->text);
     case Qt::ImCurrentSelection:
         return QVariant(selectedText());
+#ifdef Q_WS_HILDON
+    case Qt::ImMode:{
+        int mode;
+        if (d->echoMode == Normal)
+            mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_AUTOCAP | HILDON_GTK_INPUT_MODE_DICTIONARY;
+        else
+            mode = HILDON_GTK_INPUT_MODE_FULL | HILDON_GTK_INPUT_MODE_INVISIBLE;
+            
+        return QVariant(mode);
+    }
+#endif
     default:
         return QVariant();
     }
@@ -2341,6 +2370,7 @@ QVariant QLineEdit::inputMethodQuery(Qt::InputMethodQuery property) const
 void QLineEdit::focusInEvent(QFocusEvent *e)
 {
     Q_D(QLineEdit);
+    
     if (e->reason() == Qt::TabFocusReason ||
          e->reason() == Qt::BacktabFocusReason  ||
          e->reason() == Qt::ShortcutFocusReason) {
diff --git a/src/gui/widgets/qmainwindow.cpp b/src/gui/widgets/qmainwindow.cpp
index 0a0faa0..ab6acc0 100644
--- a/src/gui/widgets/qmainwindow.cpp
+++ b/src/gui/widgets/qmainwindow.cpp
@@ -54,6 +54,7 @@
 #include <qstyle.h>
 #include <qdebug.h>
 #include <qpainter.h>
+#include <qhildonappmenu.h>
 
 #include <private/qwidget_p.h>
 #include "qtoolbar_p.h"
@@ -99,6 +100,9 @@ public:
     uint hasOldCursor : 1;
     uint cursorAdjusted : 1;
 #endif
+#ifdef Q_WS_HILDON
+    QPointer<QMenu> globalMenu;
+#endif
 };
 
 void QMainWindowPrivate::init()
@@ -110,6 +114,28 @@ void QMainWindowPrivate::init()
     explicitIconSize = false;
 
     q->setAttribute(Qt::WA_Hover);
+
+#ifdef Q_OS_FREMANTLE
+    int item = -1;
+    QWidget *hswParent = qobject_cast<QWidget*>(q->parent());
+    if (hswParent)
+        item = hswParent->hildonStackableWindow();
+
+    setHildonStackableWindows(item +1);
+#endif
+
+#ifdef Q_WS_HILDON
+    //Binding F4 button
+    QAction *showAppContextMenuAct = new QAction(q);
+    showAppContextMenuAct->setShortcut(Qt::Key_F4);
+    q->connect(showAppContextMenuAct, SIGNAL(triggered()),q , SLOT(showApplicationContextMenu()));
+    q->addAction(showAppContextMenuAct);
+    //Binding F6 button
+    QAction *toggleWindowStateAct = new QAction(q);
+    toggleWindowStateAct->setShortcut(Qt::Key_F6);
+    q->connect(toggleWindowStateAct, SIGNAL(triggered()),q , SLOT(toggleWindowState()));
+    q->addAction(toggleWindowStateAct);
+#endif
 }
 
 /*
@@ -674,6 +700,10 @@ void QMainWindow::removeToolBarBreak(QToolBar *before)
 */
 void QMainWindow::addToolBar(Qt::ToolBarArea area, QToolBar *toolbar)
 {
+#ifdef Q_WS_HILDON
+    area = Qt::BottomToolBarArea;
+    toolbar->setMovable(false);
+#endif
     if (!checkToolBarArea(area, "QMainWindow::addToolBar"))
         return;
 
@@ -874,6 +904,100 @@ void QMainWindow::setDockNestingEnabled(bool enabled)
     d->layout->setDockOptions(opts);
 }
 
+#ifdef Q_WS_HILDON
+void QMainWindow::showApplicationContextMenu(){
+    Q_D(QMainWindow);
+
+    static QPoint menuPos;
+    static QAction *quitAction = 0;
+
+    //Hides submenues. GlobalMenu will be destroyed as soons
+    //as QMenu::exec() terminates
+    if (!d->globalMenu.isNull()){
+        d->globalMenu->hide();
+        return;
+    }
+
+    if (!menuBar())
+        return;
+
+    QList<QAction*> actionList = menuBar()->actions();
+
+    QHildonAppMenu *appMenu;
+    
+    if (!actionList.isEmpty()){
+        QAction *action;
+
+        //Looking for "Fremantle" Menu
+        foreach(action, actionList){
+            if (action->text().compare("fremantle", Qt::CaseInsensitive) == 0){
+                QMenu *menu = action->menu();
+                if (menu){
+                    QList<QAction*> fremantleActionList;
+                    fremantleActionList = menu->actions();
+                    appMenu = new QHildonAppMenu(fremantleActionList, this);
+                    appMenu->show();
+                    return;
+                }
+            }
+        }
+    }
+
+    //Getting the Menu position from the style
+    if (menuPos.isNull()){
+        int hMenuOffset = 0, 
+            vMenuOffset = 0;
+
+        hMenuOffset = style()->pixelMetric(QStyle::PM_MenuOffsetHorizontal, 0, this);
+        vMenuOffset = style()->pixelMetric(QStyle::PM_MenuOffsetVertical, 0, this);
+        menuPos = mapToGlobal(QPoint(0, 0));
+        menuPos += QPoint(hMenuOffset, vMenuOffset);
+    }
+
+    //Creating a new Application Context Menu
+    //so that is always updated
+    d->globalMenu = new QMenu(this);
+
+    //Filling the App context menu
+    if (!actionList.isEmpty()){
+        //Trying to get the quitAction from the file menu    
+        QMenu *fileMenu = actionList[0]->menu();
+
+        if (!quitAction && fileMenu){
+            QList<QAction*> fileActionList;
+
+            fileActionList = fileMenu->actions();
+            if (!fileActionList.isEmpty()){
+                QRegExp quitString("(?:close)|(?:exit)|(?:quit)", Qt::CaseInsensitive);
+
+                quitAction = fileActionList.last();   
+                if (quitAction && quitAction->text().remove(QChar('&')).contains(quitString)){
+                    fileMenu->removeAction(quitAction);
+                    if (fileActionList.isEmpty())
+                        actionList.removeFirst();   
+                }else{
+                    quitAction = 0;
+                }
+            }
+        }
+        d->globalMenu->addActions(actionList);
+    }
+     
+     //Add quitAction in the last position
+     if (quitAction)
+         d->globalMenu->addAction(quitAction);
+     
+     if (d->globalMenu->actions().count())
+         d->globalMenu->exec(menuPos);
+
+     delete static_cast<QMenu *>(d->globalMenu);
+}
+
+void QMainWindow::toggleWindowState() {
+    setWindowState(windowState() ^ Qt::WindowFullScreen);
+}
+#endif
+
 #if 0
 /*! \property QMainWindow::verticalTabsEnabled
     \brief whether left and right dock areas use vertical tabs
diff --git a/src/gui/widgets/qmainwindow.h b/src/gui/widgets/qmainwindow.h
index 9c2fb88..a71bfa5 100644
--- a/src/gui/widgets/qmainwindow.h
+++ b/src/gui/widgets/qmainwindow.h
@@ -185,12 +185,24 @@ public:
     QT3_SUPPORT_CONSTRUCTOR QMainWindow(QWidget *parent, const char *name, Qt::WindowFlags flags = 0);
 #endif
 
+#ifdef Q_WS_HILDON
+public Q_SLOTS:
+    //NOTE API Changed.
+    void showApplicationContextMenu();
+#endif
+
 #ifndef QT_NO_DOCKWIDGET
 public Q_SLOTS:
     void setAnimated(bool enabled);
     void setDockNestingEnabled(bool enabled);
 #endif
 
+#ifdef Q_WS_HILDON
+public Q_SLOTS:
+    //NOTE API Changed.
+    void toggleWindowState();
+#endif
+
 Q_SIGNALS:
     void iconSizeChanged(const QSize &iconSize);
     void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);
diff --git a/src/gui/widgets/qmenu.cpp b/src/gui/widgets/qmenu.cpp
index 28645b4..0471ed3 100644
--- a/src/gui/widgets/qmenu.cpp
+++ b/src/gui/widgets/qmenu.cpp
@@ -79,6 +79,9 @@
 #   include <private/qt_cocoa_helpers_mac_p.h>
 #endif
 
+#ifdef Q_WS_HILDON
+#   include <qmainwindow.h>
+#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -170,7 +173,11 @@ QRect QMenuPrivate::popupGeometry(int screen) const
 #ifdef Q_WS_WIN
     return QApplication::desktop()->screenGeometry(screen);
 #elif defined Q_WS_X11
-    if (X11->desktopEnvironment == DE_KDE)
+    if (X11->desktopEnvironment == DE_KDE
+#ifdef Q_WS_HILDON
+        || X11->desktopEnvironment == DE_HILDON
+#endif
+    )
         return QApplication::desktop()->screenGeometry(screen);
     else
         return QApplication::desktop()->availableGeometry(screen);
@@ -2315,6 +2322,16 @@ QMenu::event(QEvent *e)
             keyPressEvent(ke);
             return true;
         }
+#ifdef Q_WS_HILDON
+        //HACK
+        if (ke->key() == Qt::Key_F4){
+            QMainWindow *mw = qobject_cast<QMainWindow*>(parent());
+            if (mw){
+                mw->showApplicationContextMenu();
+                return true;
+            }
+        }
+#endif
     } break;
     case QEvent::ContextMenu:
         if(QMenuPrivate::menuDelayTimer.isActive()) {
diff --git a/src/gui/widgets/qmenubar.cpp b/src/gui/widgets/qmenubar.cpp
index f58ea50..b427a15 100644
--- a/src/gui/widgets/qmenubar.cpp
+++ b/src/gui/widgets/qmenubar.cpp
@@ -725,6 +725,10 @@ void QMenuBarPrivate::init()
     if(mac_menubar)
         q->hide();
 #endif
+#ifdef Q_WS_HILDON
+    if (setCustomContext())
+        q->hide();
+#endif
 #ifdef Q_OS_WINCE
     if (qt_wince_is_mobile()) {
         wceCreateMenuBar(q->parentWidget());
@@ -1374,6 +1378,10 @@ void QMenuBarPrivate::handleReparent()
     macCreateMenuBar(newParent);
 #endif
 
+#ifdef Q_WS_HILDON
+    setCustomContext();
+#endif
+
 #ifdef Q_OS_WINCE
     if (qt_wince_is_mobile() && wce_menubar)
         wce_menubar->rebuild();
diff --git a/src/gui/widgets/qstatusbar.cpp b/src/gui/widgets/qstatusbar.cpp
index 9544c19..748f214 100644
--- a/src/gui/widgets/qstatusbar.cpp
+++ b/src/gui/widgets/qstatusbar.cpp
@@ -248,6 +248,9 @@ QStatusBar::QStatusBar(QWidget * parent, const char *name)
 #else
     reformat();
 #endif
+#ifdef Q_WS_HILDON
+    hide();
+#endif
 }
 
 
@@ -286,6 +289,9 @@ QStatusBar::QStatusBar(QWidget * parent)
 #else
     reformat();
 #endif
+#ifdef Q_WS_HILDON
+    hide();
+#endif
 }
 
 /*!
diff --git a/src/network/maemo/gconfsymbols.cpp b/src/network/maemo/gconfsymbols.cpp
new file mode 100644
index 0000000..1204997
--- /dev/null
+++ b/src/network/maemo/gconfsymbols.cpp
@@ -0,0 +1,95 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include "gconfsymbols_p.h"
+
+#include <QtCore/qlibrary.h>
+#include <QDebug>
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+static QLibrary *qgconf_libgconf = 0;
+
+bool qgconf_loadLibGConf()
+{
+    g_type_init();
+
+    static volatile bool triedToLoadLibrary = false;
+
+    QLibrary *&lib = qgconf_libgconf;
+    if (triedToLoadLibrary)
+        return lib && lib->isLoaded();
+
+    lib = new QLibrary(QLatin1String("gconf-2"), 4);
+    triedToLoadLibrary = true;
+
+    if (lib->load() && lib->resolve("gconf_client_get_default"))
+       return true;
+
+    lib->unload();
+    delete lib;
+    lib = 0;
+    return false;
+}
+
+void qgconf_unloadLibGConf()
+{
+    qgconf_libgconf->unload();
+}
+
+void *qgconf_resolve_me(const char *name)
+{
+    void *ptr = 0;
+    if (!qgconf_loadLibGConf())
+        qFatal("Cannot find libgconf-2 in your system to resolve symbol '%s'.", name);
+
+    ptr = qgconf_libgconf->resolve(name);
+    if (!ptr)
+        qFatal("Cannot resolve '%s' in your libgconf-2.", name);
+
+    return ptr;
+}
+
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
diff --git a/src/network/maemo/gconfsymbols_p.h b/src/network/maemo/gconfsymbols_p.h
new file mode 100644
index 0000000..93c3117
--- /dev/null
+++ b/src/network/maemo/gconfsymbols_p.h
@@ -0,0 +1,99 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGCONF_SYMBOLS_P_H
+#define QGCONF_SYMBOLS_P_H
+
+#include <QtCore/qglobal.h>
+
+#ifdef Q_WS_HILDON
+
+#include <gconf/gconf.h>
+
+QT_BEGIN_NAMESPACE
+
+class GConf;
+class GConfClient;
+
+typedef enum {
+  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
+  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
+  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
+} GConfClientPreloadType;
+
+typedef void (*GConfClientNotifyFunc)(GConfClient* client,
+                                      guint cnxn_id,
+                                      GConfEntry *entry,
+                                      gpointer user_data);
+
+# define DEFINEFUNC(ret, func, args, argcall, funcret)          \
+    typedef ret (* _q_PTR_##func) args;                         \
+    static inline ret q_##func args                             \
+    {                                                           \
+        static _q_PTR_##func ptr;                               \
+        if (!ptr)                                               \
+            ptr = (_q_PTR_##func) qgconf_resolve_me(#func);     \
+        funcret ptr argcall;                                    \
+    }
+
+//Private Functions
+void *qgconf_resolve_me(const char *name);
+
+//Public Functions
+bool qgconf_loadLibGConf();
+void qgconf_unloadLibGConf();
+
+DEFINEFUNC(GConfClient*, gconf_client_get_default, (),() ,return )
+DEFINEFUNC(GConfValue*,  gconf_client_get, (GConfClient* a, const gchar* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(char* , gconf_client_get_string, (GConfClient* a, const char* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(gboolean, gconf_client_get_bool, (GConfClient* a, const char* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(gint, gconf_client_get_int, (GConfClient* a, const char* b, GError ** c), (a, b, c), return)
+DEFINEFUNC(void, gconf_client_add_dir, (GConfClient* a, const gchar*b, GConfClientPreloadType c, GError** d), (a, b, c, d), )
+DEFINEFUNC(guint, gconf_client_notify_add, (GConfClient* a, const gchar* b, GConfClientNotifyFunc c, gpointer d, GFreeFunc e, GError** f),
+           (a, b, c, d, e, f), return)
+
+
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
+#endif // QGCONF_SYMBOLS_P_H
diff --git a/src/network/maemo/maemo.pri b/src/network/maemo/maemo.pri
new file mode 100644
index 0000000..5fcbe85
--- /dev/null
+++ b/src/network/maemo/maemo.pri
@@ -0,0 +1,15 @@
+# Qt network kernel module
+
+INCLUDEPATH += $$PWD
+
+HEADERS += maemo/qmaemointernetconnectivity.h \ 
+           maemo/qmaemointernetconnectivity_p.h \
+           maemo/qgconfbackend_p.h \
+           maemo/gconfsymbols_p.h
+
+SOURCES += maemo/qmaemointernetconnectivity.cpp \
+           maemo/qgconfbackend.cpp \
+           maemo/gconfsymbols.cpp
+
+CONFIG += link_pkgconfig
+PKGCONFIG += gconf-2.0
diff --git a/src/network/maemo/qgconfbackend.cpp b/src/network/maemo/qgconfbackend.cpp
new file mode 100755
index 0000000..7f850e5
--- /dev/null
+++ b/src/network/maemo/qgconfbackend.cpp
@@ -0,0 +1,179 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgconfbackend_p.h"
+
+#include <QDebug>
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+Q_GLOBAL_STATIC(QGConfBackend, gconfBackend);
+
+QGConfBackend::QGConfBackend()
+{
+    qgconf_loadLibGConf();
+    client = q_gconf_client_get_default();
+}
+
+QGConfBackend::~QGConfBackend()
+{
+    g_object_unref(client);
+    qgconf_unloadLibGConf();
+}
+
+QVariant QGConfBackend::getValue(const QString &key)
+{
+    QVariant retValue;
+    if (q_gconf_client_get_default != 0) {
+        GConfClient* client = q_gconf_client_get_default();
+        GError *err = 0;
+        //Getting the Gconf value type
+        GConfValue* value = 0;
+
+        value = q_gconf_client_get(client, qPrintable(key), &err);
+        if (err) {
+            //qDebug() << "ERROR: Unable to get the Value";
+            g_error_free (err);
+            return QVariant();
+        }
+        if (!value){
+            //qDebug() << "VALUE is 0";
+            return QVariant();
+        }
+        switch(value->type){
+        case GCONF_VALUE_STRING: {
+            char *str = q_gconf_client_get_string(client, qPrintable(key), &err);
+            if (!err) {
+                retValue.setValue(QString::fromUtf8(str));
+                g_free(str);
+            }
+        } break;
+        case GCONF_VALUE_BOOL: {
+            gboolean b = q_gconf_client_get_bool(client, qPrintable(key), &err);
+            if (!err) {
+                retValue.setValue((bool)b);
+            }
+        } break;
+        case GCONF_VALUE_INT: {
+            gint i = q_gconf_client_get_int(client, qPrintable(key), &err);
+            if (!err) {
+                retValue.setValue((int)i);
+            }
+        } break;
+        default:
+            //qDebug("QGConfBackend::getGConfValue: Sorry, the type %d has not been ported ", value->type);
+            return QVariant();
+        }
+
+        if (err)
+            g_error_free (err);
+
+        return retValue;
+    }
+
+    return QVariant();
+}
+
+bool QGConfBackend::connect(const QString& dir, slot funcToCall){
+    //TODO Dir Check
+
+    //Check if the dir exists already in the Map
+    /*
+    QMap<QString, slot>::const_iterator i = map.find(dir);
+    if (i != map.end()){
+        //qDebug() << "The key exists already in the Map.";
+        return false;
+    }*/
+
+    if ( map.value(dir))
+        return false;
+
+    gconfBackend()->map.insert(dir, funcToCall);
+    watch(dir, callback);
+    return true;
+}
+
+QGConfBackend* QGConfBackend::self(){
+    return gconfBackend();
+}
+
+void QGConfBackend::watch(const QString& dir, callbackFunc cPtr){
+    GError *err = 0;
+
+    q_gconf_client_add_dir(client, qPrintable(dir), GCONF_CLIENT_PRELOAD_NONE, &err);
+
+    if (err) {
+        //qDebug() <<  "Failed to add a watch to GCClient:" << err->message;
+        g_error_free (err);
+    }
+
+    q_gconf_client_notify_add(client, qPrintable(dir), cPtr, 0, 0, &err);
+
+    if (err) {
+        //qDebug() << "Failed to add register the callback" << err->message;
+        g_error_free (err);
+    }
+}
+
+void QGConfBackend::callback(GConfClient* a, guint b, GConfEntry* c, void* d){
+    Q_UNUSED(a);
+    Q_UNUSED(b);
+    Q_UNUSED(d);
+    //qDebug() << "KEY" << c->key << "VALUE TYPE" << c->value->type;
+
+    QVariant value;
+    const QString fullKey = c->key;
+    QString key, dir;
+
+    key = fullKey.split("/").last();
+    dir = fullKey;
+    dir.remove("/" + key);
+
+    slot slotToCall = gconfBackend()->map.value(dir);
+    value = gconfBackend()->getValue(fullKey);
+    (*slotToCall)(key, value);
+}
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
diff --git a/src/network/maemo/qgconfbackend_p.h b/src/network/maemo/qgconfbackend_p.h
new file mode 100644
index 0000000..406b969
--- /dev/null
+++ b/src/network/maemo/qgconfbackend_p.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QGCONFBACKEND_P_H
+#define QGCONFBACKEND_P_H
+
+#include "gconfsymbols_p.h"
+#include "QtCore/qstringlist.h"
+#include "QtCore/qvariant.h"
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+typedef void (*slot)(QString& key, QVariant value);
+
+class QGConfBackend
+{
+   typedef void (*callbackFunc)(GConfClient* a, guint b, GConfEntry* c , void* d);
+
+public:
+    QGConfBackend();
+    ~QGConfBackend();
+
+    //Read the value for the key stored in GConf
+    QVariant getValue(const QString &key);
+
+    //slotToCall is called when changes happen in the GConf dir.
+    bool connect(const QString& dir, slot slotToCall);
+
+    static QGConfBackend* self();
+
+private:
+    void watch(const QString& dir, callbackFunc cPtr);
+    static void callback(GConfClient* a, guint b, GConfEntry* c, void* d);
+    void callSlot(GConfEntry* entry);
+
+    GConfClient* client;
+    QMap<QString, slot> map;
+};
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
+#endif //QGCONFBACKEND_P_H
diff --git a/src/network/maemo/qmaemointernetconnectivity.cpp b/src/network/maemo/qmaemointernetconnectivity.cpp
new file mode 100755
index 0000000..3f614d4
--- /dev/null
+++ b/src/network/maemo/qmaemointernetconnectivity.cpp
@@ -0,0 +1,289 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+/*!
+    \class QMaemoInternetConnectivity
+
+    \since 4.5maemo
+
+    \brief The QMaemoInternetConnectivity TODO
+
+    \reentrant
+    \ingroup maemo
+    \inmodule QtNetwork
+
+    QMaemoInternetConnectivity TODO
+*/
+#include "qmaemointernetconnectivity.h"
+#include "qmaemointernetconnectivity_p.h"
+
+#ifdef Q_WS_HILDON
+
+
+QT_BEGIN_NAMESPACE
+
+Q_GLOBAL_STATIC(QMaemoICPrivate, maemoICInstance);
+
+bool QMaemoInternetConnectivity::isConnected(){
+    return maemoICInstance()->isConnected();
+}
+
+static QString currentAPName() {
+    return maemoICInstance()->currentAPName();
+}
+
+void QMaemoInternetConnectivity::connectionRequest(){
+    return maemoICInstance()->connectionRequest();
+}
+
+bool QMaemoInternetConnectivity::isHttpProxyUsed(){
+    return maemoICInstance()->isHttpProxyUsed();
+}
+
+QMaemoICPrivate::QMaemoICPrivate()
+	: connected(UNKNOWN)
+	, icdInterface(0)
+	, icdUiInterface(0)
+{
+	if (!QDBusConnection::systemBus().isConnected()) {
+		qFatal("Cannot connect to the D-BUS session bus.");
+	}
+
+	//Creating D-Bus interfeces
+	icdInterface = new QDBusInterface(ICD_DBUS_SERVICE, ICD_DBUS_PATH,
+			ICD_DBUS_INTERFACE, QDBusConnection::systemBus(), this);
+	icdUiInterface = new QDBusInterface(ICD_UI_DBUS_SERVICE, ICD_UI_DBUS_PATH,
+			ICD_UI_DBUS_INTERFACE, QDBusConnection::systemBus(), this);
+
+	QDBusConnection::systemBus().connect(ICD_DBUS_SERVICE, ICD_DBUS_PATH,
+			ICD_DBUS_INTERFACE, "status_changed",
+			this, SLOT(statusChangedSlot(QString, QString, QString, QString) ));
+
+	//Watching for changes in the proxy settings
+	QString httpProxyDir = QString("/system/http_proxy");
+	if (!QGConfBackend::self()->connect(httpProxyDir, proxySettingsChanged))
+		qWarning() << "QMaemoICPrivate fails to watch for GConf changes in " << httpProxyDir; 
+
+}
+
+QMaemoICPrivate::~QMaemoICPrivate()
+{
+}
+
+bool QMaemoICPrivate::isAutoConnect()
+{
+	QString auto_connect = QGConfBackend::self()->getValue(
+			"/system/osso/connectivity/network_type/auto_connect").toString();
+	//qDebug() << "auto_connect:" << auto_connect;
+
+	int search_interval = QGConfBackend::self()->getValue(
+			"/system/osso/connectivity/network_type/search_interval").toInt();
+	//qDebug() << "search_interval:" << search_interval;
+
+	// Connect automatically:
+	// Always ask -> empty
+	// WLAN -> WLAN_INFRA
+	// Phone -> DUM_... etc.
+	// Any Connection -> *
+	if (auto_connect.isEmpty())
+		return false;
+
+	if (search_interval == 0)
+		return false;
+
+	return true;
+}
+
+bool QMaemoICPrivate::isConnected()
+{
+	//qDebug() << "isConnected() :" << connected;
+	if (connected == UNKNOWN)
+		checkConnectionStatus();
+	return connected;
+}
+
+void QMaemoICPrivate::connectionRequest()
+{
+	if (isConnected()) {
+		//qDebug() << "The device is already connected";
+		return;
+	}
+
+	if (!isAutoConnect()) {
+		//qDebug() << "The device should not auto connect";
+		return;
+	}
+
+	QDBusMessage reply;
+
+	//Check last used network
+	//NOTE: Chinook needs lastApName
+	const QString lastNetwork = lastAPid();
+	//qDebug() << "Last used network is " << lastNetwork;
+	
+	if (lastNetwork.isEmpty()) {
+		//Show the the Access point list to the user
+		reply = icdUiInterface->call(ICD_UI_SHOW_CONNDLG_REQ, false);
+	} else {
+		//Connect to the last Access Point used
+		//qDebug() << "Connecting to" << lastNetwork;
+		quint32 i = 0;
+		reply = icdInterface->call(ICD_CONNECT_REQ, lastNetwork, i);
+	}
+	
+	
+	if (reply.type() == QDBusMessage::ErrorMessage) {
+		readErrorDBusErrorMsg(reply);
+		if (!lastNetwork.isEmpty())
+			icdUiInterface->call(ICD_UI_SHOW_CONNDLG_REQ, false);
+		return;
+	}
+}
+
+bool QMaemoICPrivate::isHttpProxyUsed()
+{
+	if (connected != CONNECTED)
+		return false;
+	return QGConfBackend::self()->getValue("/system/http_proxy/use_http_proxy").toBool();
+}
+
+QString QMaemoICPrivate::currentAPName()
+{
+	if (connected != CONNECTED)
+		return QString();
+	QString gconfKey = iap;
+	gconfKey.prepend("/system/osso/connectivity/IAP/");
+	gconfKey.append("/name");
+	return QGConfBackend::self()->getValue(gconfKey).toString();
+}
+
+QString QMaemoICPrivate::lastAPName()
+{
+	QString gconfKey = lastAPid();
+	if (gconfKey.isEmpty())
+		return QString();
+	gconfKey.prepend("/system/osso/connectivity/IAP/");
+	gconfKey.append("/name");
+	return QGConfBackend::self()->getValue(gconfKey).toString();
+}
+
+QString QMaemoICPrivate::lastAPid()
+{
+	return QGConfBackend::self()->getValue("/system/osso/connectivity/IAP/last_used_network").toString();
+}
+
+//Called by the QGConfBackend instance when the proxy parameters change.
+void QMaemoICPrivate::proxySettingsChanged(QString& key, QVariant value)
+{
+	//qDebug() << "PROXY SETTINGS CHANGED" << key << value;
+	//emit qmic->proxySettingsChangedSig(key, value);
+}
+
+void QMaemoICPrivate::checkConnectionStatus()
+{
+	//qDebug() << "echeckConnectionStatus()";
+	QDBusMessage reply = icdInterface->call(ICD_GET_STATE_REQ);
+
+	if (reply.type() == QDBusMessage::ErrorMessage) {
+		readErrorDBusErrorMsg(reply);
+		connected = UNKNOWN;
+		return;
+	}
+
+	QList<QVariant> values;
+	values = reply.arguments();
+	//qDebug() << "reply arg size:" << values.size();
+#if 0
+	if (values.takeFirst().toInt()) {
+		connected = CONNECTED;
+	} else {
+		connected = DISCONNECTED;
+	}
+#else
+	connected = DISCONNECTED;
+	while (!values.isEmpty()) {
+		int n = values.takeFirst().toInt();
+		//qDebug() << "status:" << n;
+		if (n) {
+		//if (values.takeFirst().toInt()) {
+			connected = CONNECTED;
+			break;
+		}
+	}
+#endif
+	//qDebug() << "echeckConnectionStatus() done";
+}
+
+void QMaemoICPrivate::readErrorDBusErrorMsg(const QDBusMessage& msg)
+{
+	qWarning() << "QMaemoInternetConnectivity has received an error message." << endl
+			   << "Name: " << msg.errorName() << endl
+			   << "Message: " << msg.errorMessage();
+}
+
+void QMaemoICPrivate::statusChangedSlot(QString IAPname, QString networkType, QString state, QString errorCode)
+{
+	//qDebug() << "STATUS CHANGED" << IAPname << networkType << state << errorCode;
+
+	Q_UNUSED(networkType); //TODO
+
+	iap = IAPname;
+
+	if (!errorCode.isEmpty()) {
+		connected= UNKNOWN;
+		qWarning() << errorCode;
+	} else if (state == "CONNECTED") {
+		connected = CONNECTED;
+		//emit icStatusChanged();
+	} else if (state == "CONNECTING") {
+		connected = CONNECTING;
+	} else if (state == "IDLE" && errorCode.isEmpty()) {
+		connected = DISCONNECTED;
+		//emit icStatusChanged();
+	} else if (state == "DISCONNECTING") {
+		connected = DISCONNECTING;
+	}
+	//qDebug() << "CHECK connected=" << connected;
+}
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
diff --git a/src/network/maemo/qmaemointernetconnectivity.h b/src/network/maemo/qmaemointernetconnectivity.h
new file mode 100755
index 0000000..4ac0bdd
--- /dev/null
+++ b/src/network/maemo/qmaemointernetconnectivity.h
@@ -0,0 +1,69 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the unofficial Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtCore/qobject.h>
+
+#ifndef QMAEMOINTERNETCONNECTIVITY_H
+#define QMAEMOINTERNETCONNECTIVITY_H
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+QT_MODULE(Network)
+
+class Q_NETWORK_EXPORT QMaemoInternetConnectivity
+{
+    public: 
+    static bool isConnected();
+    static QString currentAPName(); 
+    static void connectionRequest();
+    static bool isHttpProxyUsed();
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif //Q_WS_HILDON
+
+#endif //QMAEMOINTERNETCONNECTIVITY_H
diff --git a/src/network/maemo/qmaemointernetconnectivity_p.h b/src/network/maemo/qmaemointernetconnectivity_p.h
new file mode 100755
index 0000000..c5218a9
--- /dev/null
+++ b/src/network/maemo/qmaemointernetconnectivity_p.h
@@ -0,0 +1,111 @@
+/****************************************************************************
+**
+** Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: Qt Software Information (qt-info@nokia.com)
+**
+** This file is part of the QtNetwork module of the Maemo Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial Usage
+** Licensees holding valid Qt Commercial licenses may use this file in
+** accordance with the Qt Commercial License Agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Nokia.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain
+** additional rights. These rights are described in the Nokia Qt LGPL
+** Exception version 1.0, included in the file LGPL_EXCEPTION.txt in this
+** package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+** If you are unsure which license is appropriate for your use, please
+** contact the sales department at qt-sales@nokia.com.
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMAEMOINTERNETCONNECTIVITY_P_H
+#define QMAEMOINTERNETCONNECTIVITY_P_H
+
+#include "QtCore/qobject.h"
+#include "QtDBus/qdbusinterface.h"
+#include <QDebug>
+#include "qgconfbackend_p.h"
+
+#include <icd/osso-ic-dbus.h>
+#include <icd/osso-ic-ui-dbus.h>
+
+#ifdef Q_WS_HILDON
+
+QT_BEGIN_NAMESPACE
+
+class QMaemoICPrivate : public QObject
+{
+   Q_OBJECT
+
+   enum connectStatus {
+        UNKNOWN = -1,
+        DISCONNECTED = 0,
+        CONNECTED = 1,
+        DISCONNECTING = 2,
+        CONNECTING = 3
+        //SCAN_START
+        //SCAN_STOP
+   };
+
+public:
+    QMaemoICPrivate();
+    ~QMaemoICPrivate();
+	
+    bool isConnected();
+	bool isAutoConnect();
+    
+    //Show connection dialog.
+    void connectionRequest();
+
+    bool isHttpProxyUsed();
+    QString currentAPName();
+    QString lastAPName();
+
+    QString lastAPid();
+
+    //Called by the QGConfBackend instance when the proxy parameters change.
+    static void proxySettingsChanged(QString& key, QVariant value);
+
+private:
+    void checkConnectionStatus();
+    void readErrorDBusErrorMsg(const QDBusMessage& msg);
+
+private Q_SLOTS:
+    //Update the internal vars with the status_changed signals sent by the daemon via D-Bus
+    void statusChangedSlot(QString IAPname, QString networkType,
+			QString state, QString errorCode);
+
+private:
+   int connected;
+   QDBusInterface *icdInterface;
+   QDBusInterface *icdUiInterface;
+   QString iap; //Internet Access Point
+
+};
+
+QT_END_NAMESPACE
+
+#endif //Q_WS_HILDON
+
+#endif //QMAEMOINTERNETCONNECTIVITY_P_H
diff --git a/src/network/network.pro b/src/network/network.pro
index d476b56..2960f22 100644
--- a/src/network/network.pro
+++ b/src/network/network.pro
@@ -3,7 +3,7 @@
 TARGET   = QtNetwork
 QPRO_PWD = $$PWD
 DEFINES += QT_BUILD_NETWORK_LIB QT_NO_USING_NAMESPACE
-QT = core
+QT = core dbus
 win32-msvc*|win32-icc:QMAKE_LFLAGS += /BASE:0x64000000
 
 unix:QMAKE_PKGCONFIG_REQUIRES = QtCore
@@ -13,5 +13,6 @@ include(access/access.pri)
 include(kernel/kernel.pri)
 include(socket/socket.pri)
 include(ssl/ssl.pri)
+include(maemo/maemo.pri)
 
 QMAKE_LIBS += $$QMAKE_LIBS_NETWORK
diff --git a/src/network/socket/qabstractsocket.cpp b/src/network/socket/qabstractsocket.cpp
index 8281990..4eb3584 100644
--- a/src/network/socket/qabstractsocket.cpp
+++ b/src/network/socket/qabstractsocket.cpp
@@ -355,6 +355,10 @@
 
 #include <time.h>
 
+#ifdef Q_WS_HILDON
+#include <maemo/qmaemointernetconnectivity.h>
+#endif
+
 #define Q_CHECK_SOCKETENGINE(returnValue) do { \
     if (!d->socketEngine) { \
         return returnValue; \
@@ -1292,6 +1296,10 @@ void QAbstractSocket::connectToHostImplementation(const QString &hostName, quint
         d->hostLookupId = -1;
     }
 
+#ifdef Q_WS_HILDON
+    QMaemoInternetConnectivity::connectionRequest();
+#endif
+
 #ifndef QT_NO_NETWORKPROXY
     // Get the proxy information
     d->resolveProxy(hostName, port);
diff --git a/src/opengl/gl2paintengineex/glgc_shader_source.h b/src/opengl/gl2paintengineex/glgc_shader_source.h
index 7f0e1b8..37f93b3 100644
--- a/src/opengl/gl2paintengineex/glgc_shader_source.h
+++ b/src/opengl/gl2paintengineex/glgc_shader_source.h
@@ -234,7 +234,7 @@ static const char* qglslRadialGradientBrushVertexShader = "\
         gl_Position.xy = gl_Position.xy * invertedHTexCoordsZ; \
         gl_Position.w = invertedHTexCoordsZ; \
         A = hTexCoords.xy * invertedHTexCoordsZ; \
-        b = 2.0 * fmp * (A.x + A.y); \
+        b = 2.0 * dot(A, fmp);\
 \
     }";
 
@@ -274,10 +274,12 @@ static const char* qglslConicalGradientBrushFragmentShader = "\n\
     uniform         sampler2D   brushTexture; \
     uniform mediump float       angle; \
     varying highp   vec2        A; \
-    mediump vec4 brush() { \
+    lowp vec4 brush() { \
+        highp float t; \
         if (abs(A.y) == abs(A.x)) \
-            A.y += 0.002; \
-        highp float t = (atan2(-A.y, A.x) + angle) * INVERSE_2PI; \
+            t = (atan(-A.y + 0.002, A.x) + angle) * INVERSE_2PI; \
+        else \
+            t = (atan(-A.y, A.x) + angle) * INVERSE_2PI; \
         return texture2D(brushTexture, vec2(t - floor(t), 0.5)); \
     }\n";
 
diff --git a/src/src.pro b/src/src.pro
old mode 100644
new mode 100755
index f40c6ad..fe72e0b
--- a/src/src.pro
+++ b/src/src.pro
@@ -6,9 +6,10 @@ win32:SRC_SUBDIRS += src_winmain
 wince*:{
   SRC_SUBDIRS += src_corelib src_xml src_gui src_sql src_network src_script src_testlib
 } else {
-    SRC_SUBDIRS += src_tools_bootstrap src_tools_moc src_tools_rcc src_tools_uic src_corelib src_xml src_network src_gui src_sql src_script src_testlib
+    SRC_SUBDIRS += src_tools_bootstrap src_tools_moc src_tools_rcc src_tools_uic src_corelib src_xml 
+    contains(QT_CONFIG, dbus): SRC_SUBDIRS += src_dbus 
+    SRC_SUBDIRS += src_network src_gui src_sql src_script src_testlib
     contains(QT_CONFIG, qt3support): SRC_SUBDIRS += src_qt3support
-    contains(QT_CONFIG, dbus):SRC_SUBDIRS += src_dbus
     !cross_compile {
         contains(QT_CONFIG, qt3support): SRC_SUBDIRS += src_tools_uic3
     }
diff --git a/tools/assistant/compat/mainwindow.cpp b/tools/assistant/compat/mainwindow.cpp
index d3e74fe..09ce15d 100644
--- a/tools/assistant/compat/mainwindow.cpp
+++ b/tools/assistant/compat/mainwindow.cpp
@@ -398,6 +398,7 @@ QString MainWindow::urlifyFileName(const QString &fileName)
     return name;
 }
 
+#ifndef QT_NO_PRINTER
 class PrintThread : public QThread
 {
     QPrinter _printer;
@@ -433,6 +434,7 @@ protected:
         _document = 0;
     }
 };
+#endif
 
 void MainWindow::on_actionFilePrint_triggered()
 {
diff --git a/tools/linguist/linguist/mainwindow.cpp b/tools/linguist/linguist/mainwindow.cpp
index a6ef7c7..bd0e840 100644
--- a/tools/linguist/linguist/mainwindow.cpp
+++ b/tools/linguist/linguist/mainwindow.cpp
@@ -876,6 +876,9 @@ void MainWindow::releaseAll()
 
 void MainWindow::print()
 {
+#ifdef QT_NO_PRINTDIALOG
+    statusBar()->showMessage(tr("Print support is disabled"));
+#else
     int pageNum = 0;
     QPrintDialog dlg(&m_printer, this);
     if (dlg.exec()) {
@@ -953,6 +956,7 @@ void MainWindow::print()
     } else {
         statusBar()->showMessage(tr("Printing aborted"), MessageMS);
     }
+#endif
 }
 
 bool MainWindow::searchItem(const QString &searchWhat)
@@ -1229,6 +1233,9 @@ void MainWindow::editPhraseBook(QAction *action)
 
 void MainWindow::printPhraseBook(QAction *action)
 {
+#ifdef QT_NO_PRINTDIALOG
+    statusBar()->showMessage(tr("Print support is disabled"));
+#else
     PhraseBook *phraseBook = m_phraseBookMenu[PhrasePrintMenu].value(action);
 
     int pageNum = 0;
@@ -1260,6 +1267,7 @@ void MainWindow::printPhraseBook(QAction *action)
     } else {
         statusBar()->showMessage(tr("Printing aborted"), MessageMS);
     }
+#endif
 }
 
 void MainWindow::addToPhraseBook()
diff --git a/tools/linguist/linguist/mainwindow.h b/tools/linguist/linguist/mainwindow.h
index e7ec79b..66f9b85 100644
--- a/tools/linguist/linguist/mainwindow.h
+++ b/tools/linguist/linguist/mainwindow.h
@@ -228,8 +228,11 @@ private:
     QList<QHash<QString, QList<Phrase *> > > m_phraseDict;
     QList<PhraseBook *> m_phraseBooks;
     QMap<QAction *, PhraseBook *> m_phraseBookMenu[3];
-    QPrinter m_printer;
 
+#ifndef QT_NO_PRINTER 
+    QPrinter m_printer;
+#endif
+    
     FindDialog *m_findDialog;
     QString m_findText;
     Qt::CaseSensitivity m_findMatchCase;
diff --git a/tools/linguist/linguist/printout.cpp b/tools/linguist/linguist/printout.cpp
index 772f55d..7e7cfde 100644
--- a/tools/linguist/linguist/printout.cpp
+++ b/tools/linguist/linguist/printout.cpp
@@ -46,6 +46,7 @@
 
 QT_BEGIN_NAMESPACE
 
+#ifndef QT_NO_PRINTER
 PrintOut::PrintOut(QPrinter *printer)
     : pr(printer), nextRule(NoRule), page(0)
 {
@@ -207,4 +208,6 @@ void PrintOut::drawRule(Rule rule)
     }
 }
 
+#endif
+
 QT_END_NAMESPACE
diff --git a/tools/linguist/linguist/printout.h b/tools/linguist/linguist/printout.h
index 5ac493d..b569054 100644
--- a/tools/linguist/linguist/printout.h
+++ b/tools/linguist/linguist/printout.h
@@ -54,6 +54,7 @@ QT_BEGIN_NAMESPACE
 class QPrinter;
 class QFontMetrics;
 
+#ifndef QT_NO_PRINTER
 class PrintOut
 {
 public:
@@ -115,6 +116,8 @@ private:
     int vsize;
 };
 
+#endif
+
 QT_END_NAMESPACE
 
 #endif
